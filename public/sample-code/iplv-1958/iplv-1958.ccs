{
  "id": "iplv-1958-sample",
  "name": "IPL-V (1958)",
  "mode": "critique",
  "description": "Early AI list processing language - Logic Theorist and General Problem Solver",
  "messages": [],
  "codeFiles": [
    {
      "id": "9ea635c0215527e16579dfff2d829d03",
      "name": "README.md",
      "language": "markdown"
    },
    {
      "id": "cacd4d5aa9464d4da2fe10158a9940ec",
      "name": "M54.iplv",
      "language": "iplv"
    }
  ],
  "codeContents": {
    "9ea635c0215527e16579dfff2d829d03": "# IPL-V Module M54 (1958)\n\n## Historical Context\n\nIPL-V (Information Processing Language V) was developed by Allen Newell, Cliff Shaw, and Herbert Simon at RAND Corporation and Carnegie Mellon University between 1956-1958. It represents one of the earliest list processing programming languages, predating LISP and pioneering symbolic computation for artificial intelligence research.\n\nIPL-V was the implementation language for two landmark AI programs:\n- **Logic Theorist** (1956) - First program to prove mathematical theorems\n- **General Problem Solver** (1957) - First program to separate problem-solving strategy from domain knowledge\n\n## Technical Significance\n\nThis is Module M54 from an IPL-V program, demonstrating the language's distinctive features:\n\n### List Processing Architecture\nIPL-V operated on linked list structures in memory, using symbolic addresses and indirect references. Each instruction manipulated list nodes through operations like:\n- **W (Write)**: Store values to memory locations\n- **H (Hold)**: Save temporary values\n- **J (Jump)**: Control flow through symbolic labels\n- **P (Predicate)**: Test conditions on list structures\n\n### Punch Card Format\nThe code uses a fixed nine-field format inherited from 80-column punch cards:\n1. **Label field** (cols 1-8): Subroutine addresses like `M54`, `9-100`\n2. **Type field** (cols 9-13): Operation descriptors like `ADD`, `TEST`\n3. **Name field** (cols 14-40): Human-readable descriptions\n4. **Sign field** (cols 41-45): Address references for branching\n5. **PQ field** (cols 46-50): Primary operation codes (`40W0`, `00J81`, `709-0`)\n6. **Symb field** (cols 51-55): Jump targets and secondary operations\n7. **Link field** (cols 56-60): Additional linking information\n8. **Comments2** (cols 61-70): Variable definitions (`1W0=THMNAM`)\n9. **ID field** (cols 71-80): Unique line identifiers (`M054R000`)\n\n### Assembly-Like Semantics\nIPL-V sits between machine code and high-level languages. Programmers worked with:\n- Symbolic addresses rather than numeric ones\n- Register allocation documented in comments\n- Subroutine calls through label references\n- Conditional execution based on list structure tests\n\n## Critical Code Studies Value\n\nThis code rewards analysis through multiple lenses:\n\n**Computing Archaeology**: IPL-V represents a path not taken—list processing that evolved differently from LISP's S-expressions. The language's design choices reveal assumptions about how symbolic AI should work.\n\n**Materiality of Code**: The punch card format is present in every line. Column positions aren't just conventions; they're physical constraints of the medium. The 80-character limit shaped how programmers thought and commented.\n\n**Infrastructure of AI**: Before neural networks, before expert systems, this was AI—list manipulation, symbolic reasoning, and procedural knowledge. The code shows what \"artificial intelligence\" meant in 1958.\n\n**Documentation Practices**: The extensive human-readable descriptions (column 14-40) show that even assembly-like code required explanation. Variable annotations (`1W0=THMNAM`) document the mental model programmers maintained while working.\n\n**Gendered Labor**: Like other early computing work at RAND and CMU, IPL-V programming involved teams of (often uncredited) women who translated algorithms into punch card format, managed symbol tables, and debugged by hand.\n\n## About This Module\n\nModule M54 appears to handle expression mapping and theorem naming operations. Key functions include:\n\n- **Main entry (M54)**: Adds expressions to a map structure\n- **Subprocess (9-100)**: Adds segments to maps with variable/name handling\n- **Conditional branching** (9-102, 9-110): Tests list structures and creates submaps\n- **Name list management**: Tests for simple variables vs. complex expressions\n\nThe code demonstrates IPL-V's approach to symbolic manipulation—everything is a list, and processing means traversing, testing, and restructuring these lists.\n\n## About the Creators\n\n**Allen Newell** (1927-1992): Cognitive scientist who pioneered AI and cognitive architecture research. Co-creator of the Logic Theorist and General Problem Solver.\n\n**J. Clifford Shaw** (1922-1991): RAND Corporation systems programmer who designed IPL's list processing primitives. Key figure in early AI programming.\n\n**Herbert A. Simon** (1916-2001): Economist, political scientist, and cognitive psychologist. Nobel Prize winner (Economics, 1978) and Turing Award winner (1975) for foundational contributions to AI and decision-making.\n\nIPL-V was created at RAND Corporation's Santa Monica facility and Carnegie Mellon University (then Carnegie Tech), centers of early Cold War computing research funded by ARPA and the Air Force.\n\n## Source\n\n- **Language**: IPL-V (Information Processing Language V)\n- **Date**: ca. 1958\n- **Module**: M54\n- **Lines of Code**: 60\n- **Format**: 80-column punch card (9-field fixed format)\n- **Machine**: JOHNNIAC computer at RAND Corporation\n\n## Suggested Annotations\n\nWhen analyzing this code, consider:\n\n1. **Label references** (columns 1-8, 41-45): How do subroutine addresses like `9-100`, `9-0` organize the control flow? What does the numbering scheme tell us about program structure?\n\n2. **Operation codes** (columns 46-50): Decode opcodes like `40W0`, `00J81`, `709-0`. What operations are most common? What does this reveal about IPL-V's computational model?\n\n3. **Human descriptions** (columns 14-40): Compare the English descriptions to the actual operations. Where do they diverge? What assumptions do they make about the reader?\n\n4. **Variable annotations** (columns 61-70): Assignments like `1W0=THMNAM`, `1W1=MAP` document register usage. How does this memory model differ from modern programming?\n\n5. **Conditional logic** (lines 100-120): The `TEST IF SIMPLE VARIABLE` section shows branching. How does IPL-V represent if-then-else?\n\n6. **List processing patterns**: Identify operations that manipulate list structures. How does IPL-V's list model compare to LISP?\n\n7. **Subroutine calls**: Trace the flow from `M54` through `9-100` to other labels. How does IPL-V handle function calls and returns?\n\n8. **Punch card constraints**: Notice the rigid column structure. How did this physical format shape programming practices?\n\n9. **Symbol table management**: The comments document what each register holds. How did programmers maintain this mental model?\n\n10. **Historical computing labor**: Consider who wrote, punched, and debugged this code. What was the social organization of IPL-V programming?\n",
    "cacd4d5aa9464d4da2fe10158a9940ec": "     M54 ADD TOTAL EXPRESSION (0) TO      M54   40W0                    M054R000\n        MAP OF TRUE EXPRESSIONS (1).            60W0          1W0=THMNAMM054R010\n                                                00J81                   M054R020\n                                                709-0         (0)=MEX   M054R030\n                                                00J6                    M054R040\n     ADD MAIN SEGMENT (1) TO MAP (0).           009-100 J30             M054R050\n                                          9-0   30H0    J30             M054R060\n     9-100 SUBPROCESS, ADD SEGMENT (1)    9-100 04J43         1W0=THMNAMM054R070\n                       TO MAP (0).              20W1          1W1=MAP   M054R080\n                                                60W2          1W2=SEGMNTM054R090\n     TEST IF SIMPLE VARIABLE.                   00P8                    M054R100\n        IF NO, CONTINUE DOWN MAP.               709-102                 M054R110\n        IF YES, ADD THNAME.                     11W1                    M054R120\n     TEST IF NAME LIST IN MAP HEAD.             00J79                   M054R130\n        IF NO, GO MAKE ONE.                     709-101                 M054R140\n        IF YES,                                 12W1                    M054R150\n                                                11W0                    M054R160\n     INSERT NAME AND QUIT.                      00J64   J33             M054R170\n                                          9-101 11W0                    M054R180\n     CREATE LIST OF ONE NAME.                   00J91                   M054R190\n                                                00J136                  M054R200\n     PLACE IN MAP HEAD AND QUIT.                21W1    J33             M054R210\n     INPUT MAP HOLDER.                    9-102 10W1                    M054R220\n     INPUT SEGMENT CONNECTIVE.                  12W2                    M054R230\n     FIND SUBMAPS LIST.                         00J10                   M054R240\n        IF FOUND, CONTINUE.                     70      9-110           M054R250\n        IF NONE,                                10W1                    M054R260\n                                                00J90                   M054R270\n     CREATE 1ST LOCAL SUBMAP.                   00J136                  M054R280\n                                                12W2                    M054R290\n     TEST IF 2ND SUBLIST NEEDED.                00P6                    M054R300\n        IF NO, SKIP IT.                         709-111                 M054R310\n        IF YES,                                 40H0                    M054R320\n     CREATE 2ND LOCAL SUBMAP.                   00J120                  M054R330\n                                                00J92   9-112           M054R340\n     CREATE SUBMAP LIST.                  9-111 00J91                   M054R350\n                                          9-112 00J136                  M054R360\n                                                60W3          1W3=MAPLSTM054R370\n                                                12W2                    M054R380\n     ASSIGN AS SUBMAP LIST OF CONNECTIVE        00J11                   M054R390\n                                                11W3    9-110           M054R400\n                                          9-110 20W3          1W3=MAPLSTM054R410\n                                                11W2                    M054R420\n     FIND 1ST SUB SEGMENT.                      00J81                   M054R430\n        IF NONE, QUIT.                          70J33                   M054R440\n                                                11W3                    M054R450\n     FIND 1ST SUB MAP.                          00J81                   M054R460\n        IF NONE, QUIT.                          709-114                 M054R470\n     ADD SEGMENT (1) TO SUBMAP (0).             009-100                 M054R480\n                                                12W2                    M054R490\n     TEST IF MORE SEGMENTS.                     00P6                    M054R500\n        IF NO, QUIT.                            70J33                   M054R510\n                                                11W2                    M054R520\n     FIND 2ND SUBSEGMENT.                       00J82                   M054R530\n        IF NONE, QUIT.                          70J33                   M054R540\n                                                11W3                    M054R550\n     FIND 2ND SUBMAP.                           00J82                   M054R560\n        IF NONE, QUIT.                          709-114                 M054R570\n     ADD SEGMENT (1) TO SUBMAP (0).             009-100 J33             M054R580\n                                          9-114 30H0    J33             M054R600\n"
  },
  "lineAnnotations": []
}