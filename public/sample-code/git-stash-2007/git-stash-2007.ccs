{
  "id": "git-stash-2007-sample",
  "name": "Git Stash (2007) by Nanako Shiraishi",
  "mode": "critique",
  "description": "Original git-stash.sh shell script - feminist computing history and workplace interruption",
  "messages": [],
  "codeFiles": [
    {
      "id": "readme-git-stash",
      "name": "README.md",
      "language": "markdown",
      "source": "shared",
      "size": 4649,
      "uploadedAt": "2026-01-30T13:52:26.954Z"
    },
    {
      "id": "git-stash-sh",
      "name": "git-stash.sh",
      "language": "shell",
      "source": "shared",
      "size": 3312,
      "uploadedAt": "2026-01-30T13:52:26.955Z"
    }
  ],
  "codeContents": {
    "readme-git-stash": "# Git Stash (2007)\n\n## Historical Context\n\nThis is the original `git-stash.sh` shell script written by Nanako Shiraishi in June 2007, committed to the Git project as `f2c66ed196d1d1410d014e4ee3e2b585936101f5`.\n\n## Feminist Computing History\n\nThis code represents a significant moment in feminist computing history. Lines 24-48 of the original script were written by Nanako Shiraishi in June 2007, in response to repeated interruptions from her boss. The commit message she left documents this context directly.\n\nFrom that moment on, programmers who are interrupted during their work have been able to \"freeze\" their code, solve the external problem, and then return to their work without risking the loss of any changes. The interruption—a universal experience in software labor, but particularly documented in studies of women's workplace experiences—led to the creation of `git stash`, a tool designed to handle exactly this problem.\n\nLines 24-48 contain the `save_stash()` function, which captures the material conditions of software labor: the need to set aside unfinished work, preserve state across interruptions, and resume later. This is not merely a technical solution but an encoding of workplace power dynamics and the fragmented attention economy of programming labor.\n\nThis fragment reminds us that source code is immaterial but not abstract. It is also an example of how programmers write programs not only to solve others' problems, but also to improve the quality of their own lives; by sharing their work as free software, they help millions of other programmers in the same condition.\n\n## Technical Significance\n\nThis small script adds a new functionality (the stash command) to the Git environment, which is probably the most used collaborative version control system. The stash command simply saves a temporary copy of the code being written without having to declare it as final (as in the git commit command) or before sharing it with others (as in the push command).\n\nThe `git-stash` command solved a universal programmer problem:\n- Quickly save uncommitted changes without creating a commit\n- Switch contexts (branches, tasks) cleanly\n- Restore work later without losing progress\n- Handle workplace interruptions without losing work\n\nBefore `git stash`, developers had to either:\n- Create temporary commits (cluttering history)\n- Manually backup files (error-prone)\n- Risk losing work when switching branches\n\n## Critical Code Studies Value\n\nThis code rewards analysis through multiple lenses:\n\n**Labor Studies**: Code as artifact of workplace interruption and context switching costs\n\n**Feminist Technology Studies**: Early female contributor to Git; gendered patterns of interruption; tool design emerging from lived experience\n\n**Infrastructure Studies**: How version control systems encode assumptions about workflow and attention management\n\n**Software Studies**: The command's design philosophy—temporary storage, stack-based operations, automatic cleanup\n\n## About Nanako Shiraishi\n\nOne of the early contributors to the Git project during its foundational years (2006-2008), Shiraishi contributed numerous improvements to Git's core functionality during a period when the project was rapidly evolving from Linus Torvalds's initial design.\n\nWe can learn much from this commit: she's one of the first women to contribute to the project; she likely lived in Japan; she cared enough about this script to contribute on a Saturday afternoon. We have the exact time and context of the action of writing the code, but we do not know anything else about the author, apart from the name and an e-mail address. We can't go beyond that point: we are left with our questions and with the legacy of someone who was once interrupted by her boss.\n\nThe original stash script has long disappeared from Git's codebase (replaced by more sophisticated implementations), yet commit f2c66ed196d1d1410d014e4ee3e2b585936101f5 will always lead us right back to Shiraishi's contribution.\n\n## Source\n\n- **Original Commit**: f2c66ed196d1d1410d014e4ee3e2b585936101f5\n- **Date**: June 2007\n- **Repository**: https://github.com/git/git\n- **Language**: Shell script (Bash)\n- **Lines of Code**: ~150\n\n## Suggested Annotations\n\nWhen analyzing this code, consider:\n\n1. The `save_stash()` function's structure—how it captures multiple states (index, working tree, base commit)\n2. Variable naming choices and their semantic meaning\n3. Error handling patterns and what failures are anticipated\n4. The merge strategy used to restore stashed changes\n5. How the tool conceptualizes \"work in progress\"\n6. The temporal assumptions embedded in the stash metaphor\n",
    "git-stash-sh": "#!/bin/sh\n# Copyright (c) 2007, Nanako Shiraishi\n\nUSAGE='[ | list | show | apply | clear]'\n\n. git-sh-setup\nrequire_work_tree\n\nTMP=\"$GIT_DIR/.git-stash.$$\"\ntrap 'rm -f \"$TMP-*\"' 0\n\nref_stash=refs/stash\n\nno_changes () {\n\tgit-diff-index --quiet --cached HEAD &&\n\tgit-diff-files --quiet\n}\n\nclear_stash () {\n\tlogfile=\"$GIT_DIR/logs/$ref_stash\" &&\n\tmkdir -p \"$(dirname \"$logfile\")\" &&\n\t: >\"$logfile\"\n}\n\nsave_stash () {\n\tif no_changes\n\tthen\n\t\techo >&2 'No local changes to save'\n\t\texit 0\n\tfi\n\ttest -f \"$GIT_DIR/logs/$ref_stash\" ||\n\t\tclear_stash || die \"Cannot initialize stash\"\n\n\t# state of the base commit\n\tif b_commit=$(git-rev-parse --verify HEAD)\n\tthen\n\t\thead=$(git-log --abbrev-commit --pretty=oneline -n 1 HEAD)\n\telse\n\t\tdie \"You do not have the initial commit yet\"\n\tfi\n\n\tif branch=$(git-symbolic-ref -q HEAD)\n\tthen\n\t\tbranch=${branch#refs/heads/}\n\telse\n\t\tbranch='(no branch)'\n\tfi\n\tmsg=$(printf '%s: %s' \"$branch\" \"$head\")\n\n\t# state of the index\n\ti_tree=$(git-write-tree) &&\n\ti_commit=$(printf 'index on %s' \"$msg\" |\n\t\tgit-commit-tree $i_tree -p $b_commit) ||\n\t\tdie \"Cannot save the current index state\"\n\n\t# state of the working tree\n\tw_tree=$( (\n\t\tGIT_INDEX_FILE=\"$TMP-index\" &&\n\t\texport GIT_INDEX_FILE &&\n\n\t\trm -f \"$TMP-index\" &&\n\t\tgit-read-tree $i_tree &&\n\t\tgit-add -u &&\n\t\tgit-write-tree &&\n\t\trm -f \"$TMP-index\"\n\t) ) ||\n\t\tdie \"Cannot save the current worktree state\"\n\n\t# create the stash\n\tw_commit=$(printf 'WIP on %s' \"$msg\" |\n\t\tgit-commit-tree $w_tree -p $b_commit -p $i_commit) ||\n\t\tdie \"Cannot record working tree state\"\n\n\tgit-update-ref -m \"$msg\" $ref_stash $w_commit ||\n\t\tdie \"Cannot save the current status\"\n\tprintf >&2 'Saved WIP on %s\\n' \"$msg\"\n}\n\nlist_stash () {\n\tgit-log --pretty=oneline -g \"$@\" $ref_stash |\n\tsed -n -e 's/^[.0-9a-f]* refs\\///p'\n}\n\nshow_stash () {\n\tflags=$(git-rev-parse --no-revs --flags \"$@\")\n\tif test -z \"$flags\"\n\tthen\n\t\tflags=--stat\n\tfi\n\ts=$(git-rev-parse --revs-only --no-flags --default $ref_stash \"$@\")\n\n\tw_commit=$(git-rev-parse --verify \"$s\") &&\n\tb_commit=$(git-rev-parse --verify \"$s^\") &&\n\tgit-diff $flags $b_commit $w_commit\n}\n\napply_stash () {\n\tgit-diff-files --quiet ||\n\t\tdie 'Cannot restore on top of a dirty state'\n\n\t# current index state\n\tc_tree=$(git-write-tree) ||\n\t\tdie 'Cannot apply a stash in the middle of a merge'\n\n\ts=$(git-rev-parse --revs-only --no-flags --default $ref_stash \"$@\") &&\n\tw_tree=$(git-rev-parse --verify \"$s:\") &&\n\tb_tree=$(git-rev-parse --verify \"$s^:\") ||\n\t\tdie \"$*: no valid stashed state found\"\n\n\teval \"\n\t\tGITHEAD_$w_tree='Stashed changes' &&\n\t\tGITHEAD_$c_tree='Updated upstream' &&\n\t\tGITHEAD_$b_tree='Version stash was based on' &&\n\t\texport GITHEAD_$w_tree GITHEAD_$c_tree GITHEAD_$b_tree\n\t\"\n\n\tif git-merge-recursive $b_tree -- $c_tree $w_tree\n\tthen\n\t\t# No conflict\n\t\ta=\"$TMP-added\" &&\n\t\tgit-diff --cached --name-only --diff-filter=A $c_tree >\"$a\" &&\n\t\tgit-read-tree --reset $c_tree &&\n\t\tgit-update-index --add --stdin <\"$a\" ||\n\t\t\tdie \"Cannot unstage modified files\"\n\t\tgit-status\n\t\trm -f \"$a\"\n\telse\n\t\t# Merge conflict; keep the exit status from merge-recursive\n\t\texit\n\tfi\n}\n\n# Main command set\ncase \"$1\" in\nlist)\n\tshift\n\tif test $# = 0\n\tthen\n\t\tset x -n 10\n\t\tshift\n\tfi\n\tlist_stash \"$@\"\n\t;;\nshow)\n\tshift\n\tshow_stash \"$@\"\n\t;;\napply)\n\tshift\n\tapply_stash \"$@\"\n\t;;\nclear)\n\tclear_stash\n\t;;\n'')\n\tsave_stash && git-reset --hard\n\t;;\n*)\n\tusage\nesac\n"
  },
  "lineAnnotations": []
}