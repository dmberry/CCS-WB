{
  "id": "flowmatic-1958-sample",
  "name": "FLOW-MATIC (1958) by Grace Hopper",
  "mode": "critique",
  "description": "First English-like business programming language - natural language and feminist computing history",
  "messages": [],
  "codeFiles": [
    {
      "id": "readme-flowmatic",
      "name": "README.md",
      "language": "markdown",
      "source": "shared",
      "size": 6074,
      "uploadedAt": "2026-01-30T14:15:20.836Z"
    },
    {
      "id": "problem1-flo",
      "name": "Problem1.flo",
      "language": "flowmatic",
      "source": "shared",
      "size": 920,
      "uploadedAt": "2026-01-30T14:15:20.837Z"
    },
    {
      "id": "problem3-flo",
      "name": "Problem3.flo",
      "language": "flowmatic",
      "source": "shared",
      "size": 1380,
      "uploadedAt": "2026-01-30T14:15:20.837Z"
    }
  ],
  "codeContents": {
    "readme-flowmatic": "# FLOW-MATIC (1958)\n\n## Historical Context\n\nFLOW-MATIC, originally known as B-0 (Business Language version 0), was the first English-like data processing language, developed by Grace Hopper and her team at Remington Rand for the UNIVAC I computer between 1955 and 1959. The FLOW-MATIC compiler became publicly available in early 1958 and was substantially complete in 1959.\n\nThis revolutionary language marked a fundamental shift in programming philosophy: code could be written in readable business English rather than mathematical symbols or machine instructions.\n\n## Feminist Computing History\n\nGrace Murray Hopper (1906-1992) was a pioneering computer scientist, U.S. Navy rear admiral, and one of the first programmers of the Harvard Mark I computer. As a woman in mid-20th century computing, Hopper fought against institutional resistance to her innovations.\n\nWhen she proposed the first compiler in 1952, she recalled: \"Nobody believed that. I had a running compiler and nobody would touch it. They told me computers could only do arithmetic; they could not do programs.\"\n\nFLOW-MATIC embodied Hopper's philosophy of democratizing programming. She explained the motivation: \"They said, 'Throw those symbols out - I do not know what they mean, I have not time to learn symbols.' I've spent most of my life getting rid of symbols.\"\n\nThis was not merely a technical choice but a political one: making programming accessible to business users, many of whom were women working in data processing departments, rather than restricting it to mathematically-trained (predominantly male) specialists.\n\n## Technical Innovation - Business English\n\nFLOW-MATIC pioneered natural language programming with statements like:\n\n```\nINPUT INVENTORY FILE-A PRICE FILE-B ; OUTPUT PRICED-INV FILE-C .\nCOMPARE PRODUCT-NO (A) WITH PRODUCT-NO (B) ; IF GREATER GO TO OPERATION 10 .\nTRANSFER A TO D .\n```\n\nKey innovations:\n- **English keywords**: READ, WRITE, COMPARE, TRANSFER instead of symbolic operations\n- **Named variables**: PRODUCT-NO, UNIT-PRICE instead of memory addresses\n- **Declarative style**: Describe what you want, not how to do it\n- **Business domain**: Designed for inventory, payroll, billing tasks\n- **Self-documenting**: Code readable by non-programmers\n\n## \"It's Easier to Ask Forgiveness Than Permission\"\n\nThis programming philosophy, often attributed to Hopper, manifests in FLOW-MATIC's design:\n- Assume users want readable code, don't ask permission to make it so\n- Build tools that work for people, not the other way around\n- Challenge institutional resistance through working implementations\n\n## COBOL's Ancestor\n\nFLOW-MATIC directly influenced COBOL (1959). The COBOL design committee, which Hopper served on, drew heavily from FLOW-MATIC's English-like syntax. Many COBOL statements are nearly identical to their FLOW-MATIC predecessors.\n\nThis legacy means FLOW-MATIC's philosophy shaped decades of business computing - for better or worse. While it democratized programming, it also established verbose, procedural patterns that later generations would critique.\n\n## Critical Code Studies Value\n\nThis code rewards analysis through multiple lenses:\n\n**Feminist Technology Studies**: Woman-led innovation; democratization vs. gatekeeping; challenging mathematical hegemony in computing; making space for \"non-technical\" users\n\n**Language Design**: Natural language as programming interface; tradeoffs between readability and precision; English as universal vs. English imperialism\n\n**Labor Studies**: Who gets to program? Business users vs. specialists; deskilling vs. empowerment; clerical work and computing\n\n**Infrastructure Studies**: Languages as material; UNIVAC I constraints; batch processing assumptions; punch card culture\n\n**Software Studies**: Declarative vs. imperative; self-documenting code ideals; verbosity as feature vs. bug\n\n## About Grace Hopper\n\nGrace Hopper's contributions extend far beyond FLOW-MATIC:\n- Invented the first compiler (A-0, 1952)\n- Coined the term \"bug\" for computer errors (finding a moth in Harvard Mark II)\n- Developed COBOL specifications\n- Promoted standardization and portability\n- Championed human-readable programming for four decades\n- Known for her \"nanosecond\" visual aids (11.8-inch wire representing light travel time)\n\nHer famous motto: \"The most dangerous phrase in the language is, 'We've always done it this way.'\"\n\n## Source\n\n- **Original Manual**: U1518 FLOW-MATIC Programming System (1958)\n- **Archive**: [Bitsavers.org](http://www.bitsavers.org/pdf/univac/flow-matic/U1518_FLOW-MATIC_Programming_System_1958.pdf)\n- **Platform**: UNIVAC I and UNIVAC II\n- **Language**: Business English notation\n- **Era**: 1955-1959 development, 1958 public release\n\n## Suggested Annotations\n\nWhen analyzing these programs, consider:\n\n1. **English-like syntax** - What makes this \"readable\"? Who can read it?\n2. **OPERATION numbering** - How does explicit sequencing shape program structure?\n3. **File metaphors** - INPUT, OUTPUT, READ-ITEM, WRITE-ITEM - what assumptions about data?\n4. **Comparison logic** - IF GREATER, IF EQUAL - naturalizing computational operations\n5. **JUMP statements** - How do GOTOs and JUMPs structure flow despite \"high-level\" appearance?\n6. **Variable naming** - PRODUCT-NO, UNIT-PRICE - domain-specific vs. abstract\n7. **Comments in parentheses** - (0), (1), (END) - numbering as documentation\n8. **Assumed knowledge** - What business context must programmers bring?\n9. **Gender and work** - Who was expected to write and maintain this code?\n10. **ZZZZZZZZZZZZ sentinel** - End-of-file markers and batch processing assumptions\n\n## References\n\n- Hopper, G. M. (1952). \"The Education of a Computer.\" *Proceedings of the ACM Conference*\n- Sammet, J. E. (1969). *Programming Languages: History and Fundamentals*. Prentice-Hall\n- GÃ¼rer, D. (1995). \"Pioneering Women in Computer Science.\" *Communications of the ACM* 38(1)\n- Abbate, J. (2012). *Recoding Gender: Women's Changing Participation in Computing*. MIT Press\n- Light, J. S. (1999). \"When Computers Were Women.\" *Technology and Culture* 40(3)\n",
    "problem1-flo": "FLOW-MATIC PROBLEM 1: JOIN INVENTORY AND PRICES\n\n(0)  INPUT INVENTORY FILE-A PRICE FILE-B ; OUTPUT PRICED-INV FILE-C UNPRICED-INV\n     FILE-D ; HSP D .\n\n(1)  COMPARE PRODUCT-NO (A) WITH PRODUCT-NO (B) ; IF GREATER GO TO OPERATION 10 ;\n     IF EQUAL GO TO OPERATION 5 ; OTHERWISE GO TO OPERATION 2 .\n\n(2)  TRANSFER A TO D .\n\n(3)  WRITE-ITEM D .\n\n(4)  JUMP TO OPERATION 8 .\n\n(5)  TRANSFER A TO C .\n\n(6)  MOVE UNIT-PRICE (B) TO UNIT-PRICE (C) .\n\n(7)  WRITE-ITEM C .\n\n(8)  READ-ITEM A ; IF END OF DATA GO TO OPERATION 14 .\n\n(9)  JUMP TO OPERATION 1 .\n\n(10) TRANSFER B TO C .\n\n(11) MOVE ZERO TO UNIT-PRICE (C) .\n\n(12) WRITE-ITEM C .\n\n(13) READ B ; IF END OF DATA GO TO OPERATION 16 ; OTHERWISE GO TO OPERATION 1 .\n\n(14) SET OPERATION 10 TO GO TO OPERATION 12 .\n\n(15) JUMP TO OPERATION 13 .\n\n(16) TEST PRODUCT-NO (A) ; IF ZZZZZZZZZZZZ STOP RUN ; OTHERWISE GO TO OPERATION 2 .\n\n(17) CLOSE-OUT FILES C ; D .\n\n(END) STOP . (END)\n",
    "problem3-flo": "FLOW-MATIC PROBLEM 3: JOIN INVENTORY AT MULTIPLE SITES WITH PRICES\n\n(0)  INPUT INVENTORY FILE-A PRICE FILE-B ; OUTPUT PRICED-INV FILE-C UNPRICED-INV\n     FILE-D ; HSP D .\n\n(1)  COMPARE PRODUCT-NO (A) WITH PRODUCT-NO (B) ; IF GREATER GO TO OPERATION 10 ;\n     IF EQUAL GO TO OPERATION 5 ; OTHERWISE GO TO OPERATION 2 .\n\n(2)  TRANSFER A TO D .\n\n(3)  WRITE-ITEM D .\n\n(4)  JUMP TO OPERATION 8 .\n\n(5)  TRANSFER A TO C .\n\n(6)  MOVE UNIT-PRICE (B) TO UNIT-PRICE (C) .\n\n(7)  WRITE-ITEM C .\n\n(8)  READ-ITEM A ; IF END OF DATA GO TO OPERATION 20 .\n\n(9)  JUMP TO OPERATION 1 .\n\n(10) TRANSFER B TO C .\n\n(11) MOVE ZERO TO UNIT-PRICE (C) .\n\n(12) WRITE-ITEM C .\n\n(13) READ B ; IF END OF DATA GO TO OPERATION 22 ; OTHERWISE GO TO OPERATION 1 .\n\n(14) MOVE ZERO TO QTY-ON-HAND (A) .\n\n(15) READ A AT END GO TO OPERATION 20 ; OTHERWISE GO TO OPERATION 16 .\n\n(16) COMPARE PRODUCT-NO (A) WITH PRODUCT-NO (D) ; IF EQUAL GO TO OPERATION 17 ;\n     OTHERWISE GO TO OPERATION 3 .\n\n(17) ADD QTY-ON-HAND (A) TO QTY-ON-HAND (D) .\n\n(18) DELETE A .\n\n(19) JUMP TO OPERATION 15 .\n\n(20) SET OPERATION 10 TO GO TO OPERATION 12 .\n\n(21) JUMP TO OPERATION 13 .\n\n(22) TEST PRODUCT-NO (A) ; IF ZZZZZZZZZZZZ GO TO OPERATION 25 ; OTHERWISE GO TO\n     OPERATION 14 .\n\n(23) CLOSE-OUT FILES C ; D .\n\n(24) STOP .\n\n(25) IF QTY-ON-HAND (D) NOT EQUAL TO ZERO GO TO OPERATION 3 .\n\n(26) DELETE D .\n\n(27) JUMP TO OPERATION 8 . (END)\n"
  },
  "lineAnnotations": []
}