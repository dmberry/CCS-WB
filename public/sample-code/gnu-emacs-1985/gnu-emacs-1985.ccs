{
  "id": "gnu-emacs-1985-sample",
  "name": "GNU Emacs (1985)",
  "mode": "critique",
  "description": "Free software movement - GPL, Emacs Lisp, and hacker culture",
  "messages": [],
  "codeFiles": [
    {
      "id": "8ed5338386825371f46fbd3307bc66e5",
      "name": "README.md",
      "language": "markdown"
    },
    {
      "id": "5b0e227dedf8e3501d8db3062562711d",
      "name": "GNU-MANIFESTO",
      "language": "plain"
    },
    {
      "id": "93bfcccf44f9ba3f267c1a42fac717e3",
      "name": "COPYING",
      "language": "plain"
    },
    {
      "id": "899be733dfe5ad520e75357d709330b5",
      "name": "ChangeLog",
      "language": "plain"
    },
    {
      "id": "afad1f11d455300d3b665d4d3bfe7e0b",
      "name": "simple.el",
      "language": "lisp"
    },
    {
      "id": "2aabc772ab4d533f1ce11fd701999ff3",
      "name": "files.el",
      "language": "lisp"
    },
    {
      "id": "8e9ac73dc9bd0cf2595c3eb27a623818",
      "name": "window.el",
      "language": "lisp"
    },
    {
      "id": "08ea0a716b5e1caf9be9f83bcc81ca17",
      "name": "abbrev.el",
      "language": "lisp"
    },
    {
      "id": "ead6847c686cfbed9b7cede06a0f867f",
      "name": "dired.el",
      "language": "lisp"
    },
    {
      "id": "f4fbfb8095b301cccfad2191c925068c",
      "name": "compile.el",
      "language": "lisp"
    },
    {
      "id": "defc0f3a5014407b3acca8a56a23c8b7",
      "name": "mail-utils.el",
      "language": "lisp"
    },
    {
      "id": "ede625fcabadc27dfbf5e7698870a3a4",
      "name": "doctor.el",
      "language": "lisp"
    },
    {
      "id": "397167203e546383f257250af82cb658",
      "name": "emacs.c",
      "language": "c"
    },
    {
      "id": "342bcb7ae276c1ef948a36939ca0376b",
      "name": "lisp.h",
      "language": "c"
    }
  ],
  "codeContents": {
    "8ed5338386825371f46fbd3307bc66e5": "# GNU Emacs (1985)\n\n## Historical Context\n\nGNU Emacs was released by Richard Stallman in March 1985 as the first major component of the GNU Project (launched in 1983). Written primarily in C with an extensible Emacs Lisp interpreter, GNU Emacs became both a powerful text editor and a manifesto of the free software movement encoded in executable form.\n\nThe first public release was version 15.34 in March 1985, distributed via UUCP and anonymous FTP with explicit permission to copy, modify, and redistribute the source code.\n\n## The Free Software Movement\n\nGNU Emacs emerged from Richard Stallman's experience at the MIT AI Lab, where a culture of software sharing and collaborative hacking had flourished since the 1960s. When proprietary software companies began restricting access to source code in the early 1980s, Stallman saw this as an ethical crisis threatening programmer autonomy and collective knowledge.\n\nIn September 1983, Stallman announced the GNU Project (GNU's Not Unix) with the goal of creating a complete Unix-compatible operating system composed entirely of free software. \"Free\" here meant freedom: users should have the right to run, copy, distribute, study, change, and improve the software.\n\nGNU Emacs was the first substantial GNU program, demonstrating that high-quality, feature-rich software could be developed collaboratively without proprietary restrictions. Its success proved the viability of the free software model and inspired the development of other GNU tools (GCC, GDB, Bash) that would eventually form the foundation of GNU/Linux systems.\n\n## Hacker Culture and Labor\n\nStallman's philosophy emerged from MIT AI Lab hacker culture, where:\n- Source code was shared freely among programmers\n- Improvements were collective achievements, not proprietary assets\n- Programmers had autonomy to modify their tools\n- Knowledge belonged to the community, not corporations\n\nThe shift to proprietary software in the early 1980s disrupted this culture. Companies like Symbolics hired away MIT hackers and locked up their code. Printers shipped without source code, preventing users from fixing bugs. Stallman experienced this directly when Xerox refused to share printer driver source code, leaving users unable to implement basic features like network print notifications.\n\nGNU Emacs was Stallman's response: a reassertion of programmer autonomy and collective ownership of tools. By keeping the source code free and encouraging modifications, Emacs embodied an alternative labor practice—one where programmers controlled their means of production.\n\n## Technical Innovation\n\nGNU Emacs introduced several innovations that influenced editor design:\n\n- **Lisp-based extensibility**: Most editor functionality implemented in Emacs Lisp, making the editor infinitely customizable\n- **Self-documenting**: Every function and key binding includes documentation accessible via `C-h`\n- **Incremental search**: Real-time search feedback as you type\n- **Syntax highlighting**: Context-aware colorization of code\n- **Integrated environment**: Email, news, debugging, version control, and more—all within Emacs\n- **Buffer model**: Multiple files and processes managed simultaneously\n\nThe Lisp interpreter made Emacs not just a text editor but a Lisp machine—a programmable environment where users could extend and reshape the tool to their needs.\n\n## The GNU General Public License\n\nGNU Emacs was initially distributed with informal sharing terms. In 1989, Stallman formalized these principles in the GNU General Public License (GPL), introducing \"copyleft\"—a legal mechanism ensuring that software and all derivatives remain free.\n\nThe GPL inverts copyright law: instead of restricting distribution, it guarantees freedoms and ensures those freedoms propagate to all downstream users. This innovation in licensing became the legal foundation for the free software movement.\n\n## Critical Code Studies Value\n\nThis code rewards analysis through multiple lenses:\n\n**Labor Studies**: Programmer autonomy; collective knowledge vs. proprietary enclosure; hacker culture as alternative labor practice; the politics of software ownership\n\n**Software Studies**: Editor as Lisp environment; self-documenting code; extensibility as political principle; the editor as operating system\n\n**Infrastructure Studies**: Free software as infrastructure commons; dependency graphs and software freedom; GNU toolchain as foundation for Linux\n\n**Legal Studies**: Copyleft and GPL; intellectual property resistance; licensing as activism\n\n**Political Economy**: Software commodification; communal production; open source vs. free software ideological distinctions\n\n## About Richard Stallman\n\nRichard Matthew Stallman (b. 1953) founded the Free Software Foundation (1985) and authored the GNU Manifesto, GNU General Public License, and numerous GNU tools. A staff programmer at MIT AI Lab from 1971-1984, he witnessed the transformation of academic computing from collaborative to proprietary.\n\nStallman's uncompromising stance on software freedom—insisting on \"free as in freedom, not free as in beer\"—established principles that continue to shape debates about software ethics, intellectual property, and digital commons.\n\nHis famous quote: \"Proprietary software is an injustice in itself because it denies users freedom.\"\n\n## Source\n\n- **First Release**: GNU Emacs 15.34 (March 1985)\n- **Repository**: GNU FTP archives (ftp.gnu.org)\n- **Language**: C and Emacs Lisp\n- **Platform**: Unix systems (VAX, Sun, HP, etc.)\n- **License**: Initially informal sharing terms; GPL from 1989 onward\n- **Lines of Code**: ~160,000 (modern versions exceed 1 million)\n\n## Key Files Included\n\n**Important**: This is a curated sample containing 14 representative files from GNU Emacs 18.59 for Critical Code Studies analysis. The complete emacs-18.59 source code contains over 200 files and 160,000 lines of code.\n\n**Download full source**: https://ftp.gnu.org/old-gnu/emacs/emacs-18.59.tar.gz\n\nThis sample includes:\n\n### Manifestos and Documentation\n\n- **GNU-MANIFESTO**: Richard Stallman's founding document of the free software movement (1985)\n  - Explains why GNU exists and defines software freedom\n  - Political and ethical justification for free software\n  - Essential reading for understanding Emacs as activism\n\n- **COPYING**: The GNU General Public License (GPL v1)\n  - Legal implementation of copyleft\n  - Encodes software freedom in enforceable terms\n\n- **ChangeLog**: Excerpt from development history\n  - Shows collaborative development practices\n  - Documents hacker culture conventions\n  - Demonstrates collective authorship model\n\n### Emacs Lisp Files (Extensibility Layer)\n\n- **simple.el**: Basic editing commands (movement, editing, line operations)\n  - Foundation of user interaction\n  - Shows buffer manipulation primitives\n\n- **doctor.el**: Full ELIZA psychotherapy chatbot implementation (1,613 lines)\n  - Demonstrates Emacs Lisp pattern-matching and natural language processing\n  - Creates narrative connection to ELIZA (1965) sample\n  - Illustrates GNU Project's philosophy of absorbing classic CS concepts\n  - Copyright (C) 1985, 1987 Free Software Foundation, Inc.\n\n- **files.el**: File handling (visiting, saving, backups, auto-save)\n  - Core file I/O abstractions\n  - Shows Unix filesystem integration\n\n- **window.el**: Window management and splitting\n  - Multi-window interface primitives\n  - Buffer/window separation\n\n- **abbrev.el**: Abbreviation expansion mode\n  - Text automation features\n  - User customization patterns\n\n- **dired.el**: Directory editor\n  - Shows Emacs as file manager, not just text editor\n  - Lisp-based filesystem browser\n\n- **compile.el**: Compilation mode\n  - Demonstrates Emacs as IDE\n  - Integration with external tools (make, gcc)\n\n- **mail-utils.el**: Email utilities\n  - Shows Emacs as mail client\n  - \"Kitchen sink\" philosophy of extensibility\n\n### Core C Implementation (Foundation)\n\n- **emacs.c**: Main C implementation\n  - Lisp interpreter bootstrap\n  - Shows how Emacs Lisp sits atop C core\n  - Initialization and main loop\n\n- **lisp.h**: C header defining Lisp data structures\n  - Memory model and object representation\n  - Low-level implementation of high-level abstractions\n  - Interface between C and Lisp layers\n\n## Suggested Annotations\n\nWhen analyzing this code, consider:\n\n### Manifestos and Philosophy\n\n1. **GNU-MANIFESTO - Software freedom definition**: How does Stallman define the four essential freedoms? How do they differ from \"open source\"?\n2. **GNU-MANIFESTO - Labor politics**: How does the manifesto frame programmer labor and autonomy? What's the relationship between code and political economy?\n3. **GNU-MANIFESTO - Unix reimplementation**: Why create a Unix clone rather than something new? What does compatibility mean politically?\n4. **COPYING - Copyleft mechanism**: How does the GPL use copyright law against itself? What makes copyleft different from public domain?\n5. **COPYING - Legal language**: How does legal text encode technical concepts? Who is the intended audience?\n6. **ChangeLog - Collaborative authorship**: How do ChangeLog entries document collective development? What's attributed and what's implicit?\n7. **ChangeLog - Hacker culture conventions**: What norms and practices are visible in ChangeLog format and language?\n\n### Emacs Lisp (Extensibility)\n\n8. **simple.el - Function naming**: How do Emacs Lisp naming conventions reflect human readability vs. machine efficiency?\n9. **simple.el - Self-documentation**: How is documentation embedded in code? What does \"self-documenting\" mean for software literacy?\n10. **simple.el - Buffer abstraction**: How does the buffer model shape user interaction with files and processes?\n11. **files.el - File saving**: How does auto-save and backup logic encode assumptions about failure and user behavior?\n12. **files.el - Unix integration**: How does Emacs abstract filesystem operations? What Unix concepts are exposed vs. hidden?\n13. **window.el - Spatial organization**: How does window splitting encode assumptions about programmer workflow and attention?\n14. **abbrev.el - User customization**: How do abbreviations show Emacs philosophy of making the editor adapt to the user?\n15. **dired.el - Editor as OS**: What does it mean that a text editor can browse filesystems? What's the \"everything in Emacs\" philosophy?\n16. **compile.el - IDE integration**: How does Emacs integrate external tools? What's the relationship between editor and compiler?\n17. **mail-utils.el - Feature creep vs. extensibility**: Is email in a text editor \"bloat\" or principled extensibility? Who decides?\n18. **doctor.el - ELIZA reimplementation**: How does this 1985 version compare to Weizenbaum's 1965 original? What's gained/lost in translation to Emacs Lisp?\n19. **doctor.el - Pattern matching**: How are conversation patterns encoded? What assumptions about human psychology are embedded in the code?\n20. **doctor.el - GPL header**: Compare the GPL notice to ELIZA's original MIT license. How does licensing shape code reuse and reimplementation?\n\n### Core C Implementation\n\n21. **emacs.c - Lisp interpreter bootstrap**: How does the C code initialize the Lisp environment? What comes first—C or Lisp?\n22. **emacs.c - Main loop**: How does the event loop structure user interaction? What's being abstracted away?\n23. **lisp.h - Data structure representation**: How are Lisp objects represented in C? What's the memory model?\n24. **lisp.h - Type system**: How does C implement Lisp's dynamic typing? What are the performance implications?\n25. **C/Lisp boundary**: How do the C and Lisp layers communicate? What operations must be in C vs. Lisp?\n\n### Cross-Cutting Themes\n\n26. **GPL headers across files**: How does licensing appear in every file? What does ubiquitous copyright notice accomplish?\n27. **Documentation density**: Compare comment-to-code ratios across files. What needs explanation and what's considered self-evident?\n28. **Community assumptions**: What kind of user does Emacs imagine? What literacy does it assume or require?\n29. **Unix philosophy tensions**: How does Emacs relate to \"do one thing well\"? Is it one tool or many?\n30. **Extensibility vs. complexity**: How does infinite customizability affect usability and maintenance?\n\n## References\n\n- Stallman, R. M. (1985). *The GNU Manifesto*. Free Software Foundation\n- Williams, S. (2012). *Free as in Freedom: Richard Stallman's Crusade for Free Software*. O'Reilly\n- Berry, D. M. (2008). *Copy, Rip, Burn: The Politics of Copyleft and Open Source*. Pluto Press\n- Fuller, M. (2003). *Behind the Blip: Essays on the Culture of Software*. Autonomedia\n- Levy, S. (1984). *Hackers: Heroes of the Computer Revolution*. Anchor Press\n- Coleman, G. (2013). *Coding Freedom: The Ethics and Aesthetics of Hacking*. Princeton University Press\n- Raymond, E. S. (1999). *The Cathedral and the Bazaar*. O'Reilly\n- Kelty, C. M. (2008). *Two Bits: The Cultural Significance of Free Software*. Duke University Press\n",
    "5b0e227dedf8e3501d8db3062562711d": "What's GNU? Gnu's Not Unix! \n\n \n GNU, which stands for Gnu's Not Unix, is the name for the complete\nUnix-compatible software system which I am writing so that I can give\nit away free to everyone who can use it&#8239; [1] . Several\nother volunteers are helping me. Contributions of time, money,\nprograms and equipment are greatly needed. \n\n \n So far we have an Emacs text editor with Lisp for writing editor\ncommands, a source level debugger, a yacc-compatible parser generator,\na linker, and around 35 utilities. A shell (command interpreter) is\nnearly completed. A new portable optimizing C compiler has compiled\nitself and may be released this year. An initial kernel exists but\nmany more features are needed to emulate Unix. When the kernel and\ncompiler are finished, it will be possible to distribute a GNU system\nsuitable for program development. We will use TeX as our text\nformatter, but an nroff is being worked on. We will use the free,\nportable X Window System as well. After this we will add a portable\nCommon Lisp, an Empire game, a spreadsheet, and hundreds of other\nthings, plus online documentation. We hope to supply, eventually,\neverything useful that normally comes with a Unix system, and more. \n\n \n GNU will be able to run Unix programs, but will not be identical to\nUnix. We will make all improvements that are convenient, based on our\nexperience with other operating systems. In particular, we plan to\nhave longer file names, file version numbers, a crashproof file system,\nfile name completion perhaps, terminal-independent display support, and\nperhaps eventually a Lisp-based window system through which several\nLisp programs and ordinary Unix programs can share a screen. Both C\nand Lisp will be available as system programming languages. We will\ntry to support UUCP, MIT Chaosnet, and Internet protocols for\ncommunication. \n\n \n GNU is aimed initially at machines in the 68000/16000 class with\nvirtual memory, because they are the easiest machines to make it run\non. The extra effort to make it run on smaller machines will be left\nto someone who wants to use it on them. \n\n \n To avoid horrible confusion, please pronounce the g in the\nword &ldquo;GNU&rdquo; when it is the name of this project. \n\n Why I Must Write GNU \n\n \n I consider that the Golden Rule requires that if I like a program I\nmust share it with other people who like it. Software sellers want to\ndivide the users and conquer them, making each user agree not to share\nwith others. I refuse to break solidarity with other users in this\nway. I cannot in good conscience sign a nondisclosure agreement or a\nsoftware license agreement. For years I worked within the Artificial\nIntelligence Lab to resist such tendencies and other inhospitalities,\nbut eventually they had gone too far: I could not remain in an\ninstitution where such things are done for me against my will. \n\n \n So that I can continue to use computers without dishonor, I have\ndecided to put together a sufficient body of free software so that I\nwill be able to get along without any software that is not free. I\nhave resigned from the AI Lab to deny MIT any legal excuse to prevent\nme from giving GNU away&#8239; [2] . \n\n Why GNU Will Be Compatible with Unix \n\n \n Unix is not my ideal system, but it is not too bad. The essential\nfeatures of Unix seem to be good ones, and I think I can fill in what\nUnix lacks without spoiling them. And a system compatible with Unix\nwould be convenient for many other people to adopt. \n\n How GNU Will Be Available \n\n \n GNU is not in the public domain. Everyone will be permitted to\nmodify and redistribute GNU, but no distributor will be allowed to\nrestrict its further redistribution. That is to say,\n proprietary \nmodifications will not be allowed. I want to make sure that all\nversions of GNU remain free. \n\n Why Many Other Programmers Want to Help \n\n \n I have found many other programmers who are excited about GNU and\nwant to help. \n\n \n Many programmers are unhappy about the commercialization of system\nsoftware. It may enable them to make more money, but it requires them\nto feel in conflict with other programmers in general rather than feel\nas comrades. The fundamental act of friendship among programmers is the\nsharing of programs; marketing arrangements now typically used\nessentially forbid programmers to treat others as friends. The\npurchaser of software must choose between friendship and obeying the\nlaw. Naturally, many decide that friendship is more important. But\nthose who believe in law often do not feel at ease with either choice.\nThey become cynical and think that programming is just a way of making\nmoney. \n\n \n By working on and using GNU rather than proprietary programs, we can\nbe hospitable to everyone and obey the law. In addition, GNU serves as\nan example to inspire and a banner to rally others to join us in\nsharing. This can give us a feeling of harmony which is impossible if\nwe use software that is not free. For about half the programmers I\ntalk to, this is an important happiness that money cannot replace. \n\n How You Can Contribute \n\n \n \n(Nowadays, for software tasks to work on, see the High Priority Projects\nlist and the GNU Help\nWanted list , the general task list for GNU software packages. For other\nways to help, see the guide to helping\nthe GNU operating system .)\n \n \n\n \n I am asking computer manufacturers for donations of machines and\nmoney. I'm asking individuals for donations of programs and work. \n\n \n One consequence you can expect if you donate machines is that GNU\nwill run on them at an early date. The machines should be complete,\nready to use systems, approved for use in a residential area, and not\nin need of sophisticated cooling or power. \n\n \n I have found very many programmers eager to contribute part-time\nwork for GNU. For most projects, such part-time distributed work would\nbe very hard to coordinate; the independently written parts would not\nwork together. But for the particular task of replacing Unix, this\nproblem is absent. A complete Unix system contains hundreds of utility\nprograms, each of which is documented separately. Most interface\nspecifications are fixed by Unix compatibility. If each contributor\ncan write a compatible replacement for a single Unix utility, and make\nit work properly in place of the original on a Unix system, then these\nutilities will work right when put together. Even allowing for Murphy\nto create a few unexpected problems, assembling these components will\nbe a feasible task. (The kernel will require closer communication and\nwill be worked on by a small, tight group.) \n\n \n If I get donations of money, I may be able to hire a few people full\nor part time. The salary won't be high by programmers' standards, but\nI'm looking for people for whom building community spirit is as\nimportant as making money. I view this as a way of enabling dedicated\npeople to devote their full energies to working on GNU by sparing them\nthe need to make a living in another way. \n\n Why All Computer Users Will Benefit \n\n \n Once GNU is written, everyone will be able to obtain good system\nsoftware free, just like air&#8239; [3] . \n\n \n This means much more than just saving everyone the price of a Unix\nlicense. It means that much wasteful duplication of system programming\neffort will be avoided. This effort can go instead into advancing the\nstate of the art. \n\n \n Complete system sources will be available to everyone. As a result,\na user who needs changes in the system will always be free to make them\nhimself, or hire any available programmer or company to make them for\nhim. Users will no longer be at the mercy of one programmer or company\nwhich owns the sources and is in sole position to make changes. \n\n \n Schools will be able to provide a much more educational environment\nby encouraging all students to study and improve the system code.\nHarvard's computer lab used to have the policy that no program could be\ninstalled on the system if its sources were not on public display, and\nupheld it by actually refusing to install certain programs. I was very\nmuch inspired by this. \n\n \n Finally, the overhead of considering who owns the system software\nand what one is or is not entitled to do with it will be lifted. \n\n \n Arrangements to make people pay for using a program, including\nlicensing of copies, always incur a tremendous cost to society through\nthe cumbersome mechanisms necessary to figure out how much (that is,\nwhich programs) a person must pay for. And only a police state can\nforce everyone to obey them. Consider a space station where air must\nbe manufactured at great cost: charging each breather per liter of air\nmay be fair, but wearing the metered gas mask all day and all night is\nintolerable even if everyone can afford to pay the air bill. And the\nTV cameras everywhere to see if you ever take the mask off are\noutrageous. It's better to support the air plant with a head tax and\nchuck the masks. \n\n \n Copying all or parts of a program is as natural to a programmer as\nbreathing, and as productive. It ought to be as free. \n\n Some Easily Rebutted Objections to GNU's Goals \n\n \n \n &ldquo;Nobody will use it if it is free, because that means\nthey can't rely on any support.&rdquo; \n\n \n &ldquo;You have to charge for the program to pay for providing\nthe support.&rdquo; \n \n \n If people would rather pay for GNU plus service than get GNU free\nwithout service, a company to provide just service to people who have\nobtained GNU free ought to be profitable&#8239; [4] . \n\n \n We must distinguish between support in the form of real programming\nwork and mere handholding. The former is something one cannot rely on\nfrom a software vendor. If your problem is not shared by enough\npeople, the vendor will tell you to get lost. \n\n \n If your business needs to be able to rely on support, the only way\nis to have all the necessary sources and tools. Then you can hire any\navailable person to fix your problem; you are not at the mercy of any\nindividual. With Unix, the price of sources puts this out of\nconsideration for most businesses. With GNU this will be easy. It is\nstill possible for there to be no available competent person, but this\nproblem cannot be blamed on distribution arrangements. GNU does not\neliminate all the world's problems, only some of them. \n\n \n Meanwhile, the users who know nothing about computers need\nhandholding: doing things for them which they could easily do\nthemselves but don't know how. \n\n \n Such services could be provided by companies that sell just\nhandholding and repair service. If it is true that users would rather\nspend money and get a product with service, they will also be willing\nto buy the service having got the product free. The service companies\nwill compete in quality and price; users will not be tied to any\nparticular one. Meanwhile, those of us who don't need the service\nshould be able to use the program without paying for the service. \n \n\n \n &ldquo;You cannot reach many people without advertising, and\nyou must charge for the program to support that.&rdquo; \n \n &ldquo;It's no use advertising a program people can get\nfree.&rdquo; \n \n \n There are various forms of free or very cheap publicity that can be\nused to inform numbers of computer users about something like GNU. But\nit may be true that one can reach more microcomputer users with\nadvertising. If this is really so, a business which advertises the\nservice of copying and mailing GNU for a fee ought to be successful\nenough to pay for its advertising and more. This way, only the users\nwho benefit from the advertising pay for it. \n\n \n On the other hand, if many people get GNU from their friends, and\nsuch companies don't succeed, this will show that advertising was not\nreally necessary to spread GNU. Why is it that free market advocates\ndon't want to let the free market decide this?&#8239; [5] \n \n\n \n &ldquo;My company needs a proprietary operating system to get\na competitive edge.&rdquo; \n \n \n GNU will remove operating system software from the realm of\ncompetition. You will not be able to get an edge in this area, but\nneither will your competitors be able to get an edge over you. You and\nthey will compete in other areas, while benefiting mutually in this\none. If your business is selling an operating system, you will not\nlike GNU, but that's tough on you. If your business is something else,\nGNU can save you from being pushed into the expensive business of\nselling operating systems. \n\n \n I would like to see GNU development supported by gifts from many\nmanufacturers and users, reducing the cost to each&#8239; [6] . \n \n\n \n &ldquo;Don't programmers deserve a reward for their\ncreativity?&rdquo; \n \n \n If anything deserves a reward, it is social contribution.\nCreativity can be a social contribution, but only in so far as society\nis free to use the results. If programmers deserve to be rewarded for\ncreating innovative programs, by the same token they deserve to be\npunished if they restrict the use of these programs. \n \n\n \n &ldquo;Shouldn't a programmer be able to ask for a reward for\nhis creativity?&rdquo; \n \n \n There is nothing wrong with wanting pay for work, or seeking to\nmaximize one's income, as long as one does not use means that are\ndestructive. But the means customary in the field of software today\nare based on destruction. \n\n \n Extracting money from users of a program by restricting their use of\nit is destructive because the restrictions reduce the amount and the\nways that the program can be used. This reduces the amount of wealth\nthat humanity derives from the program. When there is a deliberate\nchoice to restrict, the harmful consequences are deliberate destruction. \n\n \n The reason a good citizen does not use such destructive means to\nbecome wealthier is that, if everyone did so, we would all become\npoorer from the mutual destructiveness. This is Kantian ethics; or,\nthe Golden Rule. Since I do not like the consequences that result if\neveryone hoards information, I am required to consider it wrong for one\nto do so. Specifically, the desire to be rewarded for one's creativity\ndoes not justify depriving the world in general of all or part of that\ncreativity. \n \n\n \n &ldquo;Won't programmers starve?&rdquo; \n \n \n I could answer that nobody is forced to be a programmer. Most of us\ncannot manage to get any money for standing on the street and making\nfaces. But we are not, as a result, condemned to spend our lives\nstanding on the street making faces, and starving. We do something\nelse. \n\n \n But that is the wrong answer because it accepts the questioner's\nimplicit assumption: that without ownership of software, programmers\ncannot possibly be paid a cent. Supposedly it is all or nothing. \n\n \n The real reason programmers will not starve is that it will still be\npossible for them to get paid for programming; just not paid as much as\nnow. \n\n \n Restricting copying is not the only basis for business in software.\nIt is the most common basis&#8239; [7] because it brings in\nthe most money. If it\nwere prohibited, or rejected by the customer, software business would\nmove to other bases of organization which are now used less often.\nThere are always numerous ways to organize any kind of business. \n\n \n Probably programming will not be as lucrative on the new basis as it\nis now. But that is not an argument against the change. It is not\nconsidered an injustice that sales clerks make the salaries that they\nnow do. If programmers made the same, that would not be an injustice\neither. (In practice they would still make considerably more than\nthat.) \n \n\n \n &ldquo;Don't people have a right to control how their\ncreativity is used?&rdquo; \n \n \n&ldquo;Control over the use of one's ideas&rdquo; really constitutes\ncontrol over other people's lives; and it is usually used to make\ntheir lives more difficult. \n\n \n People who have studied the issue of intellectual property\nrights&#8239; [8] carefully (such as lawyers) say that there\nis no intrinsic right to intellectual property. The kinds of supposed\nintellectual property rights that the government recognizes were\ncreated by specific acts of legislation for specific purposes. \n\n \n For example, the patent system was established to encourage\ninventors to disclose the details of their inventions. Its purpose was\nto help society rather than to help inventors. At the time, the life\nspan of 17 years for a patent was short compared with the rate of\nadvance of the state of the art. Since patents are an issue only among\nmanufacturers, for whom the cost and effort of a license agreement are\nsmall compared with setting up production, the patents often do not do\nmuch harm. They do not obstruct most individuals who use patented\nproducts. \n\n \n The idea of copyright did not exist in ancient times, when authors\nfrequently copied other authors at length in works of nonfiction. This\npractice was useful, and is the only way many authors' works have\nsurvived even in part. The copyright system was created expressly for\nthe purpose of encouraging authorship. In the domain for which it was\ninvented&mdash;books, which could be copied economically only on a printing\npress&mdash;it did little harm, and did not obstruct most of the individuals\nwho read the books. \n\n \n All intellectual property rights are just licenses granted by society\nbecause it was thought, rightly or wrongly, that society as a whole\nwould benefit by granting them. But in any particular situation, we\nhave to ask: are we really better off granting such license? What kind\nof act are we licensing a person to do? \n\n \n The case of programs today is very different from that of books a\nhundred years ago. The fact that the easiest way to copy a program is\nfrom one neighbor to another, the fact that a program has both source\ncode and object code which are distinct, and the fact that a program is\nused rather than read and enjoyed, combine to create a situation in\nwhich a person who enforces a copyright is harming society as a whole\nboth materially and spiritually; in which a person should not do so\nregardless of whether the law enables him to. \n \n\n \n &ldquo;Competition makes things get done\nbetter.&rdquo; \n \n \n The paradigm of competition is a race: by rewarding the winner, we\nencourage everyone to run faster. When capitalism really works this\nway, it does a good job; but its defenders are wrong in assuming it\nalways works this way. If the runners forget why the reward is offered\nand become intent on winning, no matter how, they may find other\nstrategies&mdash;such as, attacking other runners. If the runners get into\na fist fight, they will all finish late. \n\n \n Proprietary and secret software is the moral equivalent of runners\nin a fist fight. Sad to say, the only referee we've got does not seem\nto object to fights; he just regulates them (&ldquo;For every ten\nyards you run, you can fire one shot&rdquo;). He really ought to\nbreak them up, and penalize runners for even trying to fight. \n \n\n \n &ldquo;Won't everyone stop programming without a monetary\nincentive?&rdquo; \n \n \n Actually, many people will program with absolutely no monetary\nincentive. Programming has an irresistible fascination for some\npeople, usually the people who are best at it. There is no shortage of\nprofessional musicians who keep at it even though they have no hope of\nmaking a living that way. \n\n \n But really this question, though commonly asked, is not appropriate\nto the situation. Pay for programmers will not disappear, only become\nless. So the right question is, will anyone program with a reduced\nmonetary incentive? My experience shows that they will. \n\n \n For more than ten years, many of the world's best programmers worked\nat the Artificial Intelligence Lab for far less money than they could\nhave had anywhere else. They got many kinds of nonmonetary rewards:\nfame and appreciation, for example. And creativity is also fun, a\nreward in itself. \n\n \n Then most of them left when offered a chance to do the same\ninteresting work for a lot of money. \n\n \n What the facts show is that people will program for reasons other\nthan riches; but if given a chance to make a lot of money as well, they\nwill come to expect and demand it. Low-paying organizations do poorly\nin competition with high-paying ones, but they do not have to do badly\nif the high-paying ones are banned. \n \n\n \n &ldquo;We need the programmers desperately. If they demand\nthat we stop helping our neighbors, we have to obey.&rdquo; \n \n \n You're never so desperate that you have to obey this sort of demand.\nRemember: millions for defense, but not a cent for tribute! \n \n\n \n &ldquo;Programmers need to make a living somehow.&rdquo; \n \n \n In the short run, this is true. However, there are plenty of ways\nthat programmers could make a living without selling the right to use a\nprogram. This way is customary now because it brings programmers and\nbusinessmen the most money, not because it is the only way to make a\nliving. It is easy to find other ways if you want to find them. Here\nare a number of examples. \n\n \n A manufacturer introducing a new computer will pay for the porting of\noperating systems onto the new hardware. \n\n \n The sale of teaching, handholding and maintenance services could\nalso employ programmers. \n\n \n People with new ideas could distribute programs as\nfreeware&#8239; [9] , asking for donations from satisfied\nusers, or selling handholding services. I have met people who are\nalready working this way successfully. \n\n \n Users with related needs can form users' groups, and pay dues. A\ngroup would contract with programming companies to write programs that\nthe group's members would like to use. \n\n \n All sorts of development can be funded with a Software Tax: \n\n \n Suppose everyone who buys a computer has to pay x percent of the\n price as a software tax. The government gives this to an agency\n like the NSF to spend on software development. \n\n \n But if the computer buyer makes a donation to software development\n himself, he can take a credit against the tax. He can donate to\n the project of his own choosing&mdash;often, chosen because he hopes to\n use the results when it is done. He can take a credit for any\n amount of donation up to the total tax he had to pay. \n\n \n The total tax rate could be decided by a vote of the payers of the\n tax, weighted according to the amount they will be taxed on. \n\n \n The consequences: \n\n \n The computer-using community supports software development. \n This community decides what level of support is needed. \n Users who care which projects their share is spent on can\n choose this for themselves. \n \n \n \n \n\n \n In the long run, making programs free is a step toward the\npostscarcity world, where nobody will have to work very hard just to\nmake a living. People will be free to devote themselves to activities\nthat are fun, such as programming, after spending the necessary ten\nhours a week on required tasks such as legislation, family counseling,\nrobot repair and asteroid prospecting. There will be no need to be\nable to make a living from programming. \n\n \n We have already greatly reduced the amount of work that the whole\nsociety must do for its actual productivity, but only a little of this\nhas translated itself into leisure for workers because much\nnonproductive activity is required to accompany productive activity.\nThe main causes of this are bureaucracy and isometric struggles against\ncompetition. Free software will greatly reduce these drains in the\narea of software production. We must do this, in order for technical\ngains in productivity to translate into less work for us. \n \n\n Footnotes \n\n \n \n The wording here was careless. The intention\nwas that nobody would have to pay for permission to use the GNU\nsystem. But the words don't make this clear, and people often\ninterpret them as saying that copies of GNU should always be\ndistributed at little or no charge. That was never the intent; later\non, the manifesto mentions the possibility of companies providing the\nservice of distribution for a profit. Subsequently I have learned to\ndistinguish carefully between &ldquo;free&rdquo; in the sense of\nfreedom and &ldquo;free&rdquo; in the sense of price. Free software\nis software that users have the freedom to distribute and change.\nSome users may obtain copies at no charge, while others pay to obtain\ncopies&mdash;and if the funds help support improving the software, so much\nthe better. The important thing is that everyone who has a copy has\nthe freedom to cooperate with others in using it. \n\n The expression &ldquo;give away&rdquo; is another\nindication that I had not yet clearly separated the issue of price\nfrom that of freedom. We now recommend avoiding this expression when\ntalking about free software. See\n&ldquo; Confusing\nWords and Phrases &rdquo; for more explanation. \n\n This is another place I failed to distinguish\ncarefully between the two different meanings of &ldquo;free.&rdquo;\nThe statement as it stands is not false&mdash;you can get copies of GNU\nsoftware at no charge, from your friends or over the net. But it does\nsuggest the wrong idea. \n\n Several such companies now exist. \n\n Although it is a\ncharity rather than a company, the Free Software Foundation for 10 years raised\nmost of its funds from its distribution service. You\ncan order things from the FSF \nto support its work.\n \n\n A group of computer companies pooled funds\naround 1991 to support maintenance of the GNU C Compiler. \n\n I think I was mistaken in saying that proprietary\nsoftware was the most common basis for making money in software.\nIt seems that actually the most common business model was and is\ndevelopment of custom software. That does not offer the possibility\nof collecting rents, so the business has to keep doing real work\nin order to keep getting income. The custom software business would\ncontinue to exist, more or less unchanged, in a free software world.\nTherefore, I no longer expect that most paid programmers would earn less\nin a free software world. \n\n In the 1980s I had not yet realized how confusing\nit was to speak of &ldquo;the issue&rdquo; of &ldquo;intellectual\nproperty.&rdquo; That term is obviously biased; more subtle is the\nfact that it lumps together various disparate laws which raise very\ndifferent issues. Nowadays I urge people to reject the term\n&ldquo;intellectual property&rdquo; entirely, lest it lead others to\nsuppose that those laws form one coherent issue. The way to be clear\nis to discuss patents, copyrights, and trademarks separately.\nSee further explanation of how\nthis term spreads confusion and bias. \n\n Subsequently we learned to distinguish\nbetween &ldquo;free software&rdquo; and &ldquo;freeware.&rdquo; The\nterm &ldquo;freeware&rdquo; means software you are free to\nredistribute, but usually you are not free to study and change the\nsource code, so most of it is not free software. See\n&ldquo; Confusing\nWords and Phrases &rdquo; for more explanation.",
    "93bfcccf44f9ba3f267c1a42fac717e3": "GNU EMACS GENERAL PUBLIC LICENSE\n\n\t\t\t\tNO WARRANTY\n\n  BECAUSE EMACS IS LICENSED FREE OF CHARGE, WE PROVIDE ABSOLUTELY NO\nWARRANTY, TO THE EXTENT PERMITTED BY APPLICABLE STATE LAW.  EXCEPT\nWHEN OTHERWISE STATED IN WRITING, FREE SOFTWARE FOUNDATION, INC,\nRICHARD M. STALLMAN, AND/OR OTHER PARTIES PROVIDE EMACS \"AS IS\"\nWITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,\nBUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\nFITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY\nAND PERFORMANCE OF EMACS IS WITH YOU.  SHOULD EMACS PROVE DEFECTIVE,\nYOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.\n\n  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW WILL RICHARD M.\nSTALLMAN, THE FREE SOFTWARE FOUNDATION, INC., AND/OR ANY OTHER PARTY\nWHO MAY MODIFY AND REDISTRIBUTE EMACS AS PERMITTED BELOW, BE LIABLE\nTO YOU FOR DAMAGES, INCLUDING ANY LOST PROFITS, LOST MONIES, OR OTHER\nSPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR\nINABILITY TO USE (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA\nBEING RENDERED INACCURATE OR LOSSES SUSTAINED BY THIRD PARTIES OR A\nFAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS) EMACS, EVEN\nIF YOU HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES, OR FOR\nANY CLAIM BY ANY OTHER PARTY.\n\n\t\t     GENERAL PUBLIC LICENSE TO COPY\n\n  1. You may copy and distribute verbatim copies of EMACS source code as\nyou receive it, in any medium, provided that you conspicuously and\nappropriately publish on each copy a valid copyright notice \"Copyright\n(C) 1985 Richard M. Stallman\" (or with whatever year is appropriate);\nkeep intact the notices on all files that refer to this License\nAgreement and to the absence of any warranty; and give any other\nrecipients of the EMACS program a copy of this License Agreement along\nwith the program.  You may charge a distribution fee for the physical\nact of transferring a copy.\n\n  2. You may modify your copy or copies of EMACS or any portion of it,\nand copy and distribute such modifications under the terms of\nParagraph 1 above, provided that you also do the following:\n\n    a) cause the modified files to carry prominent notices stating\n    that you changed the files and the date of any change; and\n\n    b) cause the whole of any work that you distribute or publish,\n    that in whole or in part contains or is a derivative of EMACS or\n    any part thereof, to be licensed at no charge to all third parties\n    on terms identical to those contained in this License Agreement\n    (except that you may choose to grant more extensive warranty\n    protection to some or all third parties, at your option).\n\n    c) You may charge a distribution fee for the physical act of\n    transferring a copy, and you may at your option offer warranty\n    protection in exchange for a fee.\n\nMere aggregation of another unrelated program with this program (or its\nderivative) on a volume of a storage or distribution medium does not bring\nthe other program under the scope of these terms.\n\n  3. You may copy and distribute EMACS (or a portion or derivative of\nit, under Paragraph 2) in object code or executable form under the\nterms of Paragraphs 1 and 2 above provided that you also do one of the\nfollowing:\n\n    a) accompany it with the complete corresponding machine-readable\n    source code, which must be distributed under the terms of\n    Paragraphs 1 and 2 above; or,\n\n    b) accompany it with a written offer, valid for at least three\n    years, to give any third party free (except for a nominal charge\n    for the cost of distribution) a complete machine-readable copy of the\n    corresponding source code, to be distributed under the terms of\n    Paragraphs 1 and 2 above; or,\n\n    c) accompany it with the information you received as to where the\n    corresponding source code may be obtained.  (This alternative is\n    allowed only for noncommercial distribution and only if you\n    received the program in object code or executable form alone.)\n\nFor an executable file, complete source code means all the source code for\nall modules it contains; but, as a special exception, it need not include\nsource code for modules which are standard libraries that accompany the\noperating system on which the executable file runs.\n\n  4. You may not copy, sublicense, distribute or transfer EMACS except\nas expressly provided under this License Agreement.  Any attempt\notherwise to copy, sublicense, distribute or transfer EMACS is void and\nyour rights to use EMACS under this License agreement shall be\nautomatically terminated.  However, parties who have received computer\nsoftware programs from you with this License Agreement will not have\ntheir licenses terminated so long as such parties remain in full\ncompliance.\n\n  5. If you wish to incorporate parts of EMACS into other free programs\nwhose distribution conditions are different, write to the Free Software\nFoundation at 675 Mass Ave, Cambridge, MA 02139.  We have not yet worked\nout a simple rule that can be stated here, but we will often permit this.\nWe will be guided by the two goals of preserving the free status of all\nderivatives of our free software and of promoting the sharing and reuse\nof software.\n\nYour comments and suggestions about our licensing policies and our\nsoftware are welcome!  Please contact the Free Software Foundation, Inc.,\n675 Mass Ave, Cambridge, MA 02139, or call (617) 876-3296.\n",
    "899be733dfe5ad520e75357d709330b5": "Fri Oct 30 19:36:38 1992  Richard Stallman  (rms@mole.gnu.ai.mit.edu)\n\n\t* Version 18.59 released.\n\nWed Oct 28 19:30:14 1992  Richard Stallman  (rms@mole.gnu.ai.mit.edu)\n\n\t* vmsdist.com: Don't copy vaxcrtl.olb into distribution.\n\tAssume VMS version 5.5 or newer.\n\nSat Oct  3 01:32:44 1992  Richard Stallman  (rms@mole.gnu.ai.mit.edu)\n\n\t* build-install: Use sh -c pwd, not just pwd.\n\nFri Oct  2 19:14:07 1992  Richard Stallman  (rms@mole.gnu.ai.mit.edu)\n\n\t* Makefile (install.xenix): Delete spurious space.\n\nTue Aug 25 18:04:27 1992  Richard Stallman  (rms@mole.gnu.ai.mit.edu)\n\n\t* Makefile (src/paths.h): Use just `sed', not `/bin/sed'.\n\nSun Jun  7 14:21:01 1992  Richard Stallman  (rms@mole.gnu.ai.mit.edu)\n\n\t* Makefile (install): Get rid of -s from install commands.\n\nThu Feb 13 14:53:26 1992  Richard Stallman  (rms@mole.gnu.ai.mit.edu)\n\n\t* Makefile (install): Use INSTALL to install programs.\n\t(INSTALL): New variable.\n\nSun Feb  9 21:41:17 1992  Richard Stallman  (rms@mole.gnu.ai.mit.edu)\n\n\t* Makefile (mkdir): Create BINDIR and MANDIR if nec.\n\tDon't chmod LIBDIR.\n\n\t* build-install: Use normal convention for EMACS dir.\n\tFix syntax in directory name comparison.\n\tInstall emacsclient.  Deleted the chmod for executables.\n\tStart with #! to force use of sh.\n\nSat Feb  1 17:40:30 1992  Richard Stallman  (rms@mole.gnu.ai.mit.edu)\n\n\t* install.sh: New file.\n\nFri Jan 31 23:46:51 1992  Richard Stallman  (rms@mole.gnu.ai.mit.edu)\n\n\t* Makefile (clean, distclean): Clean oldXMenu subdir.\n\nMon Jan 27 16:29:53 1992  Richard Stallman  (rms@mole.gnu.ai.mit.edu)\n\n\t* Makefile (install): Remove `B' from tar xf command.\n\n\t* Makefile (CLEANDIR): Add oldXMenu.\n\nSat Jan 25 00:06:59 1992  Richard Stallman  (rms@mole.gnu.ai.mit.edu)\n\n\t* build-install: Finish updating to sh syntax.\n\nFri Jan 17 22:56:27 1992  Richard Stallman  (rms@mole.gnu.ai.mit.edu)\n\n\t* Makefile (LIBDIR): Change back to /usr/local/emacs.\n\t(It got changed recently but I don't know why.)\n\nSat Mar  9 23:21:20 1991  Richard Stallman  (rms at mole.ai.mit.edu)\n\n\t* Makefile (clean): Use /bin/pwd, not pwd.  \n\nFri Sep 28 22:36:32 1990  Richard Stallman  (rms at mole.ai.mit.edu)\n\n\t* Makefile (install, install.sysv, install.xenix):\n\tInstall wakeup instead of loadst.  No need for setuid or setgid.\n\nTue Aug  7 13:19:35 1990  Richard Stallman  (rms at sugar-bombs.ai.mit.edu)\n\n\t* Makefile (clean): Clean etc if that's not the installation dir.\n\nThu Apr 26 13:36:18 1990  Richard Stallman  (rms at sugar-bombs.ai.mit.edu)\n\n\t* Makefile (paths.h): Make sed alter each name in the path.\n\nTue Aug 30 13:43:43 1988  Richard Stallman  (rms at sugar-bombs.ai.mit.edu)\n\n\t* Makefile (install.sysv): Use cpio, not tar.\n\nWed Aug  3 19:20:13 1988  Richard Stallman  (rms at sugar-bombs.ai.mit.edu)\n\n\t* Makefile (lockdir): Rename `lock' target.\n\tDepend on it from install*, not from `all'.\n\nMon May 16 02:08:08 1988  Richard Stallman  (rms at frosted-flakes.ai.mit.edu)\n\n\t* Makefile: Changed LIBDIR and BINDIR back to /usr/local/{emacs,bin}\n\tto match build-install and paths.h.\n\n",
    "afad1f11d455300d3b665d4d3bfe7e0b": ";; simple.el -- basic editing commands for Emacs\n\n;; Copyright (C) 1985 Richard M. Stallman.\n\n;; This file is part of GNU Emacs.\n\n;; GNU Emacs is distributed in the hope that it will be useful,\n;; but WITHOUT ANY WARRANTY.  No author or distributor\n;; accepts responsibility to anyone for the consequences of using it\n;; or for whether it serves any particular purpose or works at all,\n;; unless he says so in writing.  Refer to the GNU Emacs General Public\n;; License for full details.\n\n;; Everyone is granted permission to copy, modify and redistribute\n;; GNU Emacs, but only under the conditions described in the\n;; GNU Emacs General Public License.   A copy of this license is\n;; supposed to have been given to you along with GNU Emacs so you\n;; can know your rights and responsibilities.  It should be in a\n;; file named COPYING.  Among other things, the copyright notice\n;; and this notice must be preserved on all copies.\n\n\n(defun beginning-of-line (&optional n)\n  \"Move point to beginning of current line.\nWith argument N not nil or 1, move forward N - 1 lines first.\nIf scan reaches end of buffer, stop there without error.\"\n  (interactive \"p\")\n  (if (or (null n) (= n 1))\n      (forward-line 0)\n    (forward-line (1- n))))\n\n(defun end-of-line (&optional n)\n  \"Move point to end of current line.\nWith argument N not nil or 1, move forward N - 1 lines first.\nIf scan reaches end of buffer, stop there without error.\"\n  (interactive \"p\")\n  (if (or (null n) (= n 1))\n      (end-of-line 1)\n    (forward-line (1- n))\n    (end-of-line 1)))\n\n(defun delete-horizontal-space ()\n  \"Delete all spaces and tabs around point.\"\n  (interactive \"*\")\n  (skip-chars-backward \" \\t\")\n  (delete-region (point) (progn (skip-chars-forward \" \\t\") (point))))\n\n(defun just-one-space ()\n  \"Delete all spaces and tabs around point, leaving one space.\"\n  (interactive \"*\")\n  (skip-chars-backward \" \\t\")\n  (if (not (bolp))\n      (progn\n        (delete-region (point) (progn (skip-chars-forward \" \\t\") (point)))\n        (insert ? ))))\n\n(defun delete-blank-lines ()\n  \"On blank line, delete all surrounding blank lines, leaving just one.\nOn isolated blank line, delete that one.\nOn nonblank line, delete all blank lines that follow it.\"\n  (interactive \"*\")\n  (let (thisblank singleblank)\n    (save-excursion\n      (beginning-of-line)\n      (setq thisblank (looking-at \"[ \\t]*$\"))\n      ;; Set singleblank if there is just one blank line here.\n      (setq singleblank\n            (and thisblank\n                 (not (looking-at \"[ \\t]*\\n[ \\t]*$\"))\n                 (or (bobp)\n                     (progn (forward-line -1)\n                            (not (looking-at \"[ \\t]*$\")))))))\n    ;; Delete preceding blank lines, and this one too if it's the only one.\n    (if thisblank\n        (progn\n          (beginning-of-line)\n          (if singleblank (forward-line 1))\n          (delete-region (point)\n                         (if (re-search-backward \"[^ \\t\\n]\" nil t)\n                             (progn (forward-line 1) (point))\n                           (point-min)))))\n    ;; Delete following blank lines, unless the current line is blank\n    ;; and there are no following blank lines.\n    (if (not (and thisblank singleblank))\n        (save-excursion\n          (end-of-line)\n          (forward-line 1)\n          (delete-region (point)\n                         (if (re-search-forward \"[^ \\t\\n]\" nil t)\n                             (progn (beginning-of-line) (point))\n                           (point-max)))))\n    ;; Handle the special case where point is followed by newline and eob.\n    ;; Delete the line, leaving point at eob.\n    (if (looking-at \"^[ \\t]*\\n\\\\'\")\n        (delete-region (point) (point-max)))))\n\n(defun back-to-indentation ()\n  \"Move point to first visible character on line.\"\n  (interactive)\n  (beginning-of-line)\n  (skip-chars-forward \" \\t\"))\n\n(defun newline (&optional arg)\n  \"Insert a newline.  With arg, insert that many newlines.\nIn Auto Fill mode, can break the preceding line if no numeric arg.\nThis is the usual command to end a line.\"\n  (interactive \"*P\")\n  (if (auto-fill-hook)\n      (progn\n        (funcall auto-fill-function)\n        (if (and (interactive-p) (eolp))\n            (if arg\n                (self-insert-command (prefix-numeric-value arg))\n              (self-insert-command 1))))\n    ;; Do the work of a self-insert-command.\n    (if arg (setq arg (prefix-numeric-value arg))\n      (setq arg 1))\n    (if (and (> arg 0)\n             (eq (char-syntax (preceding-char)) ?w))\n        (insert-char ?  1))\n    (newline arg)))\n\n(defun open-line (arg)\n  \"Insert a newline and leave point before it.\nWith arg, inserts that many newlines.\"\n  (interactive \"*p\")\n  (let ((flag (and (bolp) (not (bobp)))))\n    (if flag (forward-char -1))\n    (save-excursion\n     (while (> arg 0)\n       (insert ?\\n)\n       (setq arg (1- arg))))\n    (if flag (forward-char 1))))\n\n(defun split-line ()\n  \"Split current line, moving portion beyond point vertically down.\"\n  (interactive \"*\")\n  (skip-chars-forward \" \\t\")\n  (let ((col (current-column))\n        (pos (point)))\n    (insert ?\\n)\n    (indent-to col 0)\n    (goto-char pos)))\n\n(defun quoted-insert (arg)\n  \"Read next input character and insert it.\nUseful for inserting control characters.\nYou may also type up to 3 octal digits, to insert a character with that code.\"\n  (interactive \"*p\")\n  (let ((char (read-quoted-char)))\n    (while (> arg 0)\n      (insert char)\n      (setq arg (1- arg)))))\n\n(defun transpose-chars (arg)\n  \"Interchange characters around point, moving forward one character.\nWith prefix arg ARG, effect is to take character before point\nand drag it forward past ARG other characters (backward if ARG negative).\nIf no argument and at end of line, the previous two chars are exchanged.\"\n  (interactive \"*P\")\n  (and (null arg) (eolp) (forward-char -1))\n  (transpose-subr 'forward-char (prefix-numeric-value arg)))\n",
    "2aabc772ab4d533f1ce11fd701999ff3": ";; File input and output commands for Emacs\n;; Copyright (C) 1985, 1986, 1987, 1990 Free Software Foundation, Inc.\n\n;; This file is part of GNU Emacs.\n\n;; GNU Emacs is free software; you can redistribute it and/or modify\n;; it under the terms of the GNU General Public License as published by\n;; the Free Software Foundation; either version 1, or (at your option)\n;; any later version.\n\n;; GNU Emacs is distributed in the hope that it will be useful,\n;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n;; GNU General Public License for more details.\n\n;; You should have received a copy of the GNU General Public License\n;; along with GNU Emacs; see the file COPYING.  If not, write to\n;; the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n\n\n(defconst delete-auto-save-files t\n  \"*Non-nil means delete a buffer's auto-save file\nwhen the buffer is saved for real.\")\n\n;(make-variable-buffer-local 'buffer-backed-up)\n;(defvar buffer-backed-up nil\n;  \"Non-nil if this buffer's file has been backed up.\n;Backing up is done before the first time the file is saved.\")\n\n;;; Turn off backup files on VMS since it has version numbers.\n(defconst make-backup-files (not (eq system-type 'vax-vms))\n  \"*Create a backup of each file when it is saved for the first time.\nThis can be done by renaming the file or by copying.\n\nRenaming means that Emacs renames the existing file so that it is a\nbackup file, then writes the buffer into a new file.  Any other names\nthat the old file had will now refer to the backup file.\nThe new file is owned by you and its group is defaulted.\n\nCopying means that Emacs copies the existing file into the backup file,\nthen writes the buffer on top of the existing file.  Any other names\nthat the old file had will now refer to the new (edited) file.\nThe file's owner and group are unchanged.\n\nThe choice of renaming or copying is controlled by the variables\nbackup-by-copying, backup-by-copying-when-linked and\nbackup-by-copying-when-mismatch.\")\n\n(defconst backup-by-copying nil\n \"*Non-nil means always use copying to create backup files.\nSee documentation of variable  make-backup-files.\")\n\n(defconst backup-by-copying-when-linked nil\n \"*Non-nil means use copying to create backups for files with multiple names.\nThis causes the alternate names to refer to the latest version as edited.\nThis variable is relevant only if  backup-by-copying  is nil.\")\n\n(defconst backup-by-copying-when-mismatch nil\n  \"*Non-nil means create backups by copying if this preserves owner or group.\nRenaming may still be used (subject to control of other variables)\nwhen it would not result in changing the owner or group of the file;\nthat is, for files which are owned by you and whose group matches\nthe default for a new file created there by you.\nThis variable is relevant only if  backup-by-copying  is nil.\")\n\n(defconst buffer-offer-save nil\n  \"*Non-nil in a buffer means offer to save the buffer on exit\neven if the buffer is not visiting a file.  Automatically local in\nall buffers.\")\n(make-variable-buffer-local 'buffer-offer-save)\n\n(defconst file-precious-flag nil\n  \"*Non-nil means protect against I/O errors while saving files.\nSome modes set this non-nil in particular buffers.\")\n\n(defvar version-control nil\n  \"*Control use of version numbers for backup files.\nt means make numeric backup versions unconditionally.\nnil means make them for files that have some already.\nnever means do not make them.\")\n\n(defvar dired-kept-versions 2\n  \"*When cleaning directory, number of versions to keep.\")\n\n(defvar trim-versions-without-asking nil\n  \"*If true, deletes excess backup versions silently.\nOtherwise asks confirmation.\")\n\n(defvar kept-old-versions 2\n  \"*Number of oldest versions to keep when a new numbered backup is made.\")\n\n(defvar kept-new-versions 2\n  \"*Number of newest versions to keep when a new numbered backup is made.\nIncludes the new backup.  Must be > 0\")\n\n(defconst require-final-newline nil\n  \"*t says silently put a newline at the end whenever a file is saved.\nNon-nil but not t says ask user whether to add a newline in each such case.\nnil means don't add newlines.\")\n\n(defconst auto-save-default t\n  \"*t says by default do auto-saving of every file-visiting buffer.\")\n\n(defconst auto-save-visited-file-name nil\n  \"*t says auto-save a buffer in the file it is visiting, when practical.\nNormally auto-save files are written under other names.\")\n\n(defconst save-abbrevs nil\n  \"*Non-nil means save word abbrevs too when files are saved.\nLoading an abbrev file sets this to t.\")\n\n(defconst find-file-run-dired t\n  \"*Non-nil says run dired if find-file is given the name of a directory.\")\n\n(defvar find-file-not-found-hooks nil\n  \"List of functions to be called for find-file on nonexistent file.\nThese functions are called as soon as the error is detected.\nbuffer-file-name is already set up.\nThe functions are called in the order given,\nuntil one of them returns non-nil.\")\n\n(defvar find-file-hooks nil\n  \"List of functions to be called after a buffer is loaded from a file.\nThe buffer's local variables (if any) will have been processed before the\nfunctions are called.\")\n\n(defvar write-file-hooks nil\n  \"List of functions to be called before writing out a buffer to a file.\nIf one of them returns non-nil, the file is considered already written\nand the rest are not called.\")\n\n(defconst inhibit-local-variables nil\n  \"*Non-nil means query before obeying a file's local-variables list.\nThis applies when the local-variables list is scanned automatically\nafter you find a file.  If you explicitly request such a scan with\n\\\\[normal-mode], there is no query, regardless of this variable.\")\n\n(defconst ignore-local-eval nil\n  \"*Non-nil means ignore the \\\"variable\\\" `eval' in a file's local variables.\nThis applies when the local-variables list is scanned automatically\nafter you find a file.  If you explicitly request such a scan with\n\\\\[normal-mode], there is no query, regardless of this variable.\")\n\n;; Avoid losing in versions where CLASH_DETECTION is disabled.\n(or (fboundp 'lock-buffer)\n    (fset 'lock-buffer 'ignore))\n(or (fboundp 'unlock-buffer)\n    (fset 'unlock-buffer 'ignore))\n\f\n(defun pwd ()\n  \"Show the current default directory.\"\n  (interactive nil)\n  (message \"Directory %s\" default-directory))\n\n(defun cd (dir)\n  \"Make DIR become the current buffer's default directory.\"\n  (interactive \"DChange default directory: \")\n  (setq dir (expand-file-name dir))\n  (if (not (eq system-type 'vax-vms))\n      (setq dir (file-name-as-directory dir)))\n  (if (not (file-directory-p dir))\n      (error \"%s is not a directory\" dir)\n    (setq default-directory dir))\n  (pwd))\n\n(defun load-file (file)\n  \"Load the file FILE of Lisp code.\"\n  (interactive \"fLoad file: \")\n  (load (expand-file-name file) nil nil t))\n\n(defun load-library (library)\n  \"Load the library named LIBRARY.\nThis is an interface to the function `load'.\"\n  (interactive \"sLoad library: \")\n  (load library))\n\f\n(defun switch-to-buffer-other-window (buffer)\n  \"Select buffer BUFFER in another window.\"\n  (interactive \"BSwitch to buffer in other window: \")\n  (let ((pop-up-windows t))\n    (pop-to-buffer buffer t)))\n\n(defun find-file (filename)\n  \"Edit file FILENAME.\nSwitch to a buffer visiting file FILENAME,\ncreating one if none already exists.\"\n  (interactive \"FFind file: \")\n  (switch-to-buffer (find-file-noselect filename)))\n\n(defun find-file-other-window (filename)\n  \"Edit file FILENAME, in another window.\nMay create a new window, or reuse an existing one;\nsee the function display-buffer.\"\n  (interactive \"FFind file in other window: \")\n  (switch-to-buffer-other-window (find-file-noselect filename)))\n\n(defun find-file-read-only (filename)\n  \"Edit file FILENAME but don't save without confirmation.\nLike find-file but marks buffer as read-only.\"\n  (interactive \"fFind file read-only: \")\n  (find-file filename)\n  (setq buffer-read-only t))\n\n(defun find-alternate-file (filename)\n  \"Find file FILENAME, select its buffer, kill previous buffer.\nIf the current buffer now contains an empty file that you just visited\n\\(presumably by mistake), use this command to visit the file you really want.\"\n  (interactive \"FFind alternate file: \")\n  (and (buffer-modified-p)\n;;;       (not buffer-read-only)\n       (not (yes-or-no-p (format \"Buffer %s is modified; kill anyway? \"\n\t\t\t\t (buffer-name))))\n       (error \"Aborted\"))\n  (let ((obuf (current-buffer))\n\t(ofile buffer-file-name)\n\t(oname (buffer-name)))\n    (rename-buffer \" **lose**\")\n    (setq buffer-file-name nil)\n    (unwind-protect\n\t(progn\n\t  (unlock-buffer)\n\t  (find-file filename))\n      (cond ((eq obuf (current-buffer))\n\t     (setq buffer-file-name ofile)\n\t     (lock-buffer)\n\t     (rename-buffer oname))))\n    (or (eq obuf (current-buffer))\n\t(kill-buffer obuf))))\n\n(defun create-file-buffer (filename)\n  \"Create a suitably named buffer for visiting FILENAME, and return it.\nFILENAME (sans directory) is used unchanged if that name is free;\notherwise a string <2> or <3> or ... is appended to get an unused name.\"\n  (let ((lastname (file-name-nondirectory filename)))\n    (if (string= lastname \"\")\n\t(setq lastname filename))\n    (generate-new-buffer lastname)))\n\n(defconst automount-dir-prefix \"^/tmp_mnt/\"\n  \"Regexp to match the automounter prefix in a directory name.\")\n\n(defun find-file-noselect (filename &optional nowarn)\n  \"Read file FILENAME into a buffer and return the buffer.\nIf a buffer exists visiting FILENAME, return that one,\nbut verify that the file has not changed since visited or saved.\nThe buffer is not selected, just returned to the caller.\"\n  (setq filename (expand-file-name filename))\n  ;; Get rid of the prefixes added by the automounter.\n  (if (and (string-match automount-dir-prefix filename)\n\t   (file-exists-p (file-name-directory\n\t\t\t   (substring filename (1- (match-end 0))))))\n      (setq filename (substring filename (1- (match-end 0)))))\n  (if (file-directory-p filename)\n      (if find-file-run-dired\n\t  (dired-noselect filename)\n\t(error \"%s is a directory.\" filename))\n    (let ((buf (get-file-buffer filename))\n\t  error)\n      (if buf\n\t  (or nowarn\n\t      (verify-visited-file-modtime buf)\n\t      (cond ((not (file-exists-p filename))\n\t\t     (error \"File %s no longer exists!\" filename))\n\t\t    ((yes-or-no-p\n\t\t      (if (buffer-modified-p buf)\n    \"File has changed since last visited or saved.  Flush your changes? \"\n    \"File has changed since last visited or saved.  Read from disk? \"))\n\t\t     (save-excursion\n\t\t       (set-buffer buf)\n\t\t       (revert-buffer t t)))))\n\t(save-excursion\n\t  (setq buf (create-file-buffer filename))\n\t  (set-buffer buf)\n\t  (erase-buffer)\n\t  (condition-case ()\n\t      (insert-file-contents filename t)\n\t    (file-error\n\t     (setq error t)\n\t     ;; Run find-file-not-found-hooks until one returns non-nil.\n\t     (let ((hooks find-file-not-found-hooks))\n\t       (while (and hooks\n\t\t\t   (not (funcall (car hooks))))\n\t\t (setq hooks (cdr hooks))))))\n\t  (setq default-directory (file-name-directory filename))\n\t  (after-find-file error (not nowarn))))\n      buf)))\n\f\n(defun after-find-file (&optional error warn)\n  \"Called after finding a file and by the default revert function.\nSets buffer mode, parses local variables.\nOptional args ERROR and WARN: ERROR non-nil means there was an\nerror in reading the file.  WARN non-nil means warn if there\nexists an auto-save file more recent than the visited file.\nFinishes by calling the functions in find-file-hooks.\"\n  (setq buffer-read-only (not (file-writable-p buffer-file-name)))\n  (if noninteractive\n      nil\n    (let* (not-serious\n\t   (msg\n\t    (cond ((not buffer-read-only)\n\t\t   (if (and warn\n\t\t\t    (file-newer-than-file-p (make-auto-save-file-name)\n\t\t\t\t\t\t    buffer-file-name))\n\t\t       \"Auto save file is newer; consider M-x recover-file\"\n\t\t     (setq not-serious t)\n\t\t     (if error \"(New file)\" nil)))\n\t\t  ((not error)\n\t\t   (setq not-serious t)\n\t\t   \"File is write protected\")\n\t\t  ((file-attributes buffer-file-name)\n\t\t   \"File exists, but is read-protected.\")\n\t\t  ((file-attributes (directory-file-name default-directory))\n\t\t   \"File not found and directory write-protected\")\n\t\t  (t\n\t\t   \"File not found and directory doesn't exist\"))))\n      (if msg\n\t  (progn\n\t    (message msg)\n\t    (or not-serious (sit-for 1 t)))))\n    (if auto-save-default\n\t(auto-save-mode t)))\n  (normal-mode t)\n  (mapcar 'funcall find-file-hooks))\n\n(defun normal-mode (&optional find-file)\n  \"Choose the major mode for this buffer automatically.\nAlso sets up any specified local variables of the file.\nUses the visited file name, the -*- line, and the local variables spec.\n\nThis function is called automatically from `find-file'.  In that case,\nif `inhibit-local-variables' is non-`nil' we require confirmation before\nprocessing a local variables spec.  If you run `normal-mode' explicitly,\nconfirmation is never required.\"\n  (interactive)\n  (or find-file (funcall (or default-major-mode 'fundamental-mode)))\n  (condition-case err\n      (set-auto-mode)\n    (error (message \"File mode specification error: %s\"\n\t\t    (prin1-to-string err))))\n  (condition-case err\n      (hack-local-variables (not find-file))\n    (error (message \"File local-variables error: %s\"\n\t\t    (prin1-to-string err)))))\n\n;(defvar auto-mode-alist ...) now in loaddefs.el\n(defun set-auto-mode ()\n  \"Select major mode appropriate for current buffer.\nMay base decision on visited file name (See variable  auto-mode-list)\nor on buffer contents (-*- line or local variables spec), but does not look\nfor the \\\"mode:\\\" local variable.  For that, use  hack-local-variables.\"\n  ;; Look for -*-MODENAME-*- or -*- ... mode: MODENAME; ... -*-\n  (let (beg end mode)\n    (save-excursion\n      (goto-char (point-min))\n      (skip-chars-forward \" \\t\\n\")\n      (if (and (search-forward \"-*-\" (save-excursion (end-of-line) (point)) t)\n\t       (progn\n\t\t (skip-chars-forward \" \\t\")\n\t\t (setq beg (point))\n\t\t (search-forward \"-*-\" (save-excursion (end-of-line) (point)) t))\n\t       (progn\n\t\t (forward-char -3)\n\t\t (skip-chars-backward \" \\t\")\n\t\t (setq end (point))\n\t\t (goto-char beg)\n\t\t (if (search-forward \":\" end t)\n\t\t     (progn\n\t\t       (goto-char beg)\n\t\t       (if (let ((case-fold-search t))\n\t\t\t     (search-forward \"mode:\" end t))\n\t\t\t   (progn\n\t\t\t     (skip-chars-forward \" \\t\")\n\t\t\t     (setq beg (point))\n\t\t\t     (if (search-forward \";\" end t)\n\t\t\t\t (forward-char -1)\n\t\t\t       (goto-char end))\n\t\t\t     (skip-chars-backward \" \\t\")\n\t\t\t     (setq mode (buffer-substring beg (point))))))\n\t\t   (setq mode (buffer-substring beg end)))))\n\t  (funcall (intern (concat (downcase mode) \"-mode\")))\n\t(let ((alist auto-mode-alist)\n\t      (name buffer-file-name))\n\t  (let ((case-fold-search (eq system-type 'vax-vms)))\n\t    ;; Remove backup-suffixes from file name.\n\t    (setq name (file-name-sans-versions name))\n\t    ;; Find first matching alist entry.\n\t    (while (and (not mode) alist)\n\t      (if (string-match (car (car alist)) name)\n\t\t  (setq mode (cdr (car alist))))\n\t      (setq alist (cdr alist))))\n\t  (if mode (funcall mode)))))))\n\n(defun hack-local-variables (&optional force)\n  \"Parse, and bind or evaluate as appropriate, any local variables\nfor current buffer.\"\n  ;; Look for \"Local variables:\" line in last page.\n  (save-excursion\n    (goto-char (point-max))\n    (search-backward \"\\n\\^L\" (max (- (point-max) 3000) (point-min)) 'move)\n    (if (let ((case-fold-search t))\n\t  (and (search-forward \"Local Variables:\" nil t)\n\t       (or (not inhibit-local-variables)\n\t\t   force\n\t\t   (save-window-excursion\n\t\t     (switch-to-buffer (current-buffer))\n\t\t     (save-excursion\n\t\t       (beginning-of-line)\n\t\t       (set-window-start (selected-window) (point)))\n\t\t     (y-or-n-p (format \"Set local variables as specified at end of %s? \"\n\t\t\t\t       (file-name-nondirectory buffer-file-name)))))))\n\t(let ((continue t)\n\t      prefix prefixlen suffix beg)\n\t  ;; The prefix is what comes before \"local variables:\" in its line.\n\t  ;; The suffix is what comes after \"local variables:\" in its line.\n\t  (skip-chars-forward \" \\t\")\n\t  (or (eolp)\n\t      (setq suffix (buffer-substring (point)\n\t\t\t\t\t     (progn (end-of-line) (point)))))\n\t  (goto-char (match-beginning 0))\n\t  (or (bolp)\n\t      (setq prefix\n\t\t    (buffer-substring (point)\n\t\t\t\t      (progn (beginning-of-line) (point)))))\n\t  (if prefix (setq prefixlen (length prefix)\n\t\t\t   prefix (regexp-quote prefix)))\n\t  (if suffix (setq suffix (concat (regexp-quote suffix) \"$\")))\n\t  (while continue\n\t    ;; Look at next local variable spec.\n\t    (if selective-display (re-search-forward \"[\\n\\C-m]\")\n\t      (forward-line 1))\n\t    ;; Skip the prefix, if any.\n\t    (if prefix\n\t\t(if (looking-at prefix)\n\t\t    (forward-char prefixlen)\n\t\t  (error \"Local variables entry is missing the prefix\")))\n\t    ;; Find the variable name; strip whitespace.\n\t    (skip-chars-forward \" \\t\")\n\t    (setq beg (point))\n\t    (skip-chars-forward \"^:\\n\")\n\t    (if (eolp) (error \"Missing colon in local variables entry\"))\n\t    (skip-chars-backward \" \\t\")\n\t    (let* ((str (buffer-substring beg (point)))\n\t\t   (var (read str))\n\t\t  val)\n\t      ;; Setting variable named \"end\" means end of list.\n\t      (if (string-equal (downcase str) \"end\")\n\t\t  (setq continue nil)\n\t\t;; Otherwise read the variable value.\n\t\t(skip-chars-forward \"^:\")\n\t\t(forward-char 1)\n\t\t(setq val (read (current-buffer)))\n\t\t(skip-chars-backward \"\\n\")\n\t\t(skip-chars-forward \" \\t\")\n\t\t(or (if suffix (looking-at suffix) (eolp))\n\t\t    (error \"Local variables entry is terminated incorrectly\"))\n\t\t;; Set the variable.  \"Variables\" mode and eval are funny.\n\t\t(cond ((eq var 'mode)\n\t\t       (funcall (intern (concat (downcase (symbol-name val))\n\t\t\t\t\t\t\"-mode\"))))\n\t\t      ((eq var 'force) nil)\n\t\t      ((eq var 'ignore-local-eval)\n\t\t       nil)\n\t\t      ((eq var 'eval)\n\t\t       (if (or (and ignore-local-eval (not force))\n\t\t\t       (string= (user-login-name) \"root\"))\n\t\t\t   (message \"Ignoring `eval:' in file's local variables\")\n\t\t\t (eval val)))\n\t\t      (t (make-local-variable var)\n\t\t\t (set var val))))))))))\n\f\n(defun set-visited-file-name (filename)\n  \"Change name of file visited in current buffer to FILENAME.\nThe next time the buffer is saved it will go in the newly specified file.\nnil or empty string as argument means make buffer not be visiting any file.\nRemember to delete the initial contents of the minibuffer\nif you wish to pass an empty string as the argument.\"\n  (interactive \"FSet visited file name: \")\n  (if filename\n      (setq filename\n\t    (if (string-equal filename \"\")\n\t\tnil\n\t      (expand-file-name filename))))\n  (or (equal filename buffer-file-name)\n      (null filename)\n      (progn\n\t(lock-buffer filename)\n\t(unlock-buffer)))\n  (if filename\n      (let ((new-name (file-name-nondirectory filename)))\n\t(if (string= new-name \"\")\n\t    (error \"Empty file name\"))\n\t(if (file-directory-p filename)\n\t    (error \"File %s is a directory\" filename))\n\t(if (eq system-type 'vax-vms)\n\t    (setq new-name (downcase new-name)))\n\t(setq buffer-file-name filename)\n\t(setq default-directory (file-name-directory buffer-file-name))\n\t(or (get-buffer new-name) (rename-buffer new-name)))\n    (setq buffer-file-name nil))\n  (setq buffer-backed-up nil)\n  (clear-visited-file-modtime)\n  ;; So that C-x C-w after ftp-find-file\n  ;; writes an ordinary local file in the ordinary way.\n  (kill-local-variable 'write-file-hooks)\n  ;; So that revert works normally after theat C-x C-w.\n  (kill-local-variable 'revert-buffer-function)\n  ;; Rename the auto-save file to go with the new visited name.\n  ;; If auto-save was not already on, turn it on if appropriate.\n  (if buffer-auto-save-file-name\n      (rename-auto-save-file)\n    (auto-save-mode (and buffer-file-name auto-save-default)))\n  (if buffer-file-name\n      (set-buffer-modified-p t)))\n\n(defun write-file (filename)\n  \"Write current buffer into file FILENAME.\nMakes buffer visit that file, and marks it not modified.\"\n  (interactive \"FWrite file: \")\n  (or (null filename) (string-equal filename \"\")\n      (set-visited-file-name filename))\n  (set-buffer-modified-p t)\n  (save-buffer))\n\f\n(defun backup-buffer ()\n  \"Make a backup of the disk file visited by the current buffer, if appropriate.\nThis is normally done before saving the buffer the first time.\nIf the value is non-nil, it is the result of `file-modes' on the original file;\nthis means that the caller, after saving the buffer, should change the modes\nof the new file to agree with the old modes.\"\n  (and make-backup-files\n       (not buffer-backed-up)\n       (file-exists-p buffer-file-name)\n       (memq (aref (elt (file-attributes buffer-file-name) 8) 0)\n\t     '(?- ?l))\n       (or (< (length buffer-file-name) 5)\n\t   (not (string-equal \"/tmp/\" (substring buffer-file-name 0 5))))\n    (condition-case ()\n\t(let* ((backup-info (find-backup-file-name buffer-file-name))\n\t       (backupname (car backup-info))\n\t       (targets (cdr backup-info))\n\t       setmodes)\n;\t  (if (file-directory-p buffer-file-name)\n;\t      (error \"Cannot save buffer in directory %s\" buffer-file-name))\n\t  (condition-case ()\n\t      (if (or file-precious-flag\n\t\t      (file-symlink-p buffer-file-name)\n\t\t      backup-by-copying\n\t\t      (and backup-by-copying-when-linked\n\t\t\t   (> (file-nlinks buffer-file-name) 1))\n\t\t      (and backup-by-copying-when-mismatch\n\t\t\t   (let ((attr (file-attributes buffer-file-name)))\n\t\t\t     (or (nth 9 attr)\n\t\t\t\t (/= (nth 2 attr) (user-uid))))))\n\t\t  (copy-file buffer-file-name backupname t t)\n\t\t(condition-case ()\n\t\t    (delete-file backupname)\n\t\t  (file-error nil))\n\t\t(rename-file buffer-file-name backupname t)\n\t\t(setq setmodes (file-modes backupname)))\n\t    (file-error\n\t     ;; If trouble writing the backup, write it in ~.\n\t     (setq backupname (expand-file-name \"~/%backup%~\"))\n\t     (message \"Cannot write backup file; backing up in ~/%%backup%%~\")\n\t     (sleep-for 1)\n\t     (condition-case ()\n\t\t (delete-file backupname)\n\t       (file-error nil))\n\t     (copy-file buffer-file-name backupname t t)))\n\t  (setq buffer-backed-up t)\n\t  (if (and targets\n\t\t   (or trim-versions-without-asking\n\t\t       (y-or-n-p (format \"Delete excess backup versions of %s? \"\n\t\t\t\t\t buffer-file-name))))\n\t      (while targets\n\t\t(condition-case ()\n\t\t    (delete-file (car targets))\n\t\t  (file-error nil))\n\t\t(setq targets (cdr targets))))\n\t  setmodes)\n      (file-error nil))))\n\n(defun file-name-sans-versions (name)\n  \"Return FILENAME sans backup versions or strings.\nThis is a separate procedure so your site-init or startup file can\nredefine it.\"\n  (substring name 0\n\t     (if (eq system-type 'vax-vms)\n\t\t (or (string-match \";[0-9]*\\\\'\" name)\n\t\t     (and (string-match \"\\\\.\" name (string-match \"[]>]\" name))\n\t\t\t  (string-match \"\\\\.[0-9]*\\\\'\" name (match-end 0))))\n\t       (string-match \"\\\\(\\\\.~[0-9]+\\\\)?~\\\\'\" name))))\n\n(defun make-backup-file-name (file)\n  \"Create the non-numeric backup file name for FILE.\nThis is a separate function so you can redefine it for customization.\"\n  (concat file \"~\"))\n\n(defun backup-file-name-p (file)\n  \"Return non-nil if FILE is a backup file name (numeric or not).\nThis is a separate function so you can redefine it for customization.\nYou may need to redefine file-name-sans-versions as well.\"\n  (string-match \"~$\" file))\n\n;; I believe there is no need to alter this behavior for VMS;\n;; since backup files are not made on VMS, it should not get called.\n(defun find-backup-file-name (fn)\n  \"Find a file name for a backup file, and suggestions for deletions.\nValue is a list whose car is the name for the backup file\n and whose cdr is a list of old versions to consider deleting now.\"\n  (if (eq version-control 'never)\n      (list (make-backup-file-name fn))\n    (let* ((base-versions (concat (file-name-nondirectory fn) \".~\"))\n\t   (bv-length (length base-versions))\n\t   (possibilities (file-name-all-completions\n\t\t\t   base-versions\n\t\t\t   (file-name-directory fn)))\n\t   (versions (sort (mapcar 'backup-extract-version possibilities)\n\t\t\t   '<))\n\t   (high-water-mark (apply 'max (cons 0 versions)))\n\t   (deserve-versions-p\n\t    (or version-control\n\t\t(> high-water-mark 0)))\n\t   (number-to-delete (- (length versions)\n\t\t\t\t;; -1 compensates for the backup\n\t\t\t\t;; we are about to make.\n\t\t\t\tkept-old-versions kept-new-versions -1)))\n      (if (not deserve-versions-p)\n\t  (list (make-backup-file-name fn))\n\t(cons (concat fn \".~\" (int-to-string (1+ high-water-mark)) \"~\")\n\t      (if (and (> number-to-delete 0)\n\t\t       ;; Delete nothing if there is overflow\n\t\t       ;; in the number of versions to keep.\n\t\t       (>= (+ kept-new-versions kept-old-versions -1) 0))\n\t\t  (mapcar (function (lambda (n)\n\t\t\t\t      (concat fn \".~\"\n\t\t\t\t\t      (int-to-string n) \"~\")))\n\t\t\t  (let ((v (nthcdr kept-old-versions versions)))\n\t\t\t    (rplacd (nthcdr (1- number-to-delete) v) ())\n\t\t\t    v))))))))\n\n(defun backup-extract-version (fn)\n  (if (and (string-match \"[0-9]+~$\" fn bv-length)\n\t   (= (match-beginning 0) bv-length))\n      (string-to-int (substring fn bv-length -1))\n      0))\n\n(defun file-nlinks (filename)\n  \"Return number of names file FILENAME has.\" \n  (car (cdr (file-attributes filename))))\n\f\n(defun save-buffer (&optional args)\n  \"Save current buffer in visited file if modified.  Versions described below.\n\nBy default, makes the previous version into a backup file\n if previously requested or if this is the first save.\nWith 1 or 3 \\\\[universal-argument]'s, marks this version\n to become a backup when the next save is done.\nWith 2 or 3 \\\\[universal-argument]'s,\n unconditionally makes the previous version into a backup file.\nWith argument of 0, never makes the previous version into a backup file.\n\nIf a file's name is FOO, the names of its numbered backup versions are\n FOO.~i~ for various integers i.  A non-numbered backup file is called FOO~.\nNumeric backups (rather than FOO~) will be made if value of\n `version-control' is not the atom `never' and either there are already\n numeric versions of the file being backed up, or `version-control' is\n non-nil.\nWe don't want excessive versions piling up, so there are variables\n `kept-old-versions', which tells Emacs how many oldest versions to keep,\n and `kept-new-versions', which tells how many newest versions to keep.\n Defaults are 2 old versions and 2 new.\n`dired-kept-versions' controls dired's clean-directory (.) command.\nIf `trim-versions-without-asking' is nil, system will query user\n before trimming versions.  Otherwise it does it silently.\"\n  (interactive \"p\")\n  (let ((modp (buffer-modified-p))\n\t(large (> (buffer-size) 50000))\n\t(make-backup-files (and make-backup-files (not (eq args 0)))))\n    (and modp (memq args '(16 64)) (setq buffer-backed-up nil))\n    (if (and modp large) (message \"Saving file %s...\" (buffer-file-name)))\n    (basic-save-buffer)\n    (and modp (memq args '(4 64)) (setq buffer-backed-up nil))))\n\n(defun delete-auto-save-file-if-necessary ()\n  \"Delete the auto-save filename for the current buffer (if it has one)\nif variable  delete-auto-save-files  is non-nil.\"\n  (and buffer-auto-save-file-name delete-auto-save-files\n       (not (string= buffer-file-name buffer-auto-save-file-name))\n       (progn\n\t (condition-case ()\n\t     (delete-file buffer-auto-save-file-name)\n\t   (file-error nil))\n\t (set-buffer-auto-saved))))\n\n(defun basic-save-buffer ()\n  \"Save the current buffer in its visited file, if it has been modified.\"  \n  (interactive)\n  (if (buffer-modified-p)\n      (let (setmodes tempsetmodes)\n\t(or buffer-file-name\n\t    (progn\n\t      (setq buffer-file-name\n\t\t    (expand-file-name (read-file-name \"File to save in: \") nil)\n\t\t    default-directory (file-name-directory buffer-file-name))\n\t      (auto-save-mode auto-save-default)))\n\t(if (not (file-writable-p buffer-file-name))\n\t    (if (yes-or-no-p\n\t\t (format \"File %s is write-protected; try to save anyway? \"\n\t\t\t (file-name-nondirectory buffer-file-name)))\n\t\t(setq tempsetmodes t)\n\t      (error\n   \"Attempt to save to a file which you aren't allowed to write\")))\n\t(or (verify-visited-file-modtime (current-buffer))\n\t    (not (file-exists-p buffer-file-name))\n\t    (yes-or-no-p\n\t      \"Disk file has changed since visited or saved.  Save anyway? \")\n\t    (error \"Save not confirmed\"))\n\t(or buffer-backed-up\n\t    (setq setmodes (backup-buffer)))\n\t(save-restriction\n\t  (widen)\n\t  (and (> (point-max) 1)\n\t       (/= (char-after (1- (point-max))) ?\\n)\n\t       (or (eq require-final-newline t)\n\t\t   (and require-final-newline\n\t\t\t(yes-or-no-p\n\t\t\t (format \"Buffer %s does not end in newline.  Add one? \"\n\t\t\t\t (buffer-name)))))\n\t       (save-excursion\n\t\t (goto-char (point-max))\n\t\t (insert ?\\n)))\n\t  (let ((hooks write-file-hooks)\n\t\t(done nil))\n\t    (while (and hooks\n\t\t\t(not (setq done (funcall (car hooks)))))\n\t      (setq hooks (cdr hooks)))\n\t    ;; If a hook returned t, file is already \"written\".\n\t    (cond (done (setq setmodes nil))\n\t\t  ((not done)\n\t\t   (if file-precious-flag\n\t\t       ;; If file is precious, rename it away before\n\t\t       ;; overwriting it.\n\t\t       (let ((rename t) nodelete\n\t\t\t     (file (concat buffer-file-name \"#\")))\n\t\t\t (condition-case ()\n\t\t\t     (progn (rename-file buffer-file-name file t)\n\t\t\t\t    (setq setmodes (file-modes file)))\n\t\t\t   (file-error (setq rename nil nodelete t)))\n\t\t\t (unwind-protect\n\t\t\t     (progn (clear-visited-file-modtime)\n\t\t\t\t    (write-region (point-min) (point-max)\n\t\t\t\t\t\t  buffer-file-name nil t)\n\t\t\t\t    (setq rename nil))\n\t\t\t   ;; If rename is still t, writing failed.\n\t\t\t   ;; So rename the old file back to original name,\n\t\t\t   (if rename\n\t\t\t       (progn\n\t\t\t\t (rename-file file buffer-file-name t)\n\t\t\t\t (clear-visited-file-modtime))\n\t\t\t     ;; Otherwise we don't need the original file,\n\t\t\t     ;; so flush it.  Unless we already lost it.\n\t\t\t     (or nodelete\n\t\t\t\t (condition-case ()\n\t\t\t\t     (delete-file file)\n\t\t\t\t   (error nil))))))\n\t\t     ;; If file not writable, see if we can make it writable\n\t\t     ;; temporarily while we write it.\n\t\t     ;; But no need to do so if we have just backed it up\n\t\t     ;; (setmodes is set) because that says we're superseding.\n\t\t     ;; Systems with version numbers need not do this.\n\t\t     (if (eq system-type 'vax-vms)\n\t\t\t (setq setmodes nil tempsetmodes nil))\n\t\t     (cond ((and tempsetmodes (not setmodes))\n\t\t\t    ;; Change the mode back, after writing.\n\t\t\t    (setq setmodes (file-modes buffer-file-name))\n\t\t\t    (set-file-modes buffer-file-name 511)))\n\t\t     (write-region (point-min) (point-max) \n\t\t\t\t   buffer-file-name nil t)))))\n\t  (if setmodes\n\t      (condition-case ()\n\t\t   (set-file-modes buffer-file-name setmodes)\n\t\t(error nil))))\n\t(delete-auto-save-file-if-necessary))\n    (message \"(No changes need to be saved)\")))\n\n(defun save-some-buffers (&optional arg exiting)\n  \"Save some modified file-visiting buffers.  Asks user about each one.\nOptional argument (the prefix) non-nil means save all with no questions.\nOptional second argument EXITING means ask about certain non-file buffers\n as well as about file buffers.\"\n  (interactive \"P\")\n  (let (considered (list (buffer-list)))\n    (while list\n      (let ((buffer (car list)))\n\t(and (buffer-modified-p buffer)\n\t     (save-excursion\n\t       (set-buffer buffer)\n\t       (and\n\t\t(or buffer-file-name\n\t\t    (and exiting buffer-offer-save (> (buffer-size) 0)))\n\t\t(setq considered t)\n\t\t(or arg\n\t\t    (y-or-n-p (if buffer-file-name\n\t\t\t\t  (format \"Save file %s? \"\n\t\t\t\t\t  buffer-file-name)\n\t\t\t\t(format \"Save buffer %s? \" (buffer-name)))))\n\t\t(condition-case ()\n\t\t    (save-buffer)\n\t\t  (error nil))))))\n      (setq list (cdr list)))\n    (and save-abbrevs abbrevs-changed\n\t (progn\n\t   (setq considered t)\n\t   (if (or arg\n\t\t   (y-or-n-p (format \"Save abbrevs in %s? \" abbrev-file-name)))\n\t       (write-abbrev-file nil))\n\t   ;; Don't keep bothering user if he says no.\n\t   (setq abbrevs-changed nil)))\n    (if considered\n\t(message \"\")\n\t(message \"(No files need saving)\"))))\n\f\n(defun not-modified ()\n  \"Mark current buffer as unmodified, not needing to be saved.\"\n  (interactive)\n  (message \"Modification-flag cleared\")\n  (set-buffer-modified-p nil))\n\n(defun toggle-read-only ()\n  \"Change whether this buffer is visiting its file read-only.\"\n  (interactive)\n  (setq buffer-read-only (not buffer-read-only))\n  ;; Force mode-line redisplay\n  (set-buffer-modified-p (buffer-modified-p)))\n\n(defun insert-file (filename)\n  \"Insert contents of file FILENAME into buffer after point.\nSet mark after the inserted text.\"\n  (interactive \"fInsert file: \")\n  (let ((tem (insert-file-contents filename)))\n    (push-mark (+ (point) (car (cdr tem))))))\n\n(defun append-to-file (start end filename)\n  \"Append the contents of the region to the end of file FILENAME.\nWhen called from a function, expects three arguments,\nSTART, END and FILENAME.  START and END are buffer positions\nsaying what text to write.\"\n  (interactive \"r\\nFAppend to file: \")\n  (write-region start end filename t))\n\n(defvar revert-buffer-function nil\n  \"Function to use to revert this buffer, or nil to do the default.\")\n\n(defun revert-buffer (&optional arg noconfirm)\n  \"Replace the buffer text with the text of the visited file on disk.\nThis undoes all changes since the file was visited or saved.\nIf latest auto-save file is more recent than the visited file,\nasks user whether to use that instead.\nFirst argument (optional) non-nil means don't offer to use auto-save file.\n This is the prefix arg when called interactively.\n\nSecond argument (optional) non-nil means don't ask for confirmation at all.\n\nIf revert-buffer-function's value is non-nil, it is called to do the work.\"\n  (interactive \"P\")\n  (if revert-buffer-function\n      (funcall revert-buffer-function arg noconfirm)\n    (let* ((opoint (point))\n\t   (auto-save-p (and (null arg) (recent-auto-save-p)\n\t\t\t     buffer-auto-save-file-name\n\t\t\t     (file-readable-p buffer-auto-save-file-name)\n\t\t\t     (y-or-n-p\n   \"Buffer has been auto-saved recently.  Revert from auto-save file? \")))\n\t   (file-name (if auto-save-p\n\t\t\t  buffer-auto-save-file-name\n\t\t\tbuffer-file-name)))\n      (cond ((null file-name)\n\t     (error \"Buffer does not seem to be associated with any file\"))\n\t    ((not (file-exists-p file-name))\n\t     (error \"File %s no longer exists!\" file-name))\n\t    ((or noconfirm\n\t\t (yes-or-no-p (format \"Revert buffer from file %s? \"\n\t\t\t\t      file-name)))\n\t     ;; If file was backed up but has changed since,\n\t     ;; we shd make another backup.\n\t     (and (not auto-save-p)\n\t\t  (not (verify-visited-file-modtime (current-buffer)))\n\t\t  (setq buffer-backed-up nil))\n\t     ;; Discard all the undo information.\n\t     (or (eq buffer-undo-list t)\n\t\t (setq buffer-undo-list nil))\n\t     (let ((buffer-read-only nil)\n\t\t   ;; Don't record undo info for the revert itself.\n\t\t   ;; Doing so chews up too much storage.\n\t\t   (buffer-undo-list t))\n\t       ;; Bind buffer-file-name to nil\n\t       ;; so that we don't try to lock the file.\n\t       (let ((buffer-file-name nil))\n\t\t (or auto-save-p\n\t\t     (unlock-buffer))\n\t\t (erase-buffer))\n\t       (insert-file-contents file-name (not auto-save-p)))\n\t     (goto-char (min opoint (point-max)))\n\t     (after-find-file nil)\n\t     t)))))\n\n(defun recover-file (file)\n  \"Visit file FILE, but get contents from its last auto-save file.\"\n  (interactive \"FRecover file: \")\n  (setq file (expand-file-name file))\n  (if (auto-save-file-name-p file) (error \"%s is an auto-save file\" file))\n  (let ((file-name (let ((buffer-file-name file))\n\t\t     (make-auto-save-file-name))))\n    (cond ((not (file-newer-than-file-p file-name file))\n\t   (error \"Auto-save file %s not current\" file-name))\n\t  ((save-window-excursion\n\t     (if (not (eq system-type 'vax-vms))\n\t\t (with-output-to-temp-buffer \"*Directory*\"\n\t\t   (buffer-flush-undo standard-output)\n\t\t   (call-process \"ls\" nil standard-output nil\n\t\t\t\t \"-l\" file file-name)))\n\t     (yes-or-no-p (format \"Recover auto save file %s? \" file-name)))\n\t   (switch-to-buffer (find-file-noselect file t))\n\t   (let ((buffer-read-only nil))\n\t     (erase-buffer)\n\t     (insert-file-contents file-name nil))\n\t   (after-find-file nil))\n\t  (t (error \"Recover-file cancelled.\"))))\n  (setq buffer-auto-save-file-name nil)\n  (message \"Auto-save off in this buffer till you do M-x auto-save-mode.\"))\n\n(defun kill-some-buffers ()\n  \"For each buffer, ask whether to kill it.\"\n  (interactive)\n  (let ((list (buffer-list)))\n    (while list\n      (let* ((buffer (car list))\n\t     (name (buffer-name buffer)))\n\t(and (not (string-equal name \"\"))\n\t     (/= (aref name 0) ? )\n\t     (yes-or-no-p\n\t      (format \"Buffer %s %s.  Kill? \"\n\t\t      name\n\t\t      (if (buffer-modified-p buffer)\n\t\t\t  \"HAS BEEN EDITED\" \"is unmodified\")))\n\t     (kill-buffer buffer)))\n      (setq list (cdr list)))))\n\f\n(defun auto-save-mode (arg)\n  \"Toggle auto-saving of contents of current buffer.\nWith arg, turn auto-saving on if arg is positive, else off.\"\n  (interactive \"P\")\n  (setq buffer-auto-save-file-name\n        (and (if (null arg)\n\t\t (not buffer-auto-save-file-name)\n\t       (or (eq arg t) (listp arg) (and (integerp arg) (> arg 0))))\n\t     (if (and buffer-file-name auto-save-visited-file-name\n\t\t      (not buffer-read-only))\n\t\t buffer-file-name\n\t       (make-auto-save-file-name))))\n  (if (interactive-p)\n      (message \"Auto-save %s (in this buffer)\"\n\t       (if buffer-auto-save-file-name \"on\" \"off\")))\n  buffer-auto-save-file-name)\n\n(defun rename-auto-save-file ()\n  \"Adjust current buffer's auto save file name for current conditions.\nAlso rename any existing auto save file.\"\n  (let ((osave buffer-auto-save-file-name))\n    (setq buffer-auto-save-file-name\n\t  (make-auto-save-file-name))\n    (if (and osave buffer-auto-save-file-name\n\t     (not (string= buffer-auto-save-file-name buffer-file-name))\n\t     (not (string= buffer-auto-save-file-name osave))\n\t     (file-exists-p osave))\n\t(rename-file osave buffer-auto-save-file-name t))))\n\n(defun make-auto-save-file-name ()\n  \"Return file name to use for auto-saves of current buffer.\nDoes not consider auto-save-visited-file-name; that is checked\nbefore calling this function.\nYou can redefine this for customization.\nSee also auto-save-file-name-p.\"\n  (if buffer-file-name\n      (concat (file-name-directory buffer-file-name)\n\t      \"#\"\n\t      (file-name-nondirectory buffer-file-name)\n\t      \"#\")\n    (expand-file-name (concat \"#%\" (buffer-name) \"#\"))))\n\n(defun auto-save-file-name-p (filename)\n  \"Return non-nil if FILENAME can be yielded by make-auto-save-file-name.\nFILENAME should lack slashes.\nYou can redefine this for customization.\"\n  (string-match \"^#.*#$\" filename))\n\f\n(defconst list-directory-brief-switches \"-CF\"\n  \"*Switches for list-directory to pass to `ls' for brief listing,\")\n(defconst list-directory-verbose-switches \"-l\"\n  \"*Switches for list-directory to pass to `ls' for verbose listing,\")\n\n(defun list-directory (dirname &optional verbose)\n  \"Display a list of files in or matching DIRNAME, a la `ls'.\nDIRNAME is globbed by the shell if necessary.\nPrefix arg (second arg if noninteractive) means supply -l switch to `ls'.\nActions controlled by variables list-directory-brief-switches\n and list-directory-verbose-switches.\"\n  (interactive (let ((pfx current-prefix-arg))\n\t\t (list (read-file-name (if pfx \"List directory (verbose): \"\n\t\t\t\t\t \"List directory (brief): \")\n\t\t\t\t       nil default-directory nil)\n\t\t       pfx)))\n  (let ((switches (if verbose list-directory-verbose-switches\n\t\t    list-directory-brief-switches))\n\tfull-dir-p)\n    (or dirname (setq dirname default-directory))\n    (if (file-directory-p dirname)\n\t(progn\n\t (setq full-dir-p t)\n\t (or (string-match \"/$\" dirname)\n\t     (setq dirname (concat dirname \"/\")))))\n    (setq dirname (expand-file-name dirname))\n    (with-output-to-temp-buffer \"*Directory*\"\n      (buffer-flush-undo standard-output)\n      (princ \"Directory \")\n      (princ dirname)\n      (terpri)\n      (if full-dir-p\n\t  (call-process \"ls\" nil standard-output nil\n\t\t\tswitches dirname)\n\t(let ((default-directory (file-name-directory dirname)))\n\t  (call-process shell-file-name nil standard-output nil\n\t\t\t\"-c\" (concat \"exec ls \"\n\t\t\t\t     switches \" \"\n\t\t\t\t     (file-name-nondirectory dirname))))))))\n\n(defun save-buffers-kill-emacs (&optional arg)\n  \"Offer to save each buffer, then kill this Emacs fork.\nWith prefix arg, silently save all file-visiting buffers, then kill.\"\n  (interactive \"P\")\n  (save-some-buffers arg t)\n  (and (or (not (memq t (mapcar (function\n\t\t\t\t  (lambda (buf) (and (buffer-file-name buf)\n\t\t\t\t\t\t     (buffer-modified-p buf))))\n\t\t\t\t(buffer-list))))\n\t   (yes-or-no-p \"Modified buffers exist; exit anyway? \"))\n       (or (not (fboundp 'process-list))\n\t   ;; process-list is not defined on VMS.\n\t   (let ((processes (process-list))\n\t\t active)\n\t     (while processes\n\t       (and (memq (process-status (car processes)) '(run stop open))\n\t\t    (let ((val (process-kill-without-query (car processes))))\n\t\t      (process-kill-without-query (car processes) val)\n\t\t      val)\n\t\t    (setq active t))\n\t       (setq processes (cdr processes)))\n\t     (or (not active)\n\t\t (yes-or-no-p \"Active processes exist; kill them and exit anyway? \"))))\n       (kill-emacs)))\n\f\n(define-key ctl-x-map \"\\C-f\" 'find-file)\n(define-key ctl-x-map \"\\C-q\" 'toggle-read-only)\n(define-key ctl-x-map \"\\C-r\" 'find-file-read-only)\n(define-key ctl-x-map \"\\C-v\" 'find-alternate-file)\n(define-key ctl-x-map \"\\C-s\" 'save-buffer)\n(define-key ctl-x-map \"s\" 'save-some-buffers)\n(define-key ctl-x-map \"\\C-w\" 'write-file)\n(define-key ctl-x-map \"i\" 'insert-file)\n(define-key esc-map \"~\" 'not-modified)\n(define-key ctl-x-map \"\\C-d\" 'list-directory)\n(define-key ctl-x-map \"\\C-c\" 'save-buffers-kill-emacs)\n\n(defvar ctl-x-4-map (make-keymap)\n  \"Keymap for subcommands of C-x 4\")\n(fset 'ctl-x-4-prefix ctl-x-4-map)\n(define-key ctl-x-map \"4\" 'ctl-x-4-prefix)\n(define-key ctl-x-4-map \"f\" 'find-file-other-window)\n(define-key ctl-x-4-map \"\\C-f\" 'find-file-other-window)\n(define-key ctl-x-4-map \"b\" 'switch-to-buffer-other-window)\n",
    "8e9ac73dc9bd0cf2595c3eb27a623818": ";; GNU Emacs window commands aside from those written in C.\n;; Copyright (C) 1985 Free Software Foundation, Inc.\n\n;; This file is part of GNU Emacs.\n\n;; GNU Emacs is free software; you can redistribute it and/or modify\n;; it under the terms of the GNU General Public License as published by\n;; the Free Software Foundation; either version 1, or (at your option)\n;; any later version.\n\n;; GNU Emacs is distributed in the hope that it will be useful,\n;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n;; GNU General Public License for more details.\n\n;; You should have received a copy of the GNU General Public License\n;; along with GNU Emacs; see the file COPYING.  If not, write to\n;; the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n\n\n(defun split-window-vertically (&optional arg)\n  \"Split current window into two windows, one above the other.\nThis window becomes the uppermost of the two, and gets\nARG lines.  No arg means split equally.\"\n  (interactive \"P\")\n  (split-window nil (and arg (prefix-numeric-value arg))))\n\n(defun split-window-horizontally (&optional arg)\n  \"Split current window into two windows side by side.\nThis window becomes the leftmost of the two, and gets\nARG columns.  No arg means split equally.\"\n  (interactive \"P\")\n  (split-window nil (and arg (prefix-numeric-value arg)) t))\n\n(defun enlarge-window-horizontally (arg)\n  \"Make current window ARG columns wider.\"\n  (interactive \"p\")\n  (enlarge-window arg t))\n\n(defun shrink-window-horizontally (arg)\n  \"Make current window ARG columns narrower.\"\n  (interactive \"p\")\n  (shrink-window arg t))\n\n(define-key ctl-x-map \"2\" 'split-window-vertically)\n(define-key ctl-x-map \"5\" 'split-window-horizontally)\n(define-key ctl-x-map \"}\" 'enlarge-window-horizontally)\n(define-key ctl-x-map \"{\" 'shrink-window-horizontally)\n",
    "08ea0a716b5e1caf9be9f83bcc81ca17": ";; Abbrev mode commands for Emacs\n\n;; Copyright (C) 1985, 1986 Free Software Foundation, Inc.\n\n;; This file is part of GNU Emacs.\n\n;; GNU Emacs is free software; you can redistribute it and/or modify\n;; it under the terms of the GNU General Public License as published by\n;; the Free Software Foundation; either version 1, or (at your option)\n;; any later version.\n\n;; GNU Emacs is distributed in the hope that it will be useful,\n;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n;; GNU General Public License for more details.\n\n;; You should have received a copy of the GNU General Public License\n;; along with GNU Emacs; see the file COPYING.  If not, write to\n;; the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n\n\n(defun abbrev-mode (arg)\n  \"Toggle abbrev mode.\nWith arg, turn abbrev mode on iff arg is positive.\nIn abbrev mode, inserting an abbreviation causes it to expand\nand be replaced by its expansion.\"\n  (interactive \"P\")\n  (setq abbrev-mode\n\t(if (null arg) (not abbrev-mode)\n\t  (> (prefix-numeric-value arg) 0)))\n  (set-buffer-modified-p (buffer-modified-p))) ;No-op, but updates mode line.\n\f\n(defvar edit-abbrevs-map nil\n  \"Keymap used in edit-abbrevs.\")\n(if edit-abbrevs-map\n    nil\n  (setq edit-abbrevs-map (make-sparse-keymap))\n  (define-key edit-abbrevs-map \"\\C-x\\C-s\" 'edit-abbrevs-redefine)\n  (define-key edit-abbrevs-map \"\\C-c\\C-c\" 'edit-abbrevs-redefine))\n\n(defun kill-all-abbrevs ()\n  \"Undefine all defined abbrevs.\"\n  (interactive)\n  (let ((tables abbrev-table-name-list))\n    (while tables\n      (clear-abbrev-table (symbol-value (car tables)))\n      (setq tables (cdr tables)))))\n\n(defun insert-abbrevs ()\n  \"Insert after point a description of all defined abbrevs.\nMark is set after the inserted text.\"\n  (interactive)\n  (push-mark\n   (save-excursion\n    (let ((tables abbrev-table-name-list))\n      (while tables\n\t(insert-abbrev-table-description (car tables) t)\n\t(setq tables (cdr tables))))\n    (point))))\n\n(defun list-abbrevs ()\n  \"Display a list of all defined abbrevs.\"\n  (interactive)\n  (display-buffer (prepare-abbrev-list-buffer)))\n\n(defun prepare-abbrev-list-buffer ()\n  (save-excursion\n    (set-buffer (get-buffer-create \"*Abbrevs*\"))\n    (erase-buffer)\n    (let ((tables abbrev-table-name-list))\n      (while tables\n\t(insert-abbrev-table-description (car tables) t)\n\t(setq tables (cdr tables))))\n    (goto-char (point-min))\n    (set-buffer-modified-p nil)\n    (edit-abbrevs-mode))\n  (get-buffer-create \"*Abbrevs*\"))\n\n(defun edit-abbrevs-mode ()\n  \"Major mode for editing the list of abbrev definitions.\n\\\\{edit-abbrevs-map}\"\n  (interactive)\n  (setq major-mode 'edit-abbrevs-mode)\n  (setq mode-name \"Edit-Abbrevs\")\n  (use-local-map edit-abbrevs-map))\n\n(defun edit-abbrevs ()\n  \"Alter abbrev definitions by editing a list of them.\nSelects a buffer containing a list of abbrev definitions.\nYou can edit them and type C-c C-c to redefine abbrevs\naccording to your editing.\nBuffer contains a header line for each abbrev table,\n which is the abbrev table name in parentheses.\nThis is followed by one line per abbrev in that table:\nNAME   USECOUNT   EXPANSION   HOOK\nwhere NAME and EXPANSION are strings with quotes,\nUSECOUNT is an integer, and HOOK is any valid function\nor may be omitted (it is usually omitted).\"\n  (interactive)\n  (switch-to-buffer (prepare-abbrev-list-buffer)))\n\n(defun edit-abbrevs-redefine ()\n  \"Redefine abbrevs according to current buffer contents.\"\n  (interactive)\n  (define-abbrevs t)\n  (set-buffer-modified-p nil))\n\n(defun define-abbrevs (&optional arg)\n  \"Define abbrevs according to current visible buffer contents.\nSee documentation of edit-abbrevs for info on the format of the\ntext you must have in the buffer.\nWith argument, eliminate all abbrev definitions except\nthe ones defined from the buffer now.\"\n  (interactive \"P\")\n  (if arg (kill-all-abbrevs))\n  (save-excursion\n   (goto-char (point-min))\n   (while (and (not (eobp)) (re-search-forward \"^(\" nil t))\n     (let* ((buf (current-buffer))\n\t    (table (read buf))\n\t    abbrevs)\n       (forward-line 1)\n       (while (progn (forward-line 1)\n\t\t     (not (eolp)))\n\t (setq name (read buf) count (read buf) exp (read buf))\n\t (skip-chars-backward \" \\t\\n\\f\")\n\t (setq hook (if (not (eolp)) (read buf)))\n\t (skip-chars-backward \" \\t\\n\\f\")\n\t (setq abbrevs (cons (list name exp hook count) abbrevs)))\n       (define-abbrev-table table abbrevs)))))\n\n(defun read-abbrev-file (file &optional quietly)\n  \"Read abbrev definitions from file written with write-abbrev-file.\nTakes file name as argument.\nOptional second argument non-nil means don't print anything.\"\n  (interactive \"fRead abbrev file: \")\n  (load (if (and file (> (length file) 0)) file abbrev-file-name)\n\tnil quietly)\n  (setq save-abbrevs t abbrevs-changed nil))\n\n(defun quietly-read-abbrev-file (file)\n  \"Read abbrev definitions from file written with write-abbrev-file.\nTakes file name as argument.  Does not print anything.\"\n  ;(interactive \"fRead abbrev file: \")\n  (read-abbrev-file file t))\n\n(defun write-abbrev-file (file)\n  \"Write all abbrev definitions to file of Lisp code.\nThe file can be loaded to define the same abbrevs.\"\n  (interactive \"FWrite abbrev file: \")\n  (or (and file (> (length file) 0))\n      (setq file abbrev-file-name))\n  (save-excursion\n   (set-buffer (get-buffer-create \" write-abbrev-file\"))\n   (erase-buffer)\n   (let ((tables abbrev-table-name-list))\n     (while tables\n       (insert-abbrev-table-description (car tables) nil)\n       (setq tables (cdr tables))))\n   (write-region 1 (point-max) file)\n   (erase-buffer)))\n\f\n(defun add-mode-abbrev (arg)\n  \"Define mode-specific abbrev for last word(s) before point.\nArgument is how many words before point form the expansion;\nor zero means the region is the expansion.\nA negative argument means to undefine the specified abbrev.\nReads the abbreviation in the minibuffer.\"\n  (interactive \"p\")\n  (add-abbrev\n   (if only-global-abbrevs\n       global-abbrev-table \n     (or local-abbrev-table\n\t (error \"No per-mode abbrev table.\")))\n   \"Mode\" arg))\n\n(defun add-global-abbrev (arg)\n  \"Define global (all modes) abbrev for last word(s) before point.\nArgument is how many words before point form the expansion;\nor zero means the region is the expansion.\nA negative argument means to undefine the specified abbrev.\nReads the abbreviation in the minibuffer.\"\n  (interactive \"p\")\n  (add-abbrev global-abbrev-table \"Global\" arg))\n\n(defun add-abbrev (table type arg)\n  (let ((exp (and (>= arg 0)\n\t\t  (buffer-substring\n\t\t   (point)\n\t\t   (if (= arg 0) (mark)\n\t\t     (save-excursion (forward-word (- arg)) (point))))))\n\tname)\n    (setq name (read-string (format \"%s abbrev for \\\"%s\\\": \"\n\t\t\t\t    type exp)))\n    (if (or (null exp)\n\t    (not (abbrev-expansion name table))\n\t    (y-or-n-p (format \"%s expands to \\\"%s\\\"; redefine? \"\n\t\t\t      name (abbrev-expansion name table))))\n\t(define-abbrev table (downcase name) exp))))\n\t\n(defun inverse-add-mode-abbrev (arg)\n  \"Define last word before point as a mode-specific abbrev.\nWith argument N, defines the Nth word before point.\nReads the expansion in the minibuffer.\nExpands the abbreviation after defining it.\"\n  (interactive \"p\")\n  (inverse-add-abbrev\n   (if only-global-abbrevs\n       global-abbrev-table \n     (or local-abbrev-table\n\t (error \"No per-mode abbrev table.\")))\n   \"Mode\" arg))\n\n(defun inverse-add-global-abbrev (arg)\n  \"Define last word before point as a global (mode-independent) abbrev.\nWith argument N, defines the Nth word before point.\nReads the expansion in the minibuffer.\nExpands the abbreviation after defining it.\"\n  (interactive \"p\")\n  (inverse-add-abbrev global-abbrev-table \"Global\" arg))\n\n(defun inverse-add-abbrev (table type arg)\n  (let (name nameloc exp)\n    (save-excursion\n     (forward-word (- arg))\n     (setq name (buffer-substring (point) (progn (forward-word 1)\n\t\t\t\t\t       (setq nameloc (point))))))\n    (setq exp (read-string (format \"%s expansion for \\\"%s\\\": \"\n\t\t\t\t   type name)))\n    (if (or (not (abbrev-expansion name table))\n\t    (y-or-n-p (format \"%s expands to \\\"%s\\\"; redefine? \"\n\t\t\t      name (abbrev-expansion name table))))\n\t(progn\n\t (define-abbrev table (downcase name) exp)\n\t (save-excursion\n\t  (goto-char nameloc)\n\t  (expand-abbrev))))))\n\n(defun abbrev-prefix-mark (&optional arg)\n  \"Mark current point as the beginning of an abbrev.\nAbbrev to be expanded starts here rather than at\nbeginning of word.  This way, you can expand an abbrev\nwith a prefix: insert the prefix, use this command,\nthen insert the abbrev.\"\n  (interactive \"P\")\n  (or arg (expand-abbrev))\n  (setq abbrev-start-location (point-marker)\n\tabbrev-start-location-buffer (current-buffer))\n  (insert \"-\"))\n\n(defun expand-region-abbrevs (start end &optional noquery)\n  \"For abbrev occurrence in the region, offer to expand it.\nThe user is asked to type y or n for each occurrence.\nA numeric argument means don't query; expand all abbrevs.\nCalling from a program, arguments are START END &optional NOQUERY.\"\n  (interactive \"r\")\n  (save-excursion\n    (goto-char (min start end))\n    (let ((lim (- (point-max) (max start end))))\n      (while (and (not (eobp))\n\t\t  (progn (forward-word 1)\n\t\t\t (<= (point) (- (point-max) lim))))\n\t(let ((modp (buffer-modified-p)))\n\t  (if (expand-abbrev)\n\t      (progn\n\t       (set-buffer-modified-p modp)\n\t       (unexpand-abbrev)\n\t       (if (or noquery (y-or-n-p \"Expand this? \"))\n\t\t   (expand-abbrev)))))))))\n",
    "ead6847c686cfbed9b7cede06a0f867f": ";;; Missing: P command, sorting, setting file modes.\n;;; Dired buffer containing multiple directories gets totally confused\n;;; Implement insertion of subdirectories in situ --- tree dired\n\n;; DIRED commands for Emacs\n;; Copyright (C) 1985, 1986 Free Software Foundation, Inc.\n\n;; This file is part of GNU Emacs.\n\n;; GNU Emacs is free software; you can redistribute it and/or modify\n;; it under the terms of the GNU General Public License as published by\n;; the Free Software Foundation; either version 1, or (at your option)\n;; any later version.\n\n;; GNU Emacs is distributed in the hope that it will be useful,\n;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n;; GNU General Public License for more details.\n\n;; You should have received a copy of the GNU General Public License\n;; along with GNU Emacs; see the file COPYING.  If not, write to\n;; the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n\n\n;In loaddefs.el\n;(defvar dired-listing-switches \"-al\"\n;  \"Switches passed to ls for dired. MUST contain the 'l' option.\n;CANNOT contain the 'F' option.\")\n\n(defun dired-readin (dirname buffer)\n  (save-excursion\n    (message \"Reading directory %s...\" dirname)\n    (set-buffer buffer)\n    (let ((buffer-read-only nil))\n      (widen)\n      (erase-buffer)\n      (setq dirname (expand-file-name dirname))\n      (if (file-directory-p dirname)\n\t  (call-process \"ls\" nil buffer nil\n\t\t\tdired-listing-switches dirname)\n\t(let ((default-directory (file-name-directory dirname)))\n\t  (call-process shell-file-name nil buffer nil\n\t\t\t\"-c\" (concat \"ls \" dired-listing-switches \" \"\n\t\t\t\t     (file-name-nondirectory dirname)))))\n      (goto-char (point-min))\n      (while (not (eobp))\n\t(insert \"  \")\n\t(forward-line 1))\n      (goto-char (point-min)))\n    (set-buffer-modified-p nil)\n    (message \"Reading directory %s...done\" dirname)))\n\n(defun dired-find-buffer (dirname)\n  (let ((blist (buffer-list))\n\tfound)\n    (while blist\n      (save-excursion\n        (set-buffer (car blist))\n\t(if (and (eq major-mode 'dired-mode)\n\t\t (equal dired-directory dirname))\n\t    (setq found (car blist)\n\t\t  blist nil)\n\t  (setq blist (cdr blist)))))\n    (or found\n\t(create-file-buffer (directory-file-name dirname)))))\n\n(defun dired (dirname)\n  \"\\\"Edit\\\" directory DIRNAME--delete, rename, print, etc. some files in it.\nDired displays a list of files in DIRNAME.\nYou can move around in it with the usual commands.\nYou can flag files for deletion with C-d\nand then delete them by typing `x'.\nType `h' after entering dired for more info.\"\n  (interactive (list (read-file-name \"Dired (directory): \"\n\t\t\t\t     nil default-directory nil)))\n  (switch-to-buffer (dired-noselect dirname)))\n\n(defun dired-other-window (dirname)\n  \"\\\"Edit\\\" directory DIRNAME.  Like M-x dired but selects in another window.\"\n  (interactive (list (read-file-name \"Dired in other window (directory): \"\n\t\t\t\t     nil default-directory nil)))\n  (switch-to-buffer-other-window (dired-noselect dirname)))\n\n(defun dired-noselect (dirname)\n  \"Like M-x dired but returns the dired buffer as value, does not select it.\"\n  (or dirname (setq dirname default-directory))\n  (setq dirname (expand-file-name (directory-file-name dirname)))\n  (if (file-directory-p dirname)\n      (setq dirname (file-name-as-directory dirname)))\n  (let ((buffer (dired-find-buffer dirname)))\n    (save-excursion\n      (set-buffer buffer)\n      (dired-readin dirname buffer)\n      (dired-move-to-filename)\n      (dired-mode dirname))\n    buffer))\n\n(defun dired-revert (&optional arg noconfirm)\n  (let ((opoint (point))\n\t(ofile (dired-get-filename t t))\n\t(buffer-read-only nil))\n    (erase-buffer)\n    (dired-readin dired-directory (current-buffer))\n    (or (and ofile (re-search-forward (concat \" \" (regexp-quote ofile) \"$\")\n\t\t\t\t      nil t))\n\t(goto-char opoint))\n    (beginning-of-line)))\n\n(defvar dired-mode-map nil \"Local keymap for dired-mode buffers.\")\n(if dired-mode-map\n    nil\n  (setq dired-mode-map (make-keymap))\n  (suppress-keymap dired-mode-map)\n  (define-key dired-mode-map \"r\" 'dired-rename-file)\n  (define-key dired-mode-map \"\\C-d\" 'dired-flag-file-deleted)\n  (define-key dired-mode-map \"d\" 'dired-flag-file-deleted)\n  (define-key dired-mode-map \"v\" 'dired-view-file)\n  (define-key dired-mode-map \"e\" 'dired-find-file)\n  (define-key dired-mode-map \"f\" 'dired-find-file)\n  (define-key dired-mode-map \"o\" 'dired-find-file-other-window)\n  (define-key dired-mode-map \"u\" 'dired-unflag)\n  (define-key dired-mode-map \"x\" 'dired-do-deletions)\n  (define-key dired-mode-map \"\\177\" 'dired-backup-unflag)\n  (define-key dired-mode-map \"?\" 'dired-summary)\n  (define-key dired-mode-map \"c\" 'dired-copy-file)\n  (define-key dired-mode-map \"#\" 'dired-flag-auto-save-files)\n  (define-key dired-mode-map \"~\" 'dired-flag-backup-files)\n  (define-key dired-mode-map \".\" 'dired-clean-directory)\n  (define-key dired-mode-map \"h\" 'describe-mode)\n  (define-key dired-mode-map \" \"  'dired-next-line)\n  (define-key dired-mode-map \"\\C-n\" 'dired-next-line)\n  (define-key dired-mode-map \"\\C-p\" 'dired-previous-line)\n  (define-key dired-mode-map \"n\" 'dired-next-line)\n  (define-key dired-mode-map \"p\" 'dired-previous-line)\n  (define-key dired-mode-map \"g\" 'revert-buffer)\n  (define-key dired-mode-map \"C\" 'dired-compress)\n  (define-key dired-mode-map \"U\" 'dired-uncompress)\n  (define-key dired-mode-map \"B\" 'dired-byte-recompile)\n  (define-key dired-mode-map \"M\" 'dired-chmod)\n  (define-key dired-mode-map \"G\" 'dired-chgrp)\n  (define-key dired-mode-map \"O\" 'dired-chown))\n\n\n;; Dired mode is suitable only for specially formatted data.\n(put 'dired-mode 'mode-class 'special)\n\n(defun dired-mode (&optional dirname)\n  \"Mode for \\\"editing\\\" directory listings.\nIn dired, you are \\\"editing\\\" a list of the files in a directory.\nYou can move using the usual cursor motion commands.\nLetters no longer insert themselves.\nInstead, type d to flag a file for Deletion.\nType u to Unflag a file (remove its D flag).\n  Type Rubout to back up one line and unflag.\nType x to eXecute the deletions requested.\nType f to Find the current line's file\n  (or Dired it, if it is a directory).\nType o to find file or dired directory in Other window.\nType # to flag temporary files (names beginning with #) for Deletion.\nType ~ to flag backup files (names ending with ~) for Deletion.\nType . to flag numerical backups for Deletion.\n  (Spares dired-kept-versions or its numeric argument.)\nType r to rename a file.\nType c to copy a file.\nType v to view a file in View mode, returning to Dired when done.\nType g to read the directory again.  This discards all deletion-flags.\nSpace and Rubout can be used to move down and up by lines.\nAlso: C -- compress this file.  U -- uncompress this file.\n      B -- byte compile this file.\n M, G, O -- change file's mode, group or owner.\n\\\\{dired-mode-map}\"\n  (interactive)\n  (kill-all-local-variables)    \n  (make-local-variable 'revert-buffer-function)\n  (setq revert-buffer-function 'dired-revert)\n  (setq major-mode 'dired-mode)\n  (setq mode-name \"Dired\")\n  (make-local-variable 'dired-directory)\n  (setq dired-directory (or dirname default-directory))\n  (if dirname\n      (setq default-directory \n\t    (if (file-directory-p dirname)\n\t\tdirname (file-name-directory dirname))))\n  (setq mode-line-buffer-identification '(\"Dired: %17b\"))\n  (setq case-fold-search nil)\n  (setq buffer-read-only t)\n  (use-local-map dired-mode-map)\n  (run-hooks 'dired-mode-hook))\n\f\n(defun dired-repeat-over-lines (arg function)\n  (beginning-of-line)\n  (while (and (> arg 0) (not (eobp)))\n    (setq arg (1- arg))\n    (save-excursion\n      (beginning-of-line)\n      (and (bobp) (looking-at \"  total\")\n\t   (error \"No file on this line\"))\n      (funcall function))\n    (forward-line 1)\n    (dired-move-to-filename))\n  (while (and (< arg 0) (not (bobp)))\n    (setq arg (1+ arg))\n    (forward-line -1)\n    (dired-move-to-filename)\n    (save-excursion\n      (beginning-of-line)\n      (funcall function))))\n\n(defun dired-flag-file-deleted (arg)\n  \"In dired, flag the current line's file for deletion.\nWith arg, repeat over several lines.\"\n  (interactive \"p\")\n  (dired-repeat-over-lines arg\n    '(lambda ()\n       (let ((buffer-read-only nil))\n\t (delete-char 1)\n\t (insert \"D\")))))\n\n(defun dired-summary ()\n  (interactive)\n  ;>> this should check the key-bindings and use substitute-command-keys if non-standard\n  (message\n   \"d-elete, u-ndelete, x-ecute, f-ind, o-ther window, r-ename, c-opy, v-iew\"))\n\n(defun dired-unflag (arg)\n  \"In dired, remove the current line's delete flag then move to next line.\"\n  (interactive \"p\")\n  (dired-repeat-over-lines arg\n    '(lambda ()\n       (let ((buffer-read-only nil))\n\t (delete-char 1)\n\t (insert \" \")\n\t (forward-char -1)))))\n\n(defun dired-backup-unflag (arg)\n  \"In dired, move up a line and remove deletion flag there.\"\n  (interactive \"p\")\n  (dired-unflag (- arg)))\n\n(defun dired-next-line (arg)\n  \"Move down ARG lines then position at filename.\"\n  (interactive \"p\")\n  (next-line arg)\n  (dired-move-to-filename))\n\n(defun dired-previous-line (arg)\n  \"Move up ARG lines then position at filename.\"\n  (interactive \"p\")\n  (previous-line arg)\n  (dired-move-to-filename))\n\n(defun dired-find-file ()\n  \"In dired, visit the file or directory named on this line.\"\n  (interactive)\n  (find-file (dired-get-filename)))\n\n(defun dired-view-file ()\n  \"In dired, examine a file in view mode, returning to dired when done.\"\n  (interactive)\n  (if (file-directory-p (dired-get-filename))\n      (dired (dired-get-filename))\n    (view-file (dired-get-filename))))\n\t    \n(defun dired-find-file-other-window ()\n  \"In dired, visit this file or directory in another window.\"\n  (interactive)\n  (find-file-other-window (dired-get-filename)))\n\n(defun dired-get-filename (&optional localp no-error-if-not-filep)\n  \"In dired, return name of file mentioned on this line.\nValue returned normally includes the directory name.\nA non-nil 1st argument means do not include it.  A non-nil 2nd argument\nsays return nil if no filename on this line, otherwise an error occurs.\"\n  (let (eol)\n    (save-excursion\n      (end-of-line)\n      (setq eol (point))\n      (beginning-of-line)\n      (if (re-search-forward\n\t   \"\\\\(Jan\\\\|Feb\\\\|Mar\\\\|Apr\\\\|May\\\\|Jun\\\\|Jul\\\\|Aug\\\\|Sep\\\\|Oct\\\\|Nov\\\\|Dec\\\\)[ ]+[0-9]+\"\n\t   eol t)\n\t  (progn (skip-chars-forward \" \")\n\t\t (skip-chars-forward \"^ \" eol)\n\t\t (skip-chars-forward \" \" eol)\n\t\t (let ((beg (point)))\n\t\t   (skip-chars-forward \"^ \\n\")\n\t\t   (if localp\n\t\t       (buffer-substring beg (point))\n\t\t     ;; >> uses default-directory, could lose on cd, multiple.\n\t\t     (concat default-directory (buffer-substring beg (point))))))\n\t(if no-error-if-not-filep nil\n\t  (error \"No file on this line\"))))))\n\n(defun dired-move-to-filename ()\n  \"In dired, move to first char of filename on this line.\nReturns position (point) or nil if no filename on this line.\"\n  (let ((eol (progn (end-of-line) (point))))\n    (beginning-of-line)\n    (if (re-search-forward\n\t \"\\\\(Jan\\\\|Feb\\\\|Mar\\\\|Apr\\\\|May\\\\|Jun\\\\|Jul\\\\|Aug\\\\|Sep\\\\|Oct\\\\|Nov\\\\|Dec\\\\)[ ]+[0-9]+\"\n\t eol t)\n\t(progn\n\t  (skip-chars-forward \" \")\n\t  (skip-chars-forward \"^ \" eol)\n\t  (skip-chars-forward \" \" eol)\n\t  (point)))))\n\n(defun dired-map-dired-file-lines (fn)\n  \"perform fn with point at the end of each non-directory line:\narguments are the short and long filename\"\n  (save-excursion\n    (let (filename longfilename (buffer-read-only nil))\n      (goto-char (point-min))\n      (while (not (eobp))\n\t(save-excursion\n\t  (and (not (looking-at \"  d\"))\n\t       (not (eolp))\n\t       (setq filename (dired-get-filename t t)\n\t\t     longfilename (dired-get-filename nil t))\n\t       (progn (end-of-line)\n\t\t      (funcall fn filename longfilename))))\n\t(forward-line 1)))))\n\f\n(defun dired-flag-auto-save-files ()\n  \"Flag for deletion files whose names suggest they are auto save files.\"\n  (interactive)\n  (save-excursion\n   (let ((buffer-read-only nil))\n     (goto-char (point-min))\n     (while (not (eobp))\n       (and (not (looking-at \"  d\"))\n\t    (not (eolp))\n\t    (if (fboundp 'auto-save-file-name-p)\n\t\t(let ((fn (dired-get-filename t t)))\n\t\t  (if fn (auto-save-file-name-p fn)))\n\t      (if (dired-move-to-filename)\n\t\t  (looking-at \"#\")))\n\t    (progn (beginning-of-line)\n\t\t   (delete-char 1)\n\t\t   (insert \"D\")))\n       (forward-line 1)))))\n\n(defun dired-clean-directory (keep)\n  \"Flag numerical backups for Deletion.\nSpares dired-kept-versions latest versions, and kept-old-versions oldest.\nPositive numeric arg overrides dired-kept-versions;\nnegative numeric arg overrides kept-old-versions with minus the arg.\"\n  (interactive \"P\")\n  (setq keep (if keep (prefix-numeric-value keep) dired-kept-versions))\n  (let ((early-retention (if (< keep 0) (- keep) kept-old-versions))\n\t(late-retention (if (<= keep 0) dired-kept-versions keep))\n\t(file-version-assoc-list ()))\n    ;; Look at each file.\n    ;; If the file has numeric backup versions,\n    ;; put on file-version-assoc-list an element of the form\n    ;; (FILENAME . VERSION-NUMBER-LIST)\n    (dired-map-dired-file-lines 'dired-collect-file-versions)\n    ;; Sort each VERSION-NUMBER-LIST,\n    ;; and remove the versions not to be deleted.\n    (let ((fval file-version-assoc-list))\n      (while fval\n\t(let* ((sorted-v-list (cons 'q (sort (cdr (car fval)) '<)))\n\t       (v-count (length sorted-v-list)))\n\t  (if (> v-count (+ early-retention late-retention))\n\t      (rplacd (nthcdr early-retention sorted-v-list)\n\t\t      (nthcdr (- v-count late-retention)\n\t\t\t      sorted-v-list)))\n\t  (rplacd (car fval)\n\t\t  (cdr sorted-v-list)))\n\t(setq fval (cdr fval)))) \n    ;; Look at each file.  If it is a numeric backup file,\n    ;; find it in a VERSION-NUMBER-LIST and maybe flag it for deletion.\n    (dired-map-dired-file-lines 'dired-trample-file-versions)))\n\n(defun dired-collect-file-versions (ignore fn)\n  \"If it looks like fn has versions, we make a list of the versions.\nWe may want to flag some for deletion.\"\n    (let* ((base-versions\n\t    (concat (file-name-nondirectory fn) \".~\"))\n\t   (bv-length (length base-versions))\n\t   (possibilities (file-name-all-completions\n\t\t\t   base-versions\n\t\t\t   (file-name-directory fn)))\n\t   (versions (mapcar 'backup-extract-version possibilities)))\n      (if versions\n\t  (setq file-version-assoc-list (cons (cons fn versions)\n\t\t\t\t\t      file-version-assoc-list)))))\n\n(defun dired-trample-file-versions (ignore fn)\n  (let* ((start-vn (string-match \"\\\\.~[0-9]+~$\" fn))\n\t base-version-list)\n    (and start-vn\n\t (setq base-version-list\t; there was a base version to which \n\t       (assoc (substring fn 0 start-vn)\t; this looks like a \n\t\t      file-version-assoc-list))\t; subversion\n\t (not (memq (string-to-int (substring fn (+ 2 start-vn)))\n\t\t    base-version-list))\t; this one doesn't make the cut\n\t (dired-flag-this-line-for-DEATH))))\n\n(defun dired-flag-this-line-for-DEATH ()\n  (beginning-of-line)\n  (delete-char 1)\n  (insert \"D\"))\n\n(defun dired-flag-backup-files ()\n  \"Flag all backup files (names ending with ~) for deletion.\"\n  (interactive)\n  (save-excursion\n   (let ((buffer-read-only nil))\n     (goto-char (point-min))\n     (while (not (eobp))\n       (and (not (looking-at \"  d\"))\n\t    (not (eolp))\n\t    (if (fboundp 'backup-file-name-p)\n\t\t(let ((fn (dired-get-filename t t)))\n\t\t  (if fn (backup-file-name-p fn)))\n\t      (end-of-line)\n\t      (forward-char -1)\n\t      (looking-at \"~\"))\n\t    (progn (beginning-of-line)\n\t\t   (delete-char 1)\n\t\t   (insert \"D\")))\n       (forward-line 1)))))\n\n(defun dired-flag-backup-and-auto-save-files ()\n  \"Flag all backup and temporary files for deletion.\nBackup files have names ending in ~.  Auto save file names usually\nstart with #.\"\n  (interactive)\n  (dired-flag-backup-files)\n  (dired-flag-auto-save-files))\n\f\n(defun dired-rename-file (to-file)\n  \"Rename this file to TO-FILE.\"\n  (interactive\n   (list (read-file-name (format \"Rename %s to: \"\n\t\t\t\t (file-name-nondirectory (dired-get-filename)))\n\t\t\t nil (dired-get-filename))))\n  (setq to-file (expand-file-name to-file))\n  (rename-file (dired-get-filename) to-file)\n  (let ((buffer-read-only nil))\n    (beginning-of-line)\n    (delete-region (point) (progn (forward-line 1) (point)))\n    (setq to-file (expand-file-name to-file))\n    (dired-add-entry (file-name-directory to-file)\n\t\t     (file-name-nondirectory to-file))))\n\n(defun dired-copy-file (to-file)\n  \"Copy this file to TO-FILE.\"\n  (interactive \"FCopy to: \")\n  (copy-file (dired-get-filename) to-file)\n  (setq to-file (expand-file-name to-file))\n  (dired-add-entry (file-name-directory to-file)\n\t\t   (file-name-nondirectory to-file)))\n\n(defun dired-add-entry (directory filename)\n  ;; If tree dired is implemented, this function will have to do\n  ;; something smarter with the directory.  Currently, just check\n  ;; default directory, if same, add the new entry at point.  With tree\n  ;; dired, should call 'dired-current-directory' or similar.  Note\n  ;; that this adds the entry 'out of order' if files sorted by time,\n  ;; etc.\n  (if (string-equal directory default-directory)\n      (let ((buffer-read-only nil))\n\t(beginning-of-line)\n\t(call-process \"ls\" nil t nil\n\t\t      \"-d\" dired-listing-switches (concat directory filename))\n\t(forward-line -1)\n\t(insert \"  \")\n\t(dired-move-to-filename)\n\t(let* ((beg (point))\n\t       (end (progn (end-of-line) (point))))\n\t  (setq filename (buffer-substring beg end))\n\t  (delete-region beg end)\n\t  (insert (file-name-nondirectory filename)))\n\t(beginning-of-line))))\n\f\n(defun dired-compress ()\n  \"Compress this file.\"\n  (interactive)\n  (let* ((buffer-read-only nil)\n\t (error-buffer (get-buffer-create \" *Dired compress output*\"))\n\t (from-file (dired-get-filename))\n\t (to-file (concat from-file \".Z\")))\n    (if (string-match \"\\\\.Z$\" from-file)\n\t(error \"%s is already compressed!\" from-file))\n    (message \"Compressing %s...\" from-file)\n    (unwind-protect\n\t(progn\n\t  (save-excursion\n\t    (set-buffer error-buffer)\n\t    (erase-buffer))\n\t  ;; Must have default-directory of dired buffer in call-process\n\t  (call-process \"compress\" nil error-buffer nil \"-f\" from-file)\n\t  (if (save-excursion\n\t\t(set-buffer error-buffer)\n\t\t(= 0 (buffer-size)))\n\t      (progn\n\t\t(message \"Compressing %s... done\" from-file)\n\t\t(kill-buffer error-buffer))\n\t    (display-buffer error-buffer)\n\t    (setq error-buffer nil)\n\t    (error \"Compress error on %s.\" from-file)))\n      (if error-buffer (kill-buffer error-buffer)))\n    (dired-redisplay to-file)))\n\n(defun dired-uncompress ()\n  \"Uncompress this file.\"\n  (interactive)\n  (let* ((buffer-read-only nil)\n\t (error-buffer (get-buffer-create \" *Dired compress output*\"))\n\t (from-file (dired-get-filename))\n\t (to-file (substring from-file 0 -2)))\n    (if (string-match \"\\\\.Z$\" from-file) nil\n\t(error \"%s is not compressed!\" from-file))\n    (message \"Uncompressing %s...\" from-file)\n    (unwind-protect\n\t(progn\n\t  (save-excursion\n\t    (set-buffer error-buffer)\n\t    (erase-buffer))\n\t  ;; Must have default-directory of dired buffer in call-process\n\t  (call-process \"uncompress\" nil error-buffer nil \"-f\" from-file)\n\t  (if (save-excursion\n\t\t(set-buffer error-buffer)\n\t\t(= 0 (buffer-size)))\n\t      (progn\n\t\t(message \"Uncompressing %s... done\" from-file)\n\t\t(kill-buffer error-buffer))\n\t    (display-buffer error-buffer)\n\t    (setq error-buffer nil)\n\t    (error \"Uncompress error on %s.\" from-file)))\n      (if error-buffer (kill-buffer error-buffer)))\n    (dired-redisplay to-file)))\n\n(defun dired-byte-recompile ()\n  \"Byte recompile this file.\"\n  (interactive)\n  (let* ((buffer-read-only nil)\n\t (from-file (dired-get-filename))\n\t (to-file (substring from-file 0 -3)))\n    (if (string-match \"\\\\.el$\" from-file) nil\n\t(error \"%s is uncompilable!\" from-file))\n    (byte-compile-file from-file)))\n\n(defun dired-chmod (mode)\n  \"Change mode of this file.\"\n  (interactive \"sChange to Mode: \")\n  (let ((buffer-read-only nil)\n\t(file (dired-get-filename)))\n    (call-process \"/bin/chmod\" nil nil nil mode file)\n    (dired-redisplay file)))\n\n(defun dired-chgrp (group)\n  \"Change group of this file.\"\n  (interactive \"sChange to Group: \")\n  (let ((buffer-read-only nil)\n\t(file (dired-get-filename)))\n    (call-process \"/bin/chgrp\" nil nil nil group file)\n    (dired-redisplay file)))\n\n(defun dired-chown (owner)\n  \"Change Owner of this file.\"\n  (interactive \"sChange to Owner: \")\n  (let ((buffer-read-only nil)\n\t(file (dired-get-filename)))\n    (call-process (if (memq system-type '(hpux usg-unix-v silicon-graphics-unix))\n\t\t      \"/bin/chown\" \"/etc/chown\")\n\t\t  nil nil nil owner file)\n    (dired-redisplay file)))\n\n(defun dired-redisplay (file) \"Redisplay this line.\"\n  (beginning-of-line)\n  (delete-region (point) (progn (forward-line 1) (point)))\n  (if file (dired-add-entry (file-name-directory    file)\n\t\t\t    (file-name-nondirectory file)))\n  (dired-move-to-filename))\n\f\n(defun dired-do-deletions ()\n  \"In dired, delete the files flagged for deletion.\"\n  (interactive)\n  (let (delete-list answer)\n    (save-excursion\n     (goto-char 1)\n     (while (re-search-forward \"^D\" nil t)\n       (setq delete-list\n\t     (cons (cons (dired-get-filename t) (1- (point)))\n\t\t   delete-list))))\n    (if (null delete-list)\n\t(message \"(No deletions requested)\")\n      (save-window-excursion\n       (switch-to-buffer \" *Deletions*\")\n       (erase-buffer)\n       (setq fill-column 70)\n       (let ((l (reverse delete-list)))\n\t ;; Files should be in forward order for this loop.\n\t (while l\n\t   (if (> (current-column) 59)\n\t       (insert ?\\n)\n\t     (or (bobp)\n\t\t (indent-to (* (/ (+ (current-column) 19) 20) 20) 1)))\n\t   (insert (car (car l)))\n\t   (setq l (cdr l))))\n       (goto-char (point-min))\n       (setq answer (yes-or-no-p \"Delete these files? \")))\n      (if answer\n\t  (let ((l delete-list)\n\t\tfailures)\n\t    ;; Files better be in reverse order for this loop!\n\t    ;; That way as changes are made in the buffer\n\t    ;; they do not shift the lines still to be changed.\n\t    (while l\n\t      (goto-char (cdr (car l)))\n\t      (let ((buffer-read-only nil))\n\t\t(condition-case ()\n\t\t    (let ((fn (concat default-directory (car (car l)))))\n\t\t      (if (file-directory-p fn)\n\t\t\t  ;; This used to call delete-file if rmdir\n\t\t\t  ;; did not delete the file,\n\t\t\t  ;; but that made it too easy for root to spaz.\n\t\t\t  (call-process \"rmdir\" nil nil nil fn)\n\t\t\t(delete-file fn))\n\t\t      (delete-region (point)\n\t\t\t\t     (progn (forward-line 1) (point))))\n\t\t  (error (delete-char 1)\n\t\t\t (insert \" \")\n\t\t\t (setq failures (cons (car (car l)) failures)))))\n\t      (setq l (cdr l)))\n\t    (if failures\n\t\t(message \"Deletions failed: %s\"\n\t\t\t (prin1-to-string failures))))))))\n\n(provide 'dired)\n",
    "f4fbfb8095b301cccfad2191c925068c": ";; Run compiler as inferior of Emacs, and parse its error messages.\n;; Copyright (C) 1985, 1986 Free Software Foundation, Inc.\n\n;; This file is part of GNU Emacs.\n\n;; GNU Emacs is free software; you can redistribute it and/or modify\n;; it under the terms of the GNU General Public License as published by\n;; the Free Software Foundation; either version 1, or (at your option)\n;; any later version.\n\n;; GNU Emacs is distributed in the hope that it will be useful,\n;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n;; GNU General Public License for more details.\n\n;; You should have received a copy of the GNU General Public License\n;; along with GNU Emacs; see the file COPYING.  If not, write to\n;; the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n\n(provide 'compile)\n\n(defvar compilation-process nil\n  \"Process created by compile command, or nil if none exists now.\nNote that the process may have been \\\"deleted\\\" and still\nbe the value of this variable.\")\n\n(defvar compilation-error-list nil\n  \"List of error message descriptors for visiting erring functions.\nEach error descriptor is a list of length two.\nIts car is a marker pointing to an error message.\nIts cadr is a marker pointing to the text of the line the message is about,\n  or nil if that is not interesting.\nThe value may be t instead of a list;\nthis means that the buffer of error messages should be reparsed\nthe next time the list of errors is wanted.\")\n\n(defvar compilation-parsing-end nil\n  \"Position of end of buffer when last error messages parsed.\")\n\n(defvar compilation-error-message nil\n  \"Message to print when no more matches for compilation-error-regexp are found\")\n\n;; The filename excludes colons to avoid confusion when error message\n;; starts with digits.\n(defvar compilation-error-regexp\n  \"\\\\([^ :\\n]+\\\\(: *\\\\|, line \\\\|(\\\\)[0-9]+\\\\)\\\\|\\\\([0-9]+ *of *[^ \\n]+\\\\)\"\n  \"Regular expression for filename/linenumber in error in compilation log.\")\n\n(defun compile (command)\n  \"Compile the program including the current buffer.  Default: run `make'.\nRuns COMMAND, a shell command, in a separate process asynchronously\nwith output going to the buffer *compilation*.\nYou can then use the command \\\\[next-error] to find the next error message\nand move to the source code that caused it.\"\n  (interactive (list (read-string \"Compile command: \" compile-command)))\n  (setq compile-command command)\n  (compile1 compile-command \"No more errors\"))\n\n(defun grep (command)\n  \"Run grep, with user-specified args, and collect output in a buffer.\nWhile grep runs asynchronously, you can use the \\\\[next-error] command\nto find the text that grep hits refer to.\"\n  (interactive \"sRun grep (with args): \")\n  (compile1 (concat \"grep -n \" command \" /dev/null\")\n\t    \"No more grep hits\" \"grep\"))\n\n(defun compile1 (command error-message &optional name-of-mode)\n  (save-some-buffers)\n  (if compilation-process\n      (if (or (not (eq (process-status compilation-process) 'run))\n\t      (yes-or-no-p \"A compilation process is running; kill it? \"))\n\t  (condition-case ()\n\t      (if compilation-process\n\t\t  (let ((comp-proc compilation-process))\n\t\t    (interrupt-process comp-proc)\n\t\t    (sit-for 1)\n\t\t    (delete-process comp-proc)))\n\t    (error nil))\n\t(error \"Cannot have two compilation processes\")))\n  (setq compilation-process nil)\n  (compilation-forget-errors)\n  (setq compilation-error-list t)\n  (setq compilation-error-message error-message)\n  (setq compilation-process\n\t(start-process \"compilation\" \"*compilation*\"\n\t\t       shell-file-name\n\t\t       \"-c\" (concat \"exec \" command)))\n  (with-output-to-temp-buffer \"*compilation*\"\n    (princ \"cd \")\n    (princ default-directory)\n    (terpri)\n    (princ command)\n    (terpri))\n  (set-process-sentinel compilation-process 'compilation-sentinel)\n  (let* ((thisdir default-directory)\n\t (outbuf (process-buffer compilation-process))\n\t (outwin (get-buffer-window outbuf))\n\t (regexp compilation-error-regexp))\n    (if (eq outbuf (current-buffer))\n\t(goto-char (point-max)))\n    (save-excursion\n      (set-buffer outbuf)\n      (buffer-flush-undo outbuf)\n      (let ((start (save-excursion (set-buffer outbuf) (point-min))))\n\t(set-window-start outwin start)\n\t(or (eq outwin (selected-window))\n\t    (set-window-point outwin start)))\n      (setq default-directory thisdir)\n      (fundamental-mode)\n      (make-local-variable 'compilation-error-regexp)\n      (setq compilation-error-regexp regexp)\n      (setq mode-name (or name-of-mode \"Compilation\"))\n      ;; Make log buffer's mode line show process state\n      (setq mode-line-process '(\": %s\")))))\n\n;; Called when compilation process changes state.\n\n(defun compilation-sentinel (proc msg)\n  (cond ((null (buffer-name (process-buffer proc)))\n\t ;; buffer killed\n\t (set-process-buffer proc nil))\n\t((memq (process-status proc) '(signal exit))\n\t (let* ((obuf (current-buffer))\n\t\tomax opoint)\n\t   ;; save-excursion isn't the right thing if\n\t   ;;  process-buffer is current-buffer\n\t   (unwind-protect\n\t       (progn\n\t\t ;; Write something in *compilation* and hack its mode line,\n\t\t (set-buffer (process-buffer proc))\n\t\t (setq omax (point-max) opoint (point))\n\t\t (goto-char (point-max))\n\t\t (insert ?\\n mode-name \" \" msg)\n\t\t (forward-char -1)\n\t\t (insert \" at \"\n\t\t\t (substring (current-time-string) 0 -5))\n\t\t (forward-char 1)\n\t\t (setq mode-line-process\n\t\t       (concat \": \"\n\t\t\t       (symbol-name (process-status proc))))\n\t\t ;; If buffer and mode line will show that the process\n\t\t ;; is dead, we can delete it now.  Otherwise it\n\t\t ;; will stay around until M-x list-processes.\n\t\t (delete-process proc))\n\t     (setq compilation-process nil)\n\t     ;; Force mode line redisplay soon\n\t     (set-buffer-modified-p (buffer-modified-p)))\n\t   (if (and opoint (< opoint omax))\n\t       (goto-char opoint))\n\t   (set-buffer obuf)))))\n\n(defun kill-compilation ()\n  \"Kill the process made by the \\\\[compile] command.\"\n  (interactive)\n  (if compilation-process\n      (interrupt-process compilation-process)))\n\n(defun kill-grep ()\n  \"Kill the process made by the \\\\[grep] command.\"\n  (interactive)\n  (if compilation-process\n      (interrupt-process compilation-process)))\n\n(defun next-error (&optional argp)\n  \"Visit next compilation error message and corresponding source code.\nThis operates on the output from the \\\\[compile] command.\nIf all preparsed error messages have been processed,\nthe error message buffer is checked for new ones.\nA non-nil argument (prefix arg, if interactive)\nmeans reparse the error message buffer and start at the first error.\"\n  (interactive \"P\")\n  (if (or (eq compilation-error-list t)\n\t  argp)\n      (progn (compilation-forget-errors)\n\t     (setq compilation-parsing-end 1)))\n  (if compilation-error-list\n      nil\n    (save-excursion\n      (set-buffer \"*compilation*\")\n      (set-buffer-modified-p nil)\n      (compilation-parse-errors)))\n  (let ((next-error (car compilation-error-list)))\n    (if (null next-error)\n\t(error (concat compilation-error-message\n\t\t       (if (and compilation-process\n\t\t\t\t(eq (process-status compilation-process)\n\t\t\t\t    'run))\n\t\t\t   \" yet\" \"\"))))\n    (setq compilation-error-list (cdr compilation-error-list))\n    (if (null (car (cdr next-error)))\n\tnil\n      (switch-to-buffer (marker-buffer (car (cdr next-error))))\n      (goto-char (car (cdr next-error)))\n      (set-marker (car (cdr next-error)) nil))\n    (let* ((pop-up-windows t)\n\t   (w (display-buffer (marker-buffer (car next-error)))))\n      (set-window-point w (car next-error))\n      (set-window-start w (car next-error)))\n    (set-marker (car next-error) nil)))\n\n;; Set compilation-error-list to nil, and\n;; unchain the markers that point to the error messages and their text,\n;; so that they no longer slow down gap motion.\n;; This would happen anyway at the next garbage collection,\n;; but it is better to do it right away.\n(defun compilation-forget-errors ()\n  (if (eq compilation-error-list t)\n      (setq compilation-error-list nil))\n  (while compilation-error-list\n    (let ((next-error (car compilation-error-list)))\n      (set-marker (car next-error) nil)\n      (if (car (cdr next-error))\n\t  (set-marker (car (cdr next-error)) nil)))\n    (setq compilation-error-list (cdr compilation-error-list))))\n\n(defun compilation-parse-errors ()\n  \"Parse the current buffer as error messages.\nThis makes a list of error descriptors, compilation-error-list.\nFor each source-file, line-number pair in the buffer,\nthe source file is read in, and the text location is saved in compilation-error-list.\nThe function next-error, assigned to \\\\[next-error], takes the next error off the list\nand visits its location.\"\n  (setq compilation-error-list nil)\n  (message \"Parsing error messages...\")\n  (let (text-buffer\n\tlast-filename last-linenum)\n    ;; Don't reparse messages already seen at last parse.\n    (goto-char compilation-parsing-end)\n    ;; Don't parse the first two lines as error messages.\n    ;; This matters for grep.\n    (if (bobp)\n\t(forward-line 2))\n    (while (re-search-forward compilation-error-regexp nil t)\n      (let (linenum filename\n\t    error-marker text-marker)\n\t;; Extract file name and line number from error message.\n\t(save-restriction\n\t  (narrow-to-region (match-beginning 0) (match-end 0))\n\t  (goto-char (point-max))\n\t  (skip-chars-backward \"[0-9]\")\n\t  ;; If it's a lint message, use the last file(linenum) on the line.\n\t  ;; Normally we use the first on the line.\n\t  (if (= (preceding-char) ?\\()\n\t      (progn\n\t\t(narrow-to-region (point-min) (1+ (buffer-size)))\n\t\t(end-of-line)\n\t\t(re-search-backward compilation-error-regexp)\n\t\t(skip-chars-backward \"^ \\t\\n\")\n\t\t(narrow-to-region (point) (match-end 0))\n\t\t(goto-char (point-max))\n\t\t(skip-chars-backward \"[0-9]\")))\n\t  ;; Are we looking at a \"filename-first\" or \"line-number-first\" form?\n\t  (if (looking-at \"[0-9]\")\n\t      (progn\n\t\t(setq linenum (read (current-buffer)))\n\t\t(goto-char (point-min)))\n\t    ;; Line number at start, file name at end.\n\t    (progn\n\t      (goto-char (point-min))\n\t      (setq linenum (read (current-buffer)))\n\t      (goto-char (point-max))\n\t      (skip-chars-backward \"^ \\t\\n\")))\n\t  (setq filename (compilation-grab-filename)))\n\t;; Locate the erring file and line.\n\t(if (and (equal filename last-filename)\n\t\t (= linenum last-linenum))\n\t    nil\n\t  (beginning-of-line 1)\n\t  (setq error-marker (point-marker))\n\t  ;; text-buffer gets the buffer containing this error's file.\n\t  (if (not (equal filename last-filename))\n\t      (setq text-buffer\n\t\t    (and (file-exists-p (setq last-filename filename))\n\t\t\t (find-file-noselect filename))\n\t\t    last-linenum 0))\n\t  (if text-buffer\n\t      ;; Go to that buffer and find the erring line.\n\t      (save-excursion\n\t\t(set-buffer text-buffer)\n\t\t(if (zerop last-linenum)\n\t\t    (progn\n\t\t      (goto-char 1)\n\t\t      (setq last-linenum 1)))\n\t\t;; Move the right number of lines from the old position.\n\t\t;; If we can't move that many, put 0 in last-linenum\n\t\t;; so the next error message will be handled starting from\n\t\t;; scratch.\n\t\t(if (eq selective-display t)\n\t\t    (or (re-search-forward \"[\\n\\C-m]\" nil 'end\n\t\t\t\t\t   (- linenum last-linenum))\n\t\t\t(setq last-linenum 0))\n\t\t  (or (= 0 (forward-line (- linenum last-linenum)))\n\t\t      (setq last-linenum 0)))\n\t\t(setq last-linenum linenum)\n\t\t(setq text-marker (point-marker))\n\t\t(setq compilation-error-list\n\t\t      (cons (list error-marker text-marker)\n\t\t\t    compilation-error-list)))))\n\t(forward-line 1)))\n    (setq compilation-parsing-end (point-max)))\n  (message \"Parsing error messages...done\")\n  (setq compilation-error-list (nreverse compilation-error-list)))\n\n(defun compilation-grab-filename ()\n  \"Return a string which is a filename, starting at point.\nIgnore quotes and parentheses around it, as well as trailing colons.\"\n  (if (eq (following-char) ?\\\")\n      (save-restriction\n\t(narrow-to-region (point)\n\t\t\t  (progn (forward-sexp 1) (point)))\n\t(goto-char (point-min))\n\t(read (current-buffer)))\n    (buffer-substring (point)\n\t\t      (progn\n\t\t\t(skip-chars-forward \"^ :,\\n\\t(\")\n\t\t\t(point)))))\n\n(define-key ctl-x-map \"`\" 'next-error)\n",
    "defc0f3a5014407b3acca8a56a23c8b7": ";; Utility functions used both by rmail and rnews\n;; Copyright (C) 1985 Free Software Foundation, Inc.\n\n;; This file is part of GNU Emacs.\n\n;; GNU Emacs is free software; you can redistribute it and/or modify\n;; it under the terms of the GNU General Public License as published by\n;; the Free Software Foundation; either version 1, or (at your option)\n;; any later version.\n\n;; GNU Emacs is distributed in the hope that it will be useful,\n;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n;; GNU General Public License for more details.\n\n;; You should have received a copy of the GNU General Public License\n;; along with GNU Emacs; see the file COPYING.  If not, write to\n;; the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n\n\n(provide 'mail-utils)\n\t\t     \n;; should be in loaddefs\n(defvar mail-use-rfc822 nil\n  \"*If non-nil, use a full, hairy RFC822 parser on mail addresses.\nOtherwise, (the default) use a smaller, somewhat faster and\noften-correct parser.\")\n\n(defun mail-string-delete (string start end)\n  \"Returns a string containing all of STRING except the part\nfrom START (inclusive) to END (exclusive).\"\n  (if (null end) (substring string 0 start)\n    (concat (substring string 0 start)\n\t    (substring string end nil))))\n\n(defun mail-strip-quoted-names (address)\n  \"Delete comments and quoted strings in an address list ADDRESS.\nAlso delete leading/trailing whitespace and replace FOO <BAR> with just BAR.\nReturn a modified address list.\"\n  (if (null address)\n      nil\n    (if mail-use-rfc822\n\t(progn (require 'rfc822)\n\t       (mapconcat 'identity (rfc822-addresses address) \", \"))\n      (let (pos)\n       ;; Strip rfc822 comments (within parens).\n       ;; Understand properly the effect of backslashes and string quotes.\n       (let (instring (depth 0) start)\n\t (setq pos -1)\n\t (while pos\n\t   (cond ((< pos 0))\n\t\t ((= (aref address pos) ?\\\\)\n\t\t  (setq pos (1+ pos)))\n\t\t ((= (aref address pos) ?\\\")\n\t\t  (setq instring (not instring)))\n\t\t (instring nil)\n\t\t ((= (aref address pos) ?\\()\n\t\t  (if (= depth 0) (setq start pos))\n\t\t  (setq depth (1+ depth)))\n\t\t ((= (aref address pos) ?\\))\n\t\t  (setq depth (1- depth))\n\t\t  (if (= depth 0)\n\t\t      (setq address (mail-string-delete address start (1+ pos))\n\t\t\t    pos (1- start)))))\n\t   (setq pos (string-match \"[\\\"\\\\()]\" address (1+ pos)))))\n\n       ;; strip surrounding whitespace\n       (string-match \"\\\\`[ \\t\\n]*\" address)\n       (setq address (substring address\n\t\t\t\t(match-end 0)\n\t\t\t\t(string-match \"[ \\t\\n]*\\\\'\" address\n\t\t\t\t\t      (match-end 0))))\n\n       ;; Strip whitespace before commas.\n       (let (instring)\n\t (setq pos -1)\n\t (while pos\n\t   (cond ((< pos 0))\n\t\t ((= (aref address pos) ?\\\\)\n\t\t  (setq pos (1+ pos)))\n\t\t ((= (aref address pos) ?\\\")\n\t\t  (setq instring (not instring)))\n\t\t (instring nil)\n\t\t ((eq (string-match \"[ \\t]*,\" address pos) pos)\n\t\t  (setq address (mail-string-delete address pos\n\t\t\t\t\t\t    (1- (match-end 0))))))\n\t   (setq pos (string-match \"[ \\t,\\\"\\\\]\" address (1+ pos)))))\n\n       ;; strip `quoted' names (This is supposed to hack `\"Foo Bar\" <bar@host>')\n       (setq pos 0)\n       (while (setq pos (string-match\n\t\t\t  \"[ \\t]*\\\"\\\\([^\\\"\\\\]\\\\|\\\\\\\\.\\\\|\\\\\\\\\\n\\\\)*\\\"[ \\t\\n]*\"\n\t\t\t  address pos))\n\t ;; If the next thing is \"@\", we have \"foo bar\"@host.  Leave it.\n\t (if (and (> (length address) (match-end 0))\n\t\t  (= (aref address (match-end 0)) ?@))\n\t     (setq pos (match-end 0))\n\t   (setq address\n\t\t (mail-string-delete address\n\t\t\t\t     pos (match-end 0)))))\n       ;; Retain only part of address in <> delims, if there is such a thing.\n       (while (setq pos (string-match \"\\\\(,\\\\|\\\\`\\\\)[^,]*<\\\\([^>,]*>\\\\)\"\n\t\t\t\t      address))\n\t (let ((junk-beg (match-end 1))\n\t       (junk-end (match-beginning 2))\n\t       (close (match-end 0)))\n\t   (setq address (mail-string-delete address (1- close) close))\n\t   (setq address (mail-string-delete address junk-beg junk-end))))\n       address))))\n  \n(or (and (boundp 'rmail-default-dont-reply-to-names)\n\t (not (null rmail-default-dont-reply-to-names)))\n    (setq rmail-default-dont-reply-to-names \"info-\"))\n\n; rmail-dont-reply-to-names is defined in loaddefs\n(defun rmail-dont-reply-to (userids)\n  \"Returns string of mail addresses USERIDS sans any recipients\nthat start with matches for  rmail-dont-reply-to-names.\nUsenet paths ending in an element that matches are removed also.\"\n  (if (null rmail-dont-reply-to-names)\n      (setq rmail-dont-reply-to-names\n\t    (concat (if rmail-default-dont-reply-to-names\n\t\t\t(concat rmail-default-dont-reply-to-names \"\\\\|\")\n\t\t        \"\")\n\t\t    (concat (regexp-quote\n\t\t\t      (or (getenv \"USER\") (getenv \"LOGNAME\")\n\t\t\t\t  (user-login-name)))\n\t\t\t    \"\\\\>\"))))\n  (let ((match (concat \"\\\\(^\\\\|,\\\\)[ \\t\\n]*\\\\([^,\\n]*!\\\\|\\\\)\\\\(\"\n\t\t       rmail-dont-reply-to-names\n\t\t       \"\\\\)\"))\n\t(case-fold-search t)\n\tpos epos)\n    (while (setq pos (string-match match userids))\n      (if (> pos 0) (setq pos (1+ pos)))\n      (setq epos\n\t    (if (string-match \"[ \\t\\n,]+\" userids (match-end 0))\n\t\t(match-end 0)\n\t      (length userids)))\n      (setq userids\n\t    (mail-string-delete\n\t      userids pos epos)))\n    ;; get rid of any trailing commas\n    (if (setq pos (string-match \"[ ,\\t\\n]*\\\\'\" userids))\n\t(setq userids (substring userids 0 pos)))\n    ;; remove leading spaces. they bother me.\n    (if (string-match \"\\\\s *\" userids)\n\t(substring userids (match-end 0))\n      userids)))\n\f\n(defun mail-fetch-field (field-name &optional last all)\n  \"Return the value of the header field FIELD.\nThe buffer is expected to be narrowed to just the headers of the message.\nIf 2nd arg LAST is non-nil, use the last such field if there are several.\nIf 3rd arg ALL is non-nil, concatenate all such fields, with commas between.\"\n  (save-excursion\n    (goto-char (point-min))\n    (let ((case-fold-search t)\n\t  (name (concat \"^\" (regexp-quote field-name) \"[ \\t]*:[ \\t]*\")))\n      (goto-char (point-min))\n      (if all\n\t  (let ((value \"\"))\n\t    (while (re-search-forward name nil t)\n\t      (let ((opoint (point)))\n\t\t(while (progn (forward-line 1)\n\t\t\t      (looking-at \"[ \\t]\")))\n\t\t(setq value (concat value\n\t\t\t\t    (if (string= value \"\") \"\" \", \")\n\t\t\t\t    (buffer-substring opoint (1- (point)))))))\n\t    (and (not (string= value \"\")) value))\n\t(if (re-search-forward name nil t)\n\t    (progn\n\t      (if last (while (re-search-forward name nil t)))\n\t      (let ((opoint (point)))\n\t\t(while (progn (forward-line 1)\n\t\t\t      (looking-at \"[ \\t]\")))\n\t\t(buffer-substring opoint (1- (point))))))))))\n\f\n;; Parse a list of tokens separated by commas.\n;; It runs from point to the end of the visible part of the buffer.\n;; Whitespace before or after tokens is ignored,\n;; but whitespace within tokens is kept.\n(defun mail-parse-comma-list ()\n  (let (accumulated\n\tbeg)\n    (skip-chars-forward \" \")\n    (while (not (eobp))\n      (setq beg (point))\n      (skip-chars-forward \"^,\")\n      (skip-chars-backward \" \")\n      (setq accumulated\n\t    (cons (buffer-substring beg (point))\n\t\t  accumulated))\n      (skip-chars-forward \"^,\")\n      (skip-chars-forward \", \"))\n    accumulated))\n\n(defun mail-comma-list-regexp (labels)\n  (let (pos)\n    (setq pos (or (string-match \"[^ \\t]\" labels) 0))\n    ;; Remove leading and trailing whitespace.\n    (setq labels (substring labels pos (string-match \"[ \\t]*$\" labels pos)))\n    ;; Change each comma to \\|, and flush surrounding whitespace.\n    (while (setq pos (string-match \"[ \\t]*,[ \\t]*\" labels))\n      (setq labels\n\t    (concat (substring labels 0 pos)\n\t\t    \"\\\\|\"\n\t\t    (substring labels (match-end 0))))))\n  labels)\n",
    "ede625fcabadc27dfbf5e7698870a3a4": ";; Psychological help for frustrated users.\n;; Copyright (C) 1985, 1987 Free Software Foundation, Inc.\n\n;; This file is part of GNU Emacs.\n\n;; GNU Emacs is free software; you can redistribute it and/or modify\n;; it under the terms of the GNU General Public License as published by\n;; the Free Software Foundation; either version 1, or (at your option)\n;; any later version.\n\n;; GNU Emacs is distributed in the hope that it will be useful,\n;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n;; GNU General Public License for more details.\n\n;; You should have received a copy of the GNU General Public License\n;; along with GNU Emacs; see the file COPYING.  If not, write to\n;; the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n\n\n(defun doctor-cadr (x) (car (cdr x)))\n(defun doctor-caddr (x) (car (cdr (cdr x))))\n(defun doctor-cddr (x) (cdr (cdr x)))\n\n(defun doctor-member (x y)\n  \"Like memq, but uses  equal  for comparison\"\n  (while (and y (not (equal x (car y))))\n    (setq y (cdr y)))\n  y)\n\n(defun random-range (top)\n  \"Return a random nonnegative integer less than TOP.\"\n  (let ((tem (% (random) top)))\n    (if (< tem 0) (- tem) tem)))\n\n(defun // (x) x)\n\n(defmacro $ (what)\n  \"quoted arg form of doctor-$\"\n  (list 'doctor-$ (list 'quote what)))\n\n(defun doctor-$ (what)\n  \"Return the car of a list, rotating the list each time\"\n  (let* ((vv (symbol-value what))\n\t(first (car vv))\n\t(ww (append (cdr vv) (list first))))\n    (set what ww)\n    first))\n\f\n(defvar doctor-mode-map nil)\n(if doctor-mode-map\n    nil\n  (setq doctor-mode-map (make-sparse-keymap))\n  (define-key doctor-mode-map \"\\n\" 'doctor-read-print)\n  (define-key doctor-mode-map \"\\r\" 'doctor-ret-or-read))\n\n(defun doctor-mode ()\n  \"Major mode for running the Doctor (Eliza) program.\nLike Text mode with Auto Fill mode\nexcept that RET when point is after a newline, or LFD at any time,\nreads the sentence before point, and prints the Doctor's answer.\"\n  (interactive)\n  (text-mode)\n  (make-doctor-variables)\n  (use-local-map doctor-mode-map)\n  (setq major-mode 'doctor-mode)\n  (setq mode-name \"Doctor\")\n  (turn-on-auto-fill)\n  (doctor-type '(i am the psychotherapist \\.\n\t\t ($ please) ($ describe) your ($ problems) \\.\n\t\t each time you are finished talking, type \\R\\E\\T twice \\.))\n  (insert \"\\n\"))\n\n(defun make-doctor-variables ()\n  (make-local-variable 'monosyllables)\n  (setq monosyllables\n\t\"\n     Your attitude at the end of the session was wholly unacceptable.\n     Please try to come back next time with a willingness to speak more\n     freely. If you continue to refuse to talk openly, there is little\n     I can do to help!\n\")\n  (make-local-variable 'typos)\n  (setq typos\n\t(mapcar (function (lambda (x)\n\t\t\t    (put (car x) 'doctor-correction  (doctor-cadr x))\n\t\t\t    (put (doctor-cadr x) 'doctor-expansion (doctor-caddr x))\n\t\t\t    (car x)))\n\t\t'((theyll they\\'ll (they will))\n\t\t  (theyre they\\'re (they are))\n\t\t  (hes he\\'s (he is))\n\t\t  (he7s he\\'s (he is))\n\t\t  (im i\\'m (you are))\n\t\t  (i7m i\\'m (you are))\n\t\t  (isa is\\ a (is a))\n\t\t  (thier their (their))\n\t\t  (dont don\\'t (do not))\n\t\t  (don7t don\\'t (do not))\n\t\t  (you7re you\\'re (i am))\n\t\t  (you7ve you\\'ve (i have))\n\t\t  (you7ll you\\'ll (i will)))))\n  (make-local-variable 'found)\n  (setq found nil)\n  (make-local-variable 'owner)\n  (setq owner nil)\n  (make-local-variable 'history)\n  (setq history nil)\n  (make-local-variable '*debug*)\n  (setq *debug* nil)\n  (make-local-variable 'inter)\n  (setq inter\n\t'((well\\,)\n\t  (hmmm \\.\\.\\.\\ so\\,)\n\t  (so)\n\t  (\\.\\.\\.and)\n\t  (then)))\n  (make-local-variable 'continue)\n  (setq continue\n\t'((continue)\n\t  (proceed)\n\t  (go on)\n\t  (keep going) ))\n  (make-local-variable 'relation)\n  (setq relation\n\t'((your relationship with)\n\t  (something you remember about)\n\t  (your feelings toward)\n\t  (some experiences you have had with)\n\t  (how you feel about)))\n  (make-local-variable 'fears)\n  (setq fears '( (($ whysay) you are ($ afraidof) (// feared) \\?)\n\t\t (you seem terrified by (// feared) \\.)\n\t\t (when did you first feel ($ afraidof) (// feared) \\?) ))\n  (make-local-variable 'sure)\n  (setq sure '((sure)(positive)(certain)(absolutely sure)))\n  (make-local-variable 'afraidof)\n  (setq afraidof '( (afraid of) (frightened by) (scared of) ))\n  (make-local-variable 'areyou)\n  (setq areyou '( (are you)(have you been)(have you been) ))\n  (make-local-variable 'isrelated)\n  (setq isrelated '( (has something to do with)(is related to)\n\t\t     (could be the reason for) (is caused by)(is because of)))\n  (make-local-variable 'arerelated)\n  (setq arerelated '((have something to do with)(are related to)\n\t\t     (could have caused)(could be the reason for) (are caused by)\n\t\t     (are because of)))\n  (make-local-variable 'moods)\n  (setq moods '( (($ areyou)(// found) often \\?)\n\t\t (what causes you to be (// found) \\?)\n\t\t (($ whysay) you are (// found) \\?) ))\n  (make-local-variable 'maybe)\n  (setq maybe\n\t'((maybe)\n\t  (perhaps)\n\t  (possibly)))\n  (make-local-variable 'whatwhen)\n  (setq whatwhen\n\t'((what happened when)\n\t  (what would happen if)))\n  (make-local-variable 'hello)\n  (setq hello\n\t'((how do you do \\?) (hello \\.) (howdy!) (hello \\.) (hi \\.) (hi there \\.)))\n  (make-local-variable 'drnk)\n  (setq drnk\n\t'((do you drink a lot of (// found) \\?)\n\t  (do you get drunk often \\?)\n\t  (($ describe) your drinking habits \\.) )) \n  (make-local-variable 'drugs)\n  (setq drugs '( (do you use (// found) often \\?)(($ areyou)\n\t\t\t\t\t\t addicted to (// found) \\?)(do you realize that drugs can\n\t\t\t\t\t\t be very harmful \\?)(($ maybe) you should try to quit using (// found)\n\t\t\t\t\t\t \\.)))\n  (make-local-variable 'whywant)\n  (setq whywant '( (($ whysay) (// subj) might ($ want) (// obj) \\?)\n\t\t   (how does it feel to want \\?)\n\t\t   (why should (// subj) get (// obj) \\?)\n\t\t   (when did (// subj) first ($ want) (// obj) \\?)\n\t\t   (($ areyou) obsessed with (// obj) \\?)\n\t\t   (why should i give (// obj) to (// subj) \\?)\n\t\t   (have you ever gotten (// obj) \\?) ))\n  (make-local-variable 'canyou)\n  (setq canyou '((of course i can \\.)\n\t\t (why should i \\?)\n\t\t (what makes you think i would even want to \\?)\n\t\t (i am the doctor\\, i can do anything i damn please \\.)\n\t\t (not really\\, it\\'s not up to me \\.)\n\t\t (depends\\, how important is it \\?)\n\t\t (i could\\, but i don\\'t think it would be a wise thing to do \\.)\n\t\t (can you \\?)\n\t\t (maybe i can\\, maybe i can\\'t \\.\\.\\.)\n\t\t (i don\\'t think i should do that \\.)))\n  (make-local-variable 'want)\n  (setq want '( (want) (desire) (wish) (want) (hope) ))\n  (make-local-variable 'shortlst)\n  (setq shortlst\n\t'((can you elaborate on that \\?)\n\t  (($ please) continue \\.)\n\t  (go on\\, don\\'t be afraid \\.)\n\t  (i need a little more detail please \\.)\n\t  (you\\'re being a bit brief\\, ($ please) go into detail \\.)\n\t  (can you be more explicit \\?)\n\t  (and \\?)\n\t  (($ please) go into more detail \\?)\n\t  (you aren\\'t being very talkative today\\!)\n\t  (is that all there is to it \\?)\n\t  (why must you respond so briefly \\?)))\n\n  (make-local-variable 'famlst)\n  (setq famlst\n\t'((tell me ($ something) about (// owner) family \\.)\n\t  (you seem to dwell on (// owner) family \\.)\n\t  (($ areyou) hung up on (// owner) family \\?)))\n  (make-local-variable 'huhlst)\n  (setq huhlst\n\t'((($ whysay)(// sent) \\?)\n\t  (is it because of ($ things) that you say (// sent) \\?) ))\n  (make-local-variable 'longhuhlst)\n  (setq longhuhlst\n\t'((($ whysay) that \\?)\n\t  (i don\\'t understand \\.)\n\t  (($ thlst))\n\t  (($ areyou) ($ afraidof) that \\?)))\n  (make-local-variable 'feelings)\n  (setq feelings-about\n\t'((feelings about)\n\t  (aprehensions toward)\n\t  (thoughts on)\n\t  (emotions toward)))\n  (make-local-variable 'random)\n  (setq random-adjective\n\t'((vivid)\n\t  (emotionally stimulating)\n\t  (exciting)\n\t  (boring)\n\t  (interesting)\n\t  (recent)\n\t  (random)   ;How can we omit this?\n\t  (unusual)\n\t  (shocking)\n\t  (embarrassing)))\n  (make-local-variable 'whysay)\n  (setq whysay\n\t'((why do you say)\n\t  (what makes you believe)\n\t  (are you sure that)\n\t  (do you really think)\n\t  (what makes you think) ))\n  (make-local-variable 'isee)\n  (setq isee\n\t'((i see \\.\\.\\.)\n\t  (yes\\,)\n\t  (i understand \\.)\n\t  (oh \\.) ))\n  (make-local-variable 'please)\n  (setq please \n\t'((please\\,)\n\t  (i would appreciate it if you would)\n\t  (perhaps you could)\n\t  (please\\,)\n\t  (would you please)\n\t  (why don\\'t you)\n\t  (could you)))\n  (make-local-variable 'bye)\n  (setq bye\n\t'((my secretary will send you a bill \\.)\n\t  (bye bye \\.)\n\t  (see ya \\.)\n\t  (ok\\, talk to you some other time \\.)\n\t  (talk to you later \\.)\n\t  (ok\\, have fun \\.)\n\t  (ciao \\.)))\n  (make-local-variable 'something)\n  (setq something\n\t'((something)\n\t  (more)\n\t  (how you feel)))\n  (make-local-variable 'things)\n  (setq things \n\t'(;(your interests in computers)   ;; let's make this less computer oriented\n\t  ;(the machines you use)\n\t  (your plans)\n\t  ;(your use of computers)\n\t  (your life)\n\t  ;(other machines you use)\n\t  (the people you hang around with)\n\t  ;(computers you like)\n\t  (problems at school)\n\t  (any hobbies you have)\n\t  ;(other computers you use)\n\t  (your sex life)\n\t  (hangups you have)\n\t  (your inhibitions)\n\t  (some problems in your childhood)\n\t  ;(knowledge of computers)\n\t  (some problems at home)))\n  (make-local-variable 'describe)\n  (setq describe\n\t'((describe)\n\t  (tell me about)\n\t  (talk about)\n\t  (discuss)\n\t  (tell me more about)\n\t  (elaborate on)))\n  (make-local-variable 'ibelieve)\n  (setq ibelieve \n\t'((i believe) (i think) (i have a feeling) (it seems to me that)\n\t  (it looks like)))\n  (make-local-variable 'problems)\n  (setq problems '( (problems)\n\t\t    (inhibitions)\n\t\t    (hangups)\n\t\t    (difficulties)\n\t\t    (anxieties)\n\t\t    (frustrations) ))\n  (make-local-variable 'bother)\n  (setq bother\n\t'((does it bother you that)\n\t  (are you annoyed that)\n\t  (did you ever regret)\n\t  (are you sorry)\n\t  (are you satisfied with the fact that)))\n  (make-local-variable 'machlst)\n  (setq machlst \n\t'((you have your mind on (// found) \\, it seems \\.)\n\t  (you think too much about  (// found) \\.)\n\t  (you should try taking your mind off of (// found)\\.)\n\t  (are you a computer hacker \\?)))\n  (make-local-variable 'qlist)\n  (setq qlist\n\t'((what do you think \\?)\n\t  (i\\'ll ask the questions\\, if you don\\'t mind!)\n\t  (i could ask the same thing myself \\.)\n\t  (($ please) allow me to do the questioning \\.)\n\t  (i have asked myself that question many times \\.)\n\t  (($ please) try to answer that question yourself \\.)))\n  (make-local-variable 'elist)\n  (setq elist\n\t'((($ please) try to calm yourself \\.)\n\t  (you seem very excited \\. relax \\. ($ please) ($ describe) ($ things)\n\t       \\.)\n\t  (you\\'re being very emotional \\. calm down \\.)))\n  (make-local-variable 'foullst)\n  (setq foullst\n\t'((($ please) watch your tongue!)\n\t  (($ please) avoid such unwholesome thoughts \\.)\n\t  (($ please) get your mind out of the gutter \\.)\n\t  (such lewdness is not appreciated \\.)))\n  (make-local-variable 'deathlst)\n  (setq deathlst\n\t'((this is not a healthy way of thinking \\.)\n\t  (($ bother) you\\, too\\, may die someday \\?)\n\t  (i am worried by your obssession with this topic!)\n\t  (did you watch a lot of crime and violence on television as a child \\?))\n\t)\n  (make-local-variable 'sexlst)\n  (setq sexlst \n\t'((($ areyou) ($ afraidof) sex \\?)\n\t  (($ describe)($ something) about your sexual history \\.)\n\t  (($ please)($ describe) your sex life \\.\\.\\.)\n\t  (($ describe) your ($ feelings-about) your sexual partner \\.)\n\t  (($ describe) your most ($ random-adjective) sexual experience \\.)\n\t  (($ areyou) satisfied with (// lover) \\.\\.\\. \\?)))\n  (make-local-variable 'neglst)\n  (setq neglst\n\t'((why not \\?)\n\t  (($ bother) i ask that \\?)\n\t  (why not \\?)\n\t  (why not \\?)\n\t  (how come \\?)\n\t  (($ bother) i ask that \\?)))\n  (make-local-variable 'beclst)\n  (setq beclst '(\n\t\t (is it because (// sent) that you came to me \\?)\n\t\t (($ bother)(// sent) \\?)\n\t\t (when did you first know that (// sent) \\?)\n\t\t (is the fact that (// sent) the real reason \\?)\n\t\t (does the fact that (// sent) explain anything else \\?)\n\t\t (($ areyou)($ sure)(// sent) \\? ) ))\n  (make-local-variable 'shortbeclst)\n  (setq shortbeclst '(\n\t\t      (($ bother) i ask you that \\?)\n\t\t      (that\\'s not much of an answer!)\n\t\t      (($ inter) why won\\'t you talk about it \\?)\n\t\t      (speak up!)\n\t\t      (($ areyou) ($ afraidof) talking about it \\?)\n\t\t      (don\\'t be ($ afraidof) elaborating \\.)\n\t\t      (($ please) go into more detail \\.)))\n  (make-local-variable 'thlst)\n  (setq thlst '(\n\t\t(($ maybe)($ things)($ arerelated) this \\.)\n\t\t(is it because of ($ things) that you are going through all this \\?)\n\t\t(how do you reconcile ($ things) \\? )\n\t\t(($ maybe) this ($ isrelated)($ things) \\?) ))\n  (make-local-variable 'remlst)\n  (setq remlst '( (earlier you said ($ history) \\?)\n\t\t  (you mentioned that ($ history) \\?)\n\t\t  (($ whysay)($ history) \\? ) ))\n  (make-local-variable 'toklst)\n  (setq toklst\n\t'((is this how you relax \\?)\n\t  (how long have you been smoking\tgrass \\?)\n\t  (($ areyou) ($ afraidof) of being drawn to using harder stuff \\?)))\n  (make-local-variable 'states)\n  (setq states\n\t'((do you get (// found) often \\?)\n\t  (do you enjoy being (// found) \\?)\n\t  (what makes you (// found) \\?)\n\t  (how often ($ areyou)(// found) \\?)\n\t  (when were you last (// found) \\?)))\n  (make-local-variable 'replist)\n  (setq replist \n\t'((i . (you))\n\t  (my . (your))\n\t  (me . (you))\n\t  (you . (me))\n\t  (your . (my))\n\t  (mine . (yours))\n\t  (yours . (mine))\n\t  (our . (your))\n\t  (ours . (yours))\n\t  (we . (you))\n\t  (dunno . (do not know))\n;;\t  (yes . ())\n\t  (no\\, . ())\n\t  (yes\\, . ())\n\t  (ya . (i))\n\t  (aint . (am not))\n\t  (wanna . (want to))\n\t  (gimme . (give me))\n\t  (gotta . (have to))\n\t  (gonna . (going to))\n\t  (never . (not ever))\n\t  (doesn\\'t . (does not))\n\t  (don\\'t . (do not))\n\t  (aren\\'t . (are not))\n\t  (isn\\'t . (is not))\n\t  (won\\'t . (will not))\n\t  (can\\'t . (cannot))\n\t  (haven\\'t . (have not))\n\t  (i\\'m . (you are))\n\t  (ourselves . (yourselves))\n\t  (myself . (yourself))\n\t  (yourself . (myself))\n\t  (you\\'re . (i am))\n\t  (you\\'ve . (i have))\n\t  (i\\'ve . (you have))\n\t  (i\\'ll . (you will))\n\t  (you\\'ll . (i shall))\n\t  (i\\'d . (you would))\n\t  (you\\'d . (i would))\n\t  (here . (there))\n\t  (please . ())\n\t  (eh\\, . ())\n\t  (eh . ())\n\t  (oh\\, . ())\n\t  (oh . ())\n\t  (shouldn\\'t . (should not))\n\t  (wouldn\\'t . (would not))\n\t  (won\\'t . (will not))\n\t  (hasn\\'t . (has not))))\n  (make-local-variable 'stallmanlst)\n  (setq stallmanlst '(\n\t\t      (($ describe) your ($ feelings-about) him \\.)\n\t\t      (($ areyou) a friend of Stallman \\?)\n\t\t      (($ bother) Stallman is ($ random-adjective) \\?)\n\t\t      (($ ibelieve) you are ($ afraidof) him \\.)))\n  (make-local-variable 'schoollst)\n  (setq schoollst '(\n\t\t    (($ describe) your (// found) \\.)\n\t\t    (($ bother) your grades could ($ improve) \\?)\n\t\t    (($ areyou) ($ afraidof) (// found) \\?)\n\t\t    (($ maybe) this ($ isrelated) to your attitude \\.)\n\t\t    (($ areyou) absent often \\?)\n\t\t    (($ maybe) you should study ($ something) \\.)))\n  (make-local-variable 'improve)\n  (setq improve '((improve) (be better) (be improved) (be higher)))\n  (make-local-variable 'elizalst)\n  (setq elizalst '(\n\t\t   (($ areyou) ($ sure) \\?)\n\t\t   (($ ibelieve) you have ($ problems) with (// found) \\.)\n\t\t   (($ whysay) (// sent) \\?)))\n  (make-local-variable 'sportslst)\n  (setq sportslst '(\n\t\t    (tell me ($ something) about (// found) \\.)\n\t\t    (($ describe) ($ relation) (// found) \\.)\n\t\t    (do you find (// found) ($ random-adjective) \\?)))\n  (make-local-variable 'mathlst)\n  (setq mathlst '(\n\t\t  (($ describe) ($ something) about math \\.)\n\t\t  (($ maybe) your ($ problems) ($ arerelated) (// found) \\.)\n\t\t  (i do\\'nt know much (// found) \\, but ($ continue)\n\t\t     anyway \\.)))\n  (make-local-variable 'zippylst)\n  (setq zippylst '(\n\t\t   (($ areyou) Zippy \\?)\n\t\t   (($ ibelieve) you have some serious ($ problems) \\.)\n\t\t   (($ bother) you are a pinhead \\?)))\n  (make-local-variable 'chatlst)\n  (setq chatlst '(\n\t\t  (($ maybe) we could chat \\.)\n\t\t  (($ please) ($ describe) ($ something) about chat mode \\.)\n\t\t  (($ bother) our discussion is so ($ random-adjective) \\?)))\n  (make-local-variable 'abuselst)\n  (setq abuselst '(\n\t\t   (($ please) try to be less abusive \\.)\n\t\t   (($ describe) why you call me (// found) \\.)\n\t\t   (i\\'ve had enough of you!)))\n  (make-local-variable 'abusewords)\n  (setq abusewords '(boring bozo clown clumsy cretin dumb dummy\n\t\t\t    fool foolish gnerd gnurd idiot jerk\n\t\t\t    lose loser louse lousy luse luser\n\t\t\t    moron nerd nurd oaf oafish reek\n\t\t\t    stink stupid tool toolish twit))\n  (make-local-variable 'howareyoulst)\n  (setq howareyoulst  '((how are you) (hows it going) (hows it going eh)\n\t\t\t(how\\'s it going) (how\\'s it going eh) (how goes it)\n\t\t\t(whats up) (whats new) (what\\'s up) (what\\'s new)\n\t\t\t(howre you) (how\\'re you) (how\\'s everything)\n\t\t\t(how is everything) (how do you do)\n\t\t\t(how\\'s it hanging) (que pasa)\n\t\t\t(how are you doing) (what do you say)))\n  (make-local-variable 'whereoutp)\n  (setq whereoutp '( huh remem rthing ) )\n  (make-local-variable 'subj)\n  (setq subj nil)\n  (make-local-variable 'verb)\n  (setq verb nil)\n  (make-local-variable 'obj)\n  (setq obj nil)\n  (make-local-variable 'feared)\n  (setq feared nil)\n  (make-local-variable 'observation-list)\n  (setq observation-list nil)\n  (make-local-variable 'repetitive-shortness)\n  (setq repetitive-shortness '(0 . 0))\n  (make-local-variable '**mad**)\n  (setq **mad** nil)\n  (make-local-variable 'rms-flag)\n  (setq rms-flag nil)\n  (make-local-variable 'eliza-flag)\n  (setq eliza-flag nil)\n  (make-local-variable 'zippy-flag)\n  (setq zippy-flag nil)\n  (make-local-variable 'lover)\n  (setq lover '(your partner))\n  (make-local-variable 'bak)\n  (setq bak nil)\n  (make-local-variable 'lincount)\n  (setq lincount 0)\n  (make-local-variable '*print-upcase*)\n  (setq *print-upcase* nil)\n  (make-local-variable '*print-space*)\n  (setq *print-space* nil)\n  (make-local-variable 'howdyflag)\n  (setq howdyflag nil)\n  (make-local-variable 'object)\n  (setq object nil))\n\f\n;; Define equivalence classes of words that get treated alike.\n\n(defun doctor-meaning (x) (get x 'doctor-meaning))\n\n(defmacro doctor-put-meaning (symb val)\n    \"Store the base meaning of a word on the property list\"\n    (list 'put (list 'quote symb) ''doctor-meaning val))\n\n(doctor-put-meaning howdy 'howdy)\n(doctor-put-meaning hi 'howdy)\n(doctor-put-meaning greetings 'howdy)\n(doctor-put-meaning hello 'howdy)\n(doctor-put-meaning tops20 'mach)\n(doctor-put-meaning tops-20 'mach)\n(doctor-put-meaning tops 'mach)\n(doctor-put-meaning pdp11 'mach)\n(doctor-put-meaning computer 'mach)\n(doctor-put-meaning unix 'mach)\n(doctor-put-meaning machine 'mach)\n(doctor-put-meaning computers 'mach)\n(doctor-put-meaning machines 'mach)\n(doctor-put-meaning pdp11s 'mach)\n(doctor-put-meaning foo 'mach)\n(doctor-put-meaning foobar 'mach)\n(doctor-put-meaning multics 'mach)\n(doctor-put-meaning macsyma 'mach)\n(doctor-put-meaning teletype 'mach)\n(doctor-put-meaning la36 'mach)\n(doctor-put-meaning vt52 'mach)\n(doctor-put-meaning zork 'mach)\n(doctor-put-meaning trek 'mach)\n(doctor-put-meaning startrek 'mach)\n(doctor-put-meaning advent 'mach)\n(doctor-put-meaning pdp 'mach)\n(doctor-put-meaning dec 'mach)\n(doctor-put-meaning commodore 'mach)\n(doctor-put-meaning vic 'mach)\n(doctor-put-meaning bbs 'mach)\n(doctor-put-meaning modem 'mach)\n(doctor-put-meaning baud 'mach)\n(doctor-put-meaning macintosh 'mach)\n(doctor-put-meaning vax 'mach)\n(doctor-put-meaning vms 'mach)\n(doctor-put-meaning ibm 'mach)\n(doctor-put-meaning pc 'mach)\n(doctor-put-meaning bitching 'foul)\n(doctor-put-meaning shit 'foul)\n(doctor-put-meaning bastard 'foul)\n(doctor-put-meaning damn 'foul)\n(doctor-put-meaning damned 'foul)\n(doctor-put-meaning hell 'foul)\n(doctor-put-meaning suck 'foul)\n(doctor-put-meaning sucking 'foul)\n(doctor-put-meaning sux 'foul)\n(doctor-put-meaning ass 'foul)\n(doctor-put-meaning whore 'foul)\n(doctor-put-meaning bitch 'foul)\n(doctor-put-meaning asshole 'foul)\n(doctor-put-meaning shrink 'foul)\n(doctor-put-meaning pot 'toke)\n(doctor-put-meaning grass 'toke)\n(doctor-put-meaning weed 'toke)\n(doctor-put-meaning marijuana 'toke)\n(doctor-put-meaning acapulco 'toke)\n(doctor-put-meaning columbian 'toke)\n(doctor-put-meaning tokin 'toke)\n(doctor-put-meaning joint 'toke)\n(doctor-put-meaning toke 'toke)\n(doctor-put-meaning toking 'toke)\n(doctor-put-meaning tokin\\' 'toke)\n(doctor-put-meaning toked 'toke)\n(doctor-put-meaning roach 'toke)\n(doctor-put-meaning pills 'drug)\n(doctor-put-meaning dope 'drug)\n(doctor-put-meaning acid 'drug)\n(doctor-put-meaning lsd 'drug)\n(doctor-put-meaning speed 'drug)\n(doctor-put-meaning heroin 'drug)\n(doctor-put-meaning hash 'drug)\n(doctor-put-meaning cocaine 'drug)\n(doctor-put-meaning uppers 'drug)\n(doctor-put-meaning downers 'drug)\n(doctor-put-meaning loves 'loves)\n(doctor-put-meaning love 'love)\n(doctor-put-meaning loved 'love)\n(doctor-put-meaning hates 'hates)\n(doctor-put-meaning dislikes 'hates)\n(doctor-put-meaning hate 'hate)\n(doctor-put-meaning hated 'hate)\n(doctor-put-meaning dislike 'hate)\n(doctor-put-meaning stoned 'state)\n(doctor-put-meaning drunk 'state)\n(doctor-put-meaning drunken 'state)\n(doctor-put-meaning high 'state)\n(doctor-put-meaning horny 'state)\n(doctor-put-meaning blasted 'state)\n(doctor-put-meaning happy 'state)\n(doctor-put-meaning paranoid 'state)\n(doctor-put-meaning wish 'desire)\n(doctor-put-meaning wishes 'desire)\n(doctor-put-meaning want 'desire)\n(doctor-put-meaning desire 'desire)\n(doctor-put-meaning like 'desire)\n(doctor-put-meaning hope 'desire)\n(doctor-put-meaning hopes 'desire)\n(doctor-put-meaning desires 'desire)\n(doctor-put-meaning wants 'desire)\n(doctor-put-meaning desires 'desire)\n(doctor-put-meaning likes 'desire)\n(doctor-put-meaning needs 'desire)\n(doctor-put-meaning need 'desire)\n(doctor-put-meaning frustrated 'mood)\n(doctor-put-meaning depressed 'mood)\n(doctor-put-meaning annoyed 'mood)\n(doctor-put-meaning upset 'mood)\n(doctor-put-meaning unhappy 'mood)\n(doctor-put-meaning excited 'mood)\n(doctor-put-meaning worried 'mood)\n(doctor-put-meaning lonely 'mood)\n(doctor-put-meaning angry 'mood)\n(doctor-put-meaning mad 'mood)\n(doctor-put-meaning pissed 'mood)\n(doctor-put-meaning jealous 'mood)\n(doctor-put-meaning afraid 'fear)\n(doctor-put-meaning terrified 'fear)\n(doctor-put-meaning fear 'fear)\n(doctor-put-meaning scared 'fear)\n(doctor-put-meaning frightened 'fear)\n(doctor-put-meaning virginity 'sexnoun)\n(doctor-put-meaning virgins 'sexnoun)\n(doctor-put-meaning virgin 'sexnoun)\n(doctor-put-meaning cock 'sexnoun)\n(doctor-put-meaning cocks 'sexnoun)\n(doctor-put-meaning dick 'sexnoun)\n(doctor-put-meaning dicks 'sexnoun)\n(doctor-put-meaning cunt 'sexnoun)\n(doctor-put-meaning cunts 'sexnoun)\n(doctor-put-meaning prostitute 'sexnoun)\n(doctor-put-meaning condom 'sexnoun)\n(doctor-put-meaning sex 'sexnoun)\n(doctor-put-meaning rapes 'sexnoun)\n(doctor-put-meaning wife 'family)\n(doctor-put-meaning family 'family)\n(doctor-put-meaning brothers 'family)\n(doctor-put-meaning sisters 'family)\n(doctor-put-meaning parent 'family)\n(doctor-put-meaning parents 'family)\n(doctor-put-meaning brother 'family)\n(doctor-put-meaning sister 'family)\n(doctor-put-meaning father 'family)\n(doctor-put-meaning mother 'family)\n(doctor-put-meaning husband 'family)\n(doctor-put-meaning siblings 'family)\n(doctor-put-meaning grandmother 'family)\n(doctor-put-meaning grandfather 'family)\n(doctor-put-meaning maternal 'family)\n(doctor-put-meaning paternal 'family)\n(doctor-put-meaning stab 'death)\n(doctor-put-meaning murder 'death)\n(doctor-put-meaning murders 'death)\n(doctor-put-meaning suicide 'death)\n(doctor-put-meaning suicides 'death)\n(doctor-put-meaning kill 'death)\n(doctor-put-meaning kills 'death)\n(doctor-put-meaning die 'death)\n(doctor-put-meaning dies 'death)\n(doctor-put-meaning died 'death)\n(doctor-put-meaning dead 'death)\n(doctor-put-meaning death 'death)\n(doctor-put-meaning deaths 'death)\n(doctor-put-meaning pain 'symptoms)\n(doctor-put-meaning ache 'symptoms)\n(doctor-put-meaning fever 'symptoms)\n(doctor-put-meaning sore 'symptoms)\n(doctor-put-meaning aching 'symptoms)\n(doctor-put-meaning stomachache 'symptoms)\n(doctor-put-meaning headache 'symptoms)\n(doctor-put-meaning hurts 'symptoms)\n(doctor-put-meaning disease 'symptoms)\n(doctor-put-meaning virus 'symptoms)\n(doctor-put-meaning vomit 'symptoms)\n(doctor-put-meaning vomiting 'symptoms)\n(doctor-put-meaning barf 'symptoms)\n(doctor-put-meaning toothache 'symptoms)\n(doctor-put-meaning hurt 'symptoms)\n(doctor-put-meaning rum 'alcohol)\n(doctor-put-meaning gin 'alcohol)\n(doctor-put-meaning vodka 'alcohol)\n(doctor-put-meaning alcohol 'alcohol)\n(doctor-put-meaning bourbon 'alcohol)\n(doctor-put-meaning beer 'alcohol)\n(doctor-put-meaning wine 'alcohol)\n(doctor-put-meaning whiskey 'alcohol)\n(doctor-put-meaning scotch 'alcohol)\n(doctor-put-meaning fuck 'sexverb)\n(doctor-put-meaning fucked 'sexverb)\n(doctor-put-meaning screw 'sexverb)\n(doctor-put-meaning screwing 'sexverb)\n(doctor-put-meaning fucking 'sexverb)\n(doctor-put-meaning rape 'sexverb)\n(doctor-put-meaning raped 'sexverb)\n(doctor-put-meaning kiss 'sexverb)\n(doctor-put-meaning kissing 'sexverb)\n(doctor-put-meaning kisses 'sexverb)\n(doctor-put-meaning screws 'sexverb)\n(doctor-put-meaning fucks 'sexverb)\n(doctor-put-meaning because 'conj)\n(doctor-put-meaning but 'conj)\n(doctor-put-meaning however 'conj)\n(doctor-put-meaning besides 'conj)\n(doctor-put-meaning anyway 'conj)\n(doctor-put-meaning that 'conj)\n(doctor-put-meaning except 'conj)\n(doctor-put-meaning why 'conj)\n(doctor-put-meaning how 'conj)\n(doctor-put-meaning until 'when)\n(doctor-put-meaning when 'when)\n(doctor-put-meaning whenever 'when)\n(doctor-put-meaning while 'when)\n(doctor-put-meaning since 'when)\n(doctor-put-meaning rms 'rms)\n(doctor-put-meaning stallman 'rms)\n(doctor-put-meaning school 'school)\n(doctor-put-meaning schools 'school)\n(doctor-put-meaning skool 'school)\n(doctor-put-meaning grade 'school)\n(doctor-put-meaning grades 'school)\n(doctor-put-meaning teacher 'school)\n(doctor-put-meaning teachers 'school)\n(doctor-put-meaning classes 'school)\n(doctor-put-meaning professor 'school)\n(doctor-put-meaning prof 'school)\n(doctor-put-meaning profs 'school)\n(doctor-put-meaning professors 'school)\n(doctor-put-meaning mit 'school)\n(doctor-put-meaning emacs 'eliza)\n(doctor-put-meaning eliza 'eliza)\n(doctor-put-meaning liza 'eliza)\n(doctor-put-meaning elisa 'eliza)\n(doctor-put-meaning weizenbaum 'eliza)\n(doctor-put-meaning doktor 'eliza)\n(doctor-put-meaning atheletics 'sports)\n(doctor-put-meaning baseball 'sports)\n(doctor-put-meaning basketball 'sports)\n(doctor-put-meaning football 'sports)\n(doctor-put-meaning frisbee 'sports)\n(doctor-put-meaning gym 'sports)\n(doctor-put-meaning gymnastics 'sports)\n(doctor-put-meaning hockey 'sports)\n(doctor-put-meaning lacrosse 'sports)\n(doctor-put-meaning soccer 'sports)\n(doctor-put-meaning softball 'sports)\n(doctor-put-meaning sports 'sports)\n(doctor-put-meaning swimming 'sports)\n(doctor-put-meaning swim 'sports)\n(doctor-put-meaning tennis 'sports)\n(doctor-put-meaning volleyball 'sports)\n(doctor-put-meaning math 'math)\n(doctor-put-meaning mathematics 'math)\n(doctor-put-meaning mathematical 'math)\n(doctor-put-meaning theorem 'math)\n(doctor-put-meaning axiom 'math)\n(doctor-put-meaning lemma 'math)\n(doctor-put-meaning algebra 'math)\n(doctor-put-meaning algebraic 'math)\n(doctor-put-meaning trig 'math)\n(doctor-put-meaning trigonometry 'math)\n(doctor-put-meaning trigonometric 'math)\n(doctor-put-meaning geometry 'math)\n(doctor-put-meaning geometric 'math)\n(doctor-put-meaning calculus 'math)\n(doctor-put-meaning arithmetic 'math)\n(doctor-put-meaning zippy 'zippy)\n(doctor-put-meaning zippy 'zippy)\n(doctor-put-meaning pinhead 'zippy)\n(doctor-put-meaning chat 'chat)\n\f\n(defun doctor ()\n  \"Switch to *doctor* buffer and start giving psychotherapy.\"\n  (interactive)\n  (switch-to-buffer \"*doctor*\")\n  (doctor-mode))\n\n(defun doctor-ret-or-read (arg)\n  \"Insert a newline if preceding character is not a newline,\nOtherwise call the Doctor to parse preceding sentence\"\n  (interactive \"*p\")\n  (if (= (preceding-char) ?\\n)\n      (doctor-read-print)\n    (newline arg)))\n\n(defun doctor-read-print nil\n  \"top level loop\"\n  (interactive)\n  (let ((sent (doctor-readin)))\n    (insert \"\\n\")\n    (setq lincount (1+ lincount))\n    (doctor-doc sent)\n    (insert \"\\n\")\n    (setq bak sent)))\n\n(defun doctor-readin nil\n  \"Read a sentence. Return it as a list of words\"\n  (let (sentence)\n    (backward-sentence 1)\n    (while (not (eobp))\n      (setq sentence (append sentence (list (doctor-read-token)))))\n    sentence))\n\n(defun doctor-read-token ()\n  \"read one word from buffer\"\n  (prog1 (intern (downcase (buffer-substring (point)\n\t\t\t\t\t     (progn\n\t\t\t\t\t       (forward-word 1)\n\t\t\t\t\t       (point)))))\n    (re-search-forward \"\\\\Sw*\")))\n\f\n;; Main processing function for sentences that have been read.\n\n(defun doctor-doc (sent)\n  (cond\n   ((equal sent '(foo))\n    (doctor-type '(bar! ($ please)($ continue))))\n   ((doctor-member sent howareyoulst)\n    (doctor-type '(i\\'m ok \\.  ($ describe) yourself \\.)))\n   ((or (doctor-member sent '((good bye) (see you later) (i quit) (so long)\n\t\t\t      (go away) (get lost)))\n\t(memq (car sent)\n\t      '(bye halt break quit done exit goodbye \n\t\t    bye\\, stop pause goodbye\\, stop pause)))\n    (doctor-type ($ bye)))\n   ((and (eq (car sent) 'you)\n\t (memq (doctor-cadr sent) abusewords))\n    (setq found (doctor-cadr sent))\n    (doctor-type ($ abuselst)))\n   ((eq (car sent) 'whatmeans)\n    (doctor-def (doctor-cadr sent)))\n   ((equal sent '(parse))\n    (doctor-type (list  'subj '= subj \",  \"\n\t\t\t'verb '= verb \"\\n\"\n\t\t\t'object 'phrase '= obj \",\"\n\t\t\t'noun 'form '=  object \"\\n\"\n\t\t\t'current 'keyword 'is found\n\t\t\t\", \"\n\t\t\t'most 'recent 'possessive\n\t\t\t'is owner \"\\n\"\n\t\t\t'sentence 'used 'was\n\t\t\t\"...\"\n\t\t\t'(// bak))))\n   ;;   ((eq (car sent) 'forget)\n   ;;    (set (doctor-cadr sent) nil)\n   ;;    (doctor-type '(($ isee)($ please)\n   ;;     ($ continue)\\.)))\n   (t\n    (if (doctor-defq sent) (doctor-define sent found))\n    (if (> (length sent) 12)(doctor-shorten sent))\n    (setq sent (doctor-correct-spelling (doctor-replace sent replist)))\n    (cond ((and (not (memq 'me sent))(not (memq 'i sent))\n\t\t(memq 'am sent))\n\t   (setq sent (doctor-replace sent '((am . (are)))))))\n    (cond ((equal (car sent) 'yow) (doctor-zippy))\n\t  ((< (length sent) 2)\n\t   (cond ((eq (doctor-meaning (car sent)) 'howdy)\n\t\t  (doctor-howdy))\n\t\t (t (doctor-short))))\n\t  (t\n\t   (if (memq 'am sent)\n\t       (setq sent (doctor-replace sent '((me . (i))))))\n\t   (setq sent (doctor-fixup sent))\n\t   (if (and (eq (car sent) 'do) (eq (doctor-cadr sent) 'not))\n\t       (cond ((zerop (random-range 3))\n\t\t      (doctor-type '(are you ($ afraidof) that \\?)))\n\t\t     ((zerop (random-range 2))\n\t\t      (doctor-type '(don\\'t tell me what to do \\. i am the\n\t\t\t\t\t    psychiatrist here!))\n\t\t      (doctor-rthing))\n\t\t     (t\n\t\t      (doctor-type '(($ whysay) that i shouldn\\'t\n\t\t\t\t     (doctor-cddr sent)\n\t\t\t\t     \\?))))\n\t     (doctor-go (doctor-wherego sent))))))))\n\f\n;; Things done to process sentences once read.\n\n(defun doctor-correct-spelling (sent)\n  \"correct the spelling and expand each word in sentence\"\n  (if sent\n      (apply 'append (mapcar '(lambda (word)\n\t\t\t\t(if (memq word typos)\n\t\t\t\t    (get (get word 'doctor-correction) 'doctor-expansion)\n\t\t\t\t  (list word)))\n\t\t\t     sent))))\n\n(defun doctor-shorten (sent)\n  \"Make a sentence managably short using a few hacks\"\n  (let (foo\n\tretval\n\t(temp '(because but however besides anyway until\n\t\t    while that except why how)))\n    (while temp\n\t   (setq foo (memq (car temp) sent))\n\t   (if (and foo\n\t\t    (> (length foo) 3))\n\t       (setq sent foo\n\t\t     sent (doctor-fixup sent)\n\t\t     temp nil\n\t\t     retval t)\n\t       (setq temp (cdr temp))))\n    retval))\n\n(defun doctor-define (sent found)\n  (doctor-svo sent found 1 nil)\n  (and\n   (doctor-nounp subj)\n   (not (doctor-pronounp subj))\n   subj\n   (doctor-meaning object)\n   (put subj 'doctor-meaning (doctor-meaning object))\n   t))\n\n(defun doctor-defq (sent)\n  \"Set global var  found  to first keyword found in sentence SENT\"\n  (setq found nil)\n  (let ((temp '(means applies mean refers refer related\n\t\t      similar defined associated linked like same)))\n    (while temp\n\t   (if (memq (car temp) sent)\n\t       (setq found (car temp)\n\t\t     temp nil)\n\t       (setq temp (cdr temp)))))\n  found)\n\n(defun doctor-def (x)\n  (progn\n   (doctor-type (list 'the 'word x 'means (doctor-meaning x) 'to 'me)) \n   nil))\n\n(defun doctor-forget ()\n  \"Delete the last element of the history list\"\n  (setq history (reverse (cdr (reverse history)))))\n\n(defun doctor-query (x)\n  \"Prompt for a line of input from the minibuffer until a noun or a\nverb word is seen. Put dialogue in buffer.\"\n  (let (a\n\t(prompt (concat (doctor-make-string x)\n\t\t\t\" what \\?  \"))\n\tretval)\n    (while (not retval)\n\t   (while (not a)\n\t     (insert ?\\n\n\t\t     prompt\n\t\t     (read-string prompt)\n\t\t     ?\\n)\n\t     (setq a (doctor-readin)))\n\t   (while (and a (not retval))\n\t\t  (cond ((doctor-nounp (car a))\n\t\t\t (setq retval (car a)))\n\t\t\t((doctor-verbp (car a))\n\t\t\t (setq retval (doctor-build\n\t\t\t\t       (doctor-build x \" \")\n\t\t\t\t       (car a))))\n\t\t\t((setq a (cdr a))))))\n    retval))\n\n(defun doctor-subjsearch (sent key type)\n  \"Search for the subject of a sentence SENT, looking for the noun closest to\nand preceding KEY by at least TYPE words. Set global variable subj to the\nsubject noun, and return the portion of the sentence following it\"\n  (let ((i (- (length sent) (length (memq key sent)) type)))\n    (while (and (> i -1) (not (doctor-nounp (nth i sent))))\n      (setq i (1- i)))\n    (cond ((> i -1)\n\t   (setq subj (nth i sent))\n\t   (nthcdr (1+ i) sent))\n\t  (t\n\t   (setq subj 'you)\n\t   nil))))\n\n(defun doctor-nounp (x)\n  \"Returns t if the symbol argument is a noun\"\n\t(or (doctor-pronounp x)\n\t    (not (or (doctor-verbp x)\n\t\t     (equal x 'not)\n\t\t     (doctor-prepp x)\n\t\t     (doctor-modifierp x) )) ))\n\n(defun doctor-pronounp (x)\n  \"Returns t if the symbol argument is a pronoun\"\n  (memq x '(\n\ti me mine myself\n\twe us ours ourselves ourself\n\tyou yours yourself yourselves\n\the him himself she hers herself\n\tit that those this these things thing\n\tthey them themselves theirs\n\tanybody everybody somebody\n\tanyone everyone someone\n\tanything something everything)))\n\n(mapcar (function (lambda (x) (put x 'doctor-sentence-type 'verb)))\n\t'(abort aborted aborts ask asked asks am\n\t\tapplied applies apply are associate\n\t\tassociated ate\n\t\tbe became become becomes becoming\n\t\tbeen being believe belived believes\n\t\tbit bite bites bore bored bores boring bought buy buys buying\n\t\tcall called calling calls came can caught catch come\n\t\tcontract contracted contracts control controlled controls\n\t\tcould croak croaks croaked cut cuts\n\t\tdare dared define defines dial dialed dials did die died dies\n\t\tdislike disliked\n\t\tdislikes do does drank drink drinks drinking\n\t\tdrive drives driving drove dying\n\t\teat eating eats expand expanded expands\n\t\texpect expected expects expel expels expeled expelled\n\t\texplain explained explains\n\t\tfart farts feel feels felt fight fights find finds finding\n\t\tforget forgets forgot fought found fuck fucked\n\t\tfucking fucks\n\t\tgave get gets getting give gives go goes going gone got gotten\n\t\thad harm harms has hate hated hates have having\n\t\thear heard hears hearing help helped helping helps\n\t\thit hits hope hoped hopes hurt hurts\n\t\timplies imply is\n\t\tjoin joined joins jump jumped jumps\n\t\tkeep keeping keeps kept\n\t\tkill killed killing kills kiss kissed kisses kissing\n\t\tknew know knows\n\t\tlaid lay lays let lets lie lied lies like liked likes\n\t\tliking listen listens\n\t\tlogin look looked looking looks\n\t\tlose losing lost\n\t\tlove loved loves loving\n\t\tluse lusing lust lusts\n\t\tmade make makes making may mean means meant might\n\t\tmove moved moves moving must\n\t\tneed needed needs \n\t\torder ordered orders ought\n\t\tpaid pay pays pick picked picking picks \n\t\tplaced placing prefer prefers put puts\n\t\tran rape raped rapes\n\t\tread reading reads recall receive received receives\n\t\trefer refered referred refers\n\t\trelate related relates remember remembered remembers\n\t\tromp romped romps run running runs\n\t\tsaid sang sat saw say says\n\t\tscrew screwed screwing screws scrod see sees seem seemed\n\t\tseems seen sell selling sells\n\t\tsend sendind sends sent shall shoot shot should\n\t\tsing sings sit sits sitting sold studied study\n\t\ttake takes taking talk talked talking talks tell tells telling\n\t\tthink thinks\n\t\tthought told took tooled touch touched touches touching\n\t\ttransfer transfered transfers transmit transmits transmitted\n\t\ttype types types typing\n\t\twalk walked walking walks want wanted wants was watch\n\t\twatched watching went were will wish would work worked works\n\t\twrite writes writing wrote use used uses using))\n\n(defun doctor-verbp (x) (if (symbolp x)\n\t\t\t    (eq (get x 'doctor-sentence-type) 'verb)))\n\n(defun doctor-plural (x)\n  \"form the plural of the word argument\"\n  (let ((foo (doctor-make-string x)))\n    (cond ((string-equal (substring foo -1) \"s\")\n\t   (cond ((string-equal (substring foo -2 -1) \"s\")\n\t\t  (intern (concat foo \"es\")))\n\t\t (t x)))\n\t   ((string-equal (substring foo -1) \"y\")\n\t    (intern (concat (substring foo 0 -1)\n\t\t\t    \"ies\")))\n\t   (t (intern (concat foo \"s\"))))))\n\n(defun doctor-setprep (sent key)\n  (let ((val)\n\t(foo (memq key sent)))\n    (cond ((doctor-prepp (doctor-cadr foo))\n\t   (setq val (doctor-getnoun (doctor-cddr foo)))\n\t   (cond (val val)\n\t\t (t 'something)))\n\t  ((doctor-articlep (doctor-cadr foo))\n\t   (setq val (doctor-getnoun (doctor-cddr foo)))\n\t   (cond (val (doctor-build (doctor-build (doctor-cadr foo) \" \") val))\n\t\t (t 'something)))\n\t  (t 'something))))\n\n(defun doctor-getnoun (x)\n  (cond ((null x)(setq object 'something))\n\t((atom x)(setq object x))\n\t((eq (length x) 1)\n\t (setq object (cond\n\t\t       ((doctor-nounp (setq object (car x))) object)\n\t\t       (t (doctor-query object)))))\n\t((eq (car x) 'to)\n\t (doctor-build 'to\\  (doctor-getnoun (cdr x))))\n\t((doctor-prepp (car x))\n\t (doctor-getnoun (cdr x)))\n\t((not (doctor-nounp (car x)))\n\t (doctor-build (doctor-build (cdr (assq (car x)\n\t\t\t\t\t\t(append\n\t\t\t\t\t\t '((a . this)\n\t\t\t\t\t\t   (some . this)\n\t\t\t\t\t\t   (one . that))\n\t\t\t\t\t\t (list\n\t\t\t\t\t\t  (cons\n\t\t\t\t\t\t   (car x) (car x))))))\n\t\t\t\t     \" \")\n\t\t       (doctor-getnoun (cdr x))))\n\t(t (setq object (car x))) ))\n\n(defun doctor-modifierp (x)\n  (or (doctor-adjectivep x)\n      (doctor-adverbp x)\n      (doctor-othermodifierp x)))\n\n(defun doctor-adjectivep (x)\n  (or (numberp x)\n      (doctor-nmbrp x)\n      (doctor-articlep x)\n      (doctor-colorp x)\n      (doctor-sizep x)\n      (doctor-possessivepronounp x)))\n\n(defun doctor-adverbp (xx)\n  (string-equal (substring (doctor-make-string xx) -2) \"ly\"))\n\n(defun doctor-articlep (x)\n  (memq x '(the a an)))\n\n(defun doctor-nmbrp (x)\n  (memq x '(one two three four five six seven eight nine ten\n\t\televen twelve thirteen fourteen fifteen\n\t\tsixteen seventeen eighteen nineteen\n\t\ttwenty thirty forty fifty sixty seventy eighty ninety\n\t\thundred thousand million billion\n\t\thalf quarter\n\t\tfirst second third fourth fifth\n\t\tsixth seventh eighth nineth tenth)))\n\t\t \n(defun doctor-colorp (x)\n  (memq x '(beige black blue brown crimson\n\t\t  gray grey green\n\t\t  orange pink purple red tan tawny\n\t\t  violet white yellow)))\n\n(defun doctor-sizep (x)\n  (memq x '(big large tall fat wide thick\n\t\tsmall petite short thin skinny)))\n\n(defun doctor-possessivepronounp (x)\n  (memq x '(my your his her our their)))\n\n(defun doctor-othermodifierp (x)\n  (memq x '(all also always amusing any anyway associated awesome\n\t\tbad beautiful best better but certain clear\n\t\tever every fantastic fun funny\n\t\tgood great gross growdy however if ignorant\n\t\tless linked losing lusing many more much\n\t\tnever nice obnoxious often poor pretty real related rich\n\t\tsimilar some stupid super superb\n\t\tterrible terrific too total tubular ugly very)))\n\n(defun doctor-prepp (x)\n  (memq x '(about above after around as at\n\t\t  before beneath behind beside between by\n\t\t  for from in inside into\n\t\t  like near next of on onto over\n\t\t  same through thru to toward towards\n\t\t  under underneath with without)))\n\n(defun doctor-remember (thing)\n  (cond ((null history)\n\t (setq history (list thing)))\n\t(t (setq history (append history (list thing))))))\n\n(defun doctor-type (x)\n  (setq x (doctor-fix-2 x))\n  (doctor-txtype (doctor-assm x)))\n\n(defun doctor-fixup (sent)\n  (setq sent (append\n\t      (cdr\n\t       (assq (car sent)\n\t\t     (append\n\t\t      '((me  i)\n\t\t\t(him  he)\n\t\t\t(her  she)\n\t\t\t(them  they)\n\t\t\t(okay)\n\t\t\t(well)\n\t\t\t(sigh)\n\t\t\t(hmm)\n\t\t\t(hmmm)\n\t\t\t(hmmmm)\n\t\t\t(hmmmmm)\n\t\t\t(gee)\n\t\t\t(sure)\n\t\t\t(great)\n\t\t\t(oh)\n\t\t\t(fine)\n\t\t\t(ok)\n\t\t\t(no))\n\t\t      (list (list (car sent)\n\t\t\t\t  (car sent))))))\n\t      (cdr sent)))\n  (doctor-fix-2 sent))\n\n(defun doctor-fix-2 (sent)\n  (let ((foo sent))\n    (while foo\n      (if (and (eq (car foo) 'me)\n\t       (doctor-verbp (doctor-cadr foo)))\n\t  (rplaca foo 'i)\n\t(cond ((eq (car foo) 'you)\n\t       (cond ((memq (doctor-cadr foo) '(am be been is))\n\t\t      (rplaca (cdr foo) 'are))\n\t\t     ((memq (doctor-cadr foo) '(has))\n\t\t      (rplaca (cdr foo) 'have))\n\t\t     ((memq (doctor-cadr foo) '(was))\n\t\t      (rplaca (cdr foo) 'were))))\n\t      ((equal (car foo) 'i)\n\t       (cond ((memq (doctor-cadr foo) '(are is be been))\n\t\t      (rplaca (cdr foo) 'am))\n\t\t     ((memq (doctor-cadr foo) '(were))\n\t\t      (rplaca (cdr foo) 'was))\n\t\t     ((memq (doctor-cadr foo) '(has))\n\t\t      (rplaca (cdr foo) 'have))))\n\t      ((and (doctor-verbp (car foo))\n\t\t    (eq (doctor-cadr foo) 'i)\n\t\t    (not (doctor-verbp (car (doctor-cddr foo)))))\n\t       (rplaca (cdr foo) 'me))\n\t      ((and (eq (car foo) 'a)\n\t\t    (doctor-vowelp (string-to-char\n\t\t\t\t    (doctor-make-string (doctor-cadr foo)))))\n\t       (rplaca foo 'an))\n\t      ((and (eq (car foo) 'an)\n\t\t    (not (doctor-vowelp (string-to-char\n\t\t\t\t\t (doctor-make-string (doctor-cadr foo))))))\n\t       (rplaca foo 'a)))\n\t(setq foo (cdr foo))))\n    sent))\n\n(defun doctor-vowelp (x)\n  (memq x '(?a ?e ?i ?o ?u)))\n\n(defun doctor-replace (sent rlist)\n  \"Replaces any element of SENT that is the car of a replacement element\npair in RLIST\"\n  (apply 'append\n\t (mapcar\n\t  (function\n\t   (lambda (x)\n\t     (cdr (or (assq x rlist)   ; either find a replacement\n\t\t      (list x x)))))   ; or fake an identity mapping\n\t  sent)))\n\n(defun doctor-wherego (sent)\n  (cond ((null sent)($ whereoutp))\n\t((null (doctor-meaning (car sent)))\n\t (doctor-wherego (cond ((zerop (random-range 2))\n\t\t\t\t(reverse (cdr sent)))\n\t\t\t       (t (cdr sent)))))\n\t(t\n\t (setq found (car sent))\n\t (doctor-meaning (car sent)))))\n\n(defun doctor-svo (sent key type mem)\n  \"Find subject, verb and object in sentence SENT with focus on word KEY.\nTYPE is number of words preceding KEY to start looking for subject. MEM is\nt if results are to be put on doctor's memory stack. Return is in global\nvariables subj, verb and object\"\n  (let ((foo (doctor-subjsearch sent key type) sent))\n    (or foo\n\t(setq foo sent\n\t      mem nil))\n    (while (and (null (doctor-verbp (car foo))) (cdr foo))\n      (setq foo (cdr foo)))\n    (setq verb (car foo))\n    (setq obj (doctor-getnoun (cdr foo)))\n    (cond ((eq object 'i)(setq object 'me))\n\t  ((eq subj 'me)(setq subj 'i)))\n    (cond (mem (doctor-remember (list subj verb obj))))))\n\n(defun doctor-possess (sent key)\n  \"Set possessive in SENT for keyword KEY. Hack on previous word, setting\nglobal variable owner to possibly correct result\"\n  (let* ((i (- (length sent) (length (memq key sent)) 1))\n\t (prev (if (< i 0) 'your\n\t\t (nth i sent))))\n    (setq owner (if (or (doctor-possessivepronounp prev)\n\t\t\t(string-equal \"s\"\n\t\t\t\t      (substring (doctor-make-string prev)\n\t\t\t\t\t\t -1)))\n\t\t    prev\n\t\t  'your))))\n\f\n;; Output of replies.\n\n(defun doctor-txtype (ans)\n  \"Output to buffer a list of symbols or strings as a sentence\"\n  (setq *print-upcase* t *print-space* nil)\n  (mapcar 'doctor-type-symbol ans)\n  (insert \"\\n\"))\n\n(defun doctor-type-symbol (word)\n  \"Output a symbol to the buffer with some fancy case and spacing hacks\"\n  (setq word (doctor-make-string word))\n  (if (string-equal word \"i\") (setq word \"I\"))\n  (if *print-upcase*\n      (progn\n\t(setq word (capitalize word))\n\t(if *print-space*\n\t    (insert \" \"))))\n  (cond ((or (string-match \"^[.,;:?! ]\" word)\n\t     (not *print-space*))\n\t (insert word))\n\t(t (insert ?\\  word)))\n  (if (> (current-column) fill-column)\n      (apply auto-fill-hook nil))\n  (setq *print-upcase* (string-match \"[.?!]$\" word)\n\t*print-space* t))\n\n(defun doctor-build (str1 str2)\n  \"Make a symbol out of the concatenation of the two non-list arguments\"\n  (cond ((null str1) str2)\n\t((null str2) str1)\n\t((and (atom str1)\n\t      (atom str2))\n\t (intern (concat (doctor-make-string str1)\n\t\t\t (doctor-make-string str2))))\n\t(t nil)))\n\n(defun doctor-make-string (obj)\n  (cond ((stringp obj) obj)\n\t((symbolp obj) (symbol-name obj))\n\t((numberp obj) (int-to-string obj))\n\t(t \"\")))\n\n(defun doctor-concat (x y)\n  \"like append, but force atomic arguments to be lists\"\n  (append\n   (if (and x (atom x)) (list x) x)\n   (if (and y (atom y)) (list y) y)))\n\n(defun doctor-assm (proto)\n  (cond ((null proto) nil)\n\t((atom proto) (list proto))\n\t((atom (car proto))\n\t (cons (car proto) (doctor-assm (cdr proto))))\n\t(t (doctor-concat (doctor-assm (eval (car proto))) (doctor-assm (cdr proto))))))\n\f\n;; Functions that handle specific words or meanings when found.\n\n(defun doctor-go (destination)\n  \"Call a doctor- function\"\n  (funcall (intern (concat \"doctor-\" (doctor-make-string destination)))))\n\n(defun doctor-desire1 ()\n  (doctor-go ($ whereoutp)))\n\n(defun doctor-huh ()\n  (cond ((< (length sent) 9) (doctor-type ($ huhlst)))\n\t(t (doctor-type ($ longhuhlst)))))\n\n(defun doctor-rthing () (doctor-type ($ thlst)))\n\n(defun doctor-remem () (cond ((null history)(doctor-huh))\n\t\t\t     ((doctor-type ($ remlst)))))\n\n(defun doctor-howdy ()\n  (cond ((not howdyflag)\n\t (doctor-type '(($ hello) what brings you to see me \\?))\n\t (setq howdyflag t))\n\t(t\n\t (doctor-type '(($ ibelieve) we\\'ve introduced ourselves already \\.))\n\t (doctor-type '(($ please) ($ describe) ($ things) \\.)))))\n\n(defun doctor-when ()\n  (cond ((< (length (memq found sent)) 3)(doctor-short))\n\t(t\n\t (setq sent (cdr (memq found sent)))\n\t (setq sent (doctor-fixup sent))\n\t (doctor-type '(($ whatwhen)(// sent) \\?)))))\n\n(defun doctor-conj ()\n  (cond ((< (length (memq found sent)) 4)(doctor-short))\n\t(t\n\t (setq sent (cdr (memq found sent)))\n\t (setq sent (doctor-fixup sent))\n\t (cond ((eq (car sent) 'of)\n\t\t(doctor-type '(are you ($ sure) that is the real reason \\?))\n\t\t(setq things (cons (cdr sent) things)))\n\t       (t\n\t\t(doctor-remember sent)\n\t\t(doctor-type ($ beclst)))))))\n\n(defun doctor-short ()\n  (cond ((= (car repetitive-shortness) (1- lincount))\n\t (rplacd repetitive-shortness\n\t\t (1+ (cdr repetitive-shortness))))\n\t(t\n\t (rplacd repetitive-shortness 1)))\n  (rplaca repetitive-shortness lincount)\n  (cond ((> (cdr repetitive-shortness) 6)\n\t (cond ((not **mad**)\n\t\t(doctor-type '(($ areyou)\n\t\t\t       just trying to see what kind of things\n\t\t\t       i have in my vocabulary \\? please try to\n\t\t\t       carry on a reasonable conversation!))\n\t\t(setq **mad** t))\n\t       (t\n\t\t(doctor-type '(i give up \\. you need a lesson in creative\n\t\t\t\t writing \\.\\.\\.))\n\t\t;;(push monosyllables observation-list)\n\t\t)))\n\t(t\n\t (cond ((equal sent (doctor-assm '(yes)))\n\t\t(doctor-type '(($ isee) ($ inter) ($ whysay) this is so \\?)))\n\t       ((equal sent (doctor-assm '(because)))\n\t\t(doctor-type ($ shortbeclst)))\n\t       ((equal sent (doctor-assm '(no)))\n\t\t(doctor-type ($ neglst)))\n\t       (t (doctor-type ($ shortlst)))))))\n\t   \n(defun doctor-alcohol () (doctor-type ($ drnk)))\n\n(defun doctor-desire ()\n  (let ((foo (memq found sent)))\n    (cond ((< (length foo) 2)\n\t   (doctor-go (doctor-build (doctor-meaning found) 1)))\n\t  ((memq (doctor-cadr foo) '(a an))\n\t   (rplacd foo (append '(to have) (cdr foo)))\n\t   (doctor-svo sent found 1 nil)\n\t   (doctor-remember (list subj 'would 'like obj))\n\t   (doctor-type ($ whywant)))\n\t  ((not (eq (doctor-cadr foo) 'to))\n\t   (doctor-go (doctor-build (doctor-meaning found) 1)))\n\t  (t\n\t   (doctor-svo sent found 1 nil)\n\t   (doctor-remember (list subj 'would 'like obj))\n\t   (doctor-type ($ whywant))))))\n\n(defun doctor-drug ()\n  (doctor-type ($ drugs))\n  (doctor-remember (list 'you 'used found)))\n\n(defun doctor-toke ()\n  (doctor-type ($ toklst)))\n\n(defun doctor-state ()\n  (doctor-type ($ states))(doctor-remember (list 'you 'were found)))\n\n(defun doctor-mood ()\n  (doctor-type ($ moods))(doctor-remember (list 'you 'felt found)))\n\n(defun doctor-fear ()\n  (setq feared (doctor-setprep sent found))\n  (doctor-type ($ fears))\n  (doctor-remember (list 'you 'were 'afraid 'of feared)))\n\n(defun doctor-hate ()\n  (doctor-svo sent found 1 t)\n  (cond ((memq 'not sent) (doctor-forget) (doctor-huh))\n\t((equal subj 'you)\n\t (doctor-type '(why do you (// verb)(// obj) \\?)))\n\t(t (doctor-type '(($ whysay)(list subj verb obj))))))\n\n(defun doctor-symptoms ()\n  (doctor-type '(($ maybe) you should consult a doctor of medicine\\,\n\t\t i am a psychiatrist \\.)))\n\n(defun doctor-hates ()\n  (doctor-svo sent found 1 t)\n  (doctor-hates1))\n\n(defun doctor-hates1 ()\n  (doctor-type '(($ whysay)(list subj verb obj))))\n\n(defun doctor-loves ()\n  (doctor-svo sent found 1 t)\n  (doctor-qloves))\n\n(defun doctor-qloves ()\n  (doctor-type '(($ bother)(list subj verb obj) \\?)))\n\n(defun doctor-love ()\n  (doctor-svo sent found 1 t)\n  (cond ((memq 'not sent) (doctor-forget) (doctor-huh))\n\t((memq 'to sent) (doctor-hates1))\n\t(t\n\t (cond ((equal object 'something)\n\t\t(setq object '(this person you love))))\n\t (cond ((equal subj 'you)\n\t\t(setq lover obj)\n\t\t(cond ((equal lover '(this person you love))\n\t\t       (setq lover '(your partner))\n\t\t       (doctor-forget)\n\t\t       (doctor-type '(with whom are you in love \\?)))\n\t\t      ((doctor-type '(($ please)\n\t\t\t\t      ($ describe)\n\t\t\t\t      ($ relation)\n\t\t\t\t      (// lover)\n\t\t\t\t      \\.)))))\n\t       ((equal subj 'i)\n\t\t(doctor-txtype '(we were discussing you!)))\n\t       (t (doctor-forget)\n\t\t  (setq obj 'someone)\n\t\t  (setq verb (doctor-build verb 's))\n\t\t  (doctor-qloves))))))\n\n(defun doctor-mach ()\n  (setq found (doctor-plural found))\n  (doctor-type ($ machlst)))\n\n(defun doctor-sexnoun () (doctor-sexverb))\n\n(defun doctor-sexverb ()\n  (if (or (memq 'me sent)(memq 'myself sent)(memq 'i sent))\n      (doctor-foul)\n    (doctor-type ($ sexlst))))\n\n(defun doctor-death () (doctor-type ($ deathlst)))\n\n(defun doctor-foul ()\n  (doctor-type ($ foullst)))\n\n(defun doctor-family ()\n  (doctor-possess sent found)\n  (doctor-type ($ famlst)))\n\n;; I did not add this -- rms.\n(defun doctor-rms ()\n  (cond (rms-flag (doctor-type ($ stallmanlst)))\n\t(t (setq rms-flag t) (doctor-type '(do you know Stallman \\?)))))\n\n(defun doctor-school nil (doctor-type ($ schoollst)))\n\n(defun doctor-eliza ()\n  (cond (eliza-flag (doctor-type ($ elizalst)))\n\t(t (setq eliza-flag t)\n\t   (doctor-type '((// found) \\? hah !\n\t\t\t  ($ please) ($ continue) \\.)))))\n\t   \n(defun doctor-sports ()  (doctor-type ($ sportslst)))\n\n(defun doctor-math () (doctor-type ($ mathlst)))\n\n(defun doctor-zippy ()\n  (cond (zippy-flag (doctor-type ($ zippylst)))\n\t(t (setq zippy-flag t)\n\t   (doctor-type '(yow! are we interactive yet \\?)))))\n\n\n(defun doctor-chat () (doctor-type ($ chatlst)))",
    "397167203e546383f257250af82cb658": "/* Fully extensible Emacs, running on Unix, intended for GNU.\n   Copyright (C) 1985, 1986, 1987, 1990 Free Software Foundation, Inc.\n\nThis file is part of GNU Emacs.\n\nGNU Emacs is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 1, or (at your option)\nany later version.\n\nGNU Emacs is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GNU Emacs; see the file COPYING.  If not, write to\nthe Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n\n\n/* This must precede sys/signal.h on certain machines.  */\n#include <sys/types.h>\n#include <signal.h>\n#include <errno.h>\n\n#include \"config.h\"\n#ifdef NULL\n#undef NULL\n#endif\n#include \"lisp.h\"\n#undef NULL\n#include \"commands.h\"\n\n/* Get FIONREAD, if it is available,\n   just to help decide whether SIGIO should be defined.  */\n#ifdef USG\n#include <termio.h>\n#include <fcntl.h>\n#else /* not USG */\n#ifndef VMS\n#include <sys/ioctl.h>\n#endif /* not VMS */\n#endif /* not USG */\n\n/* Allow m- file to inhibit use of FIONREAD.  */\n#ifdef BROKEN_FIONREAD\n#undef FIONREAD\n#endif\n\n/* We are unable to use interrupts if FIONREAD is not available,\n   so flush SIGIO so we won't try. */\n#ifndef FIONREAD\n#ifdef SIGIO\n#undef SIGIO\n#endif\n#endif\n\n#include <stdio.h>\n#include <sys/file.h>\n\n#ifdef VMS\n#include <ssdef.h>\n#endif\n\n#if 0 /* fcntl.h was included above.  */\n#ifdef USG5\n#include <fcntl.h>\n#endif\n#endif\n\n#ifdef BSD\n#include <sys/ioctl.h>\n#endif\n\n#ifdef APOLLO\n#ifndef APOLLO_SR10\n#include <default_acl.h>\n#endif\n#endif\n\n#ifndef O_RDWR\n#define O_RDWR 2\n#endif\n\n#define PRIO_PROCESS 0\n\n/* Command line args from shell, as list of strings */\nLisp_Object Vcommand_line_args;\n\n/* Hook run by `kill-emacs' before it does really anything.  */\nLisp_Object Vkill_emacs_hook;\n\n/* Set nonzero after Emacs has started up the first time.\n  Prevents reinitialization of the Lisp world and keymaps\n  on subsequent starts.  */\nint initialized;\n\n/* Variable whose value is symbol giving operating system type */\nLisp_Object Vsystem_type;\n  \n/* If non-zero, emacs should not attempt to use an window-specific code,\n   but instead should use the virtual terminal under which it was started */\nint inhibit_window_system;\n\n#ifdef HAVE_X_WINDOWS\n/* If -d option is used, this variable points to the name of\n   the display to use.  */\nchar *alternate_display;\nchar **xargv;\nint xargc;\n#endif /* HAVE_X_WINDOWS */\n\n#ifdef USG_SHARED_LIBRARIES\n/* If nonzero, this is the place to put the end of the writable segment\n   at startup.  */\n\nunsigned int bss_end = 0;\n#endif\n\n/* Nonzero means running Emacs without interactive terminal.  */\n\nint noninteractive;\n\n/* Value of Lisp variable `noninteractive'.\n   Normally same as C variable `noninteractive'\n   but nothing terrible happens if user sets this one.  */\n\nint noninteractive1;\n\f\n/* Signal code for the fatal signal that was received */\nint fatal_error_code;\n\n/* Nonzero if handling a fatal error already */\nint fatal_error_in_progress;\n\n/* Handle bus errors, illegal instruction, etc. */\nfatal_error_signal (sig)\n     int sig;\n{\n#ifdef BSD\n  int tpgrp;\n#endif /* BSD */\n\n  fatal_error_code = sig;\n  signal (sig, SIG_DFL);\n\n  /* If fatal error occurs in code below, avoid infinite recursion.  */\n  if (fatal_error_in_progress)\n    kill (getpid (), fatal_error_code);\n\n  fatal_error_in_progress = 1;\n\n  /* If we are controlling the terminal, reset terminal modes */\n#ifdef BSD\n  if (ioctl(0, TIOCGPGRP, &tpgrp) == 0\n      && tpgrp == getpgrp (0))\n#endif /* BSD */\n    {\n      reset_sys_modes ();\n      if (sig != SIGTERM)\n\tfprintf (stderr, \"Fatal error (%d).\", sig);\n    }\n\n  /* Clean up */\n#ifdef subprocesses\n  kill_buffer_processes (Qnil);\n#endif\n  Fdo_auto_save (Qt);\n\n#ifdef CLASH_DETECTION\n  unlock_all_files ();\n#endif /* CLASH_DETECTION */\n\n#ifdef VMS\n  kill_vms_processes ();\n  LIB$STOP (SS$_ABORT);\n#else\n  /* Signal the same code; this time it will really be fatal.  */\n  kill (getpid (), fatal_error_code);\n#endif /* not VMS */\n}\n\f\n/* Code for dealing with Lisp access to the Unix command line */\n\nstatic\ninit_cmdargs (argc, argv, skip_args)\n     int argc;\n     char **argv;\n     int skip_args;\n{\n  register int i;\n\n  Vcommand_line_args = Qnil;\n\n  for (i = argc - 1; i >= 0; i--)\n    {\n      if (i == 0 || i > skip_args)\n\tVcommand_line_args\n\t  = Fcons (build_string (argv[i]), Vcommand_line_args);\n    }\n}\n\f\n#ifdef VMS\n#ifdef LINK_CRTL_SHARE\n#ifdef SHAREABLE_LIB_BUG\n#ifdef __GNUC__\n#define\tenviron $$PsectAttributes_NOSHR$$environ\nextern char **environ;\n#else\nextern noshare char **environ;\n#endif\n#endif /* SHAREABLE_LIB_BUG */\n#endif /* LINK_CRTL_SHARE */\n#endif /* VMS */\n\n/* We don't include crtbegin.o and crtend.o in the link,\n   so these functions and variables might be missed.\n   Provide dummy definitions to avoid error.\n   (We don't have any real constructors or destructors.)  */\n#ifdef __GNUC__\n#ifndef ORDINARY_LINK\n__do_clobal_ctors ()\n{}\n__do_clobal_ctors_aux ()\n{}\n__do_global_dtors ()\n{}\nchar * __CTOR_LIST__[2] = { (char *) (-1), 0 };\nchar * __DTOR_LIST__[2] = { (char *) (-1), 0 };\n__main ()\n{}\n#endif /* not ORDINARY_LINK */\n#endif /* __GNUC__ */\n\n/* ARGSUSED */\nmain (argc, argv, envp)\n     int argc;\n     char **argv;\n     char **envp;\n{\n  int skip_args = 0;\n  extern int errno;\n  extern void malloc_warning ();\n\n/* Map in shared memory, if we are using that.  */\n#ifdef HAVE_SHM\n  if (argc > 1 && !strcmp (argv[1], \"-nl\"))\n    {\n      map_in_data (0);\n      /* The shared memory was just restored, which clobbered this.  */\n      skip_args = 1;\n    }\n  else\n    {\n      map_in_data (1);\n      /* The shared memory was just restored, which clobbered this.  */\n      skip_args = 0;\n    }\n#endif\n\n#ifdef VMS\n  /* If -map specified, map the data file in */\n  if (argc > 2 && ! strcmp (argv[1], \"-map\"))\n    {\n      skip_args = 2;\n      mapin_data (argv[2]);\n    }\n\n#ifdef LINK_CRTL_SHARE\n#ifdef SHAREABLE_LIB_BUG\n  /* Bletcherous shared libraries! */\n  if (!stdin)\n    stdin = fdopen (0, \"r\");\n  if (!stdout)\n    stdout = fdopen (1, \"w\");\n  if (!stderr)\n    stderr = fdopen (2, \"w\");\n  if (!environ)\n    environ = envp;\n#endif /* SHAREABLE_LIB_BUG */\n#endif /* LINK_CRTL_SHARE */\n#endif /* VMS */\n\n#ifdef USG_SHARED_LIBRARIES\n  if (bss_end)\n    brk (bss_end);\n#endif\n\n#ifdef NeXT\n  extern int malloc_cookie;\n\n  /* This helps out unexnext.c.  */\n  if (initialized)\n    if (malloc_jumpstart (malloc_cookie) != 0)\n      printf (\"malloc jumpstart failed!\\n\");\n#endif /* NeXT */\n\n  clearerr (stdin);\n\n#ifdef APOLLO\n#ifndef APOLLO_SR10\n  /* If USE_DOMAIN_ACLS environment variable exists,\n     use ACLs rather than UNIX modes. */\n  if (egetenv (\"USE_DOMAIN_ACLS\"))\n    default_acl (USE_DEFACL);\n#endif\n#endif /* APOLLO */\n\n#ifndef SYSTEM_MALLOC\n  /* Arrange for warnings when nearly out of space.  */\n  malloc_init (0, malloc_warning);\n#endif\n\n#ifdef HIGHPRI\n  setpriority (PRIO_PROCESS, getpid (), HIGHPRI);\n  setuid (getuid ());\n#endif HIGHPRI\n\n  inhibit_window_system = 0;\n\n#ifdef HAVE_X_WINDOWS\n  xargv = argv;\n  xargc = argc;\n#endif\n\n/* Handle the -t switch, which specifies filename to use as terminal */\n  if (skip_args + 2 < argc && !strcmp (argv[skip_args + 1], \"-t\"))\n    {\n      skip_args += 2;\n      close (0);\n      close (1);\n      open (argv[skip_args], O_RDWR, 2 );\n      dup (0);\n      fprintf (stderr, \"Using %s\\n\", argv[skip_args]);\n#ifdef HAVE_X_WINDOWS\n      inhibit_window_system = 1;\t/* -t => -nw */\n#endif\n    }\n#ifdef HAVE_X_WINDOWS\n/* Handle the -d switch, which means use a different display for X */\n  if (skip_args + 2 < argc && (!strcmp (argv[skip_args + 1], \"-d\") ||\n\t\t\t       !strcmp (argv[skip_args + 1], \"-display\")))\n    {\n      skip_args += 2;\n      alternate_display = argv[skip_args];\n    } \n  else\n    alternate_display = 0;\n#endif\t/* HAVE_X_WINDOWS */\n\n  if (skip_args + 1 < argc\n      && (!strcmp (argv[skip_args + 1], \"-nw\")))\n    {\n      skip_args += 1;\n      inhibit_window_system = 1;\n    }\n\n/* Handle the -batch switch, which means don't do interactive display.  */\n  noninteractive = 0;\n  if (skip_args + 1 < argc && !strcmp (argv[skip_args + 1], \"-batch\"))\n    {\n      skip_args += 1;\n      noninteractive = 1;\n    }\n\n#ifdef POSIX_SIGNALS\n  init_signals ();\n#endif\n\n#ifdef HAVE_TZSET\n  /* Reinitialize the time zone if it was initialized before dumping Emacs.  */\n  if (initialized)\n    tzset ();\n#endif\n\n  if (\n#ifndef CANNOT_DUMP\n      ! noninteractive || initialized\n#else\n      1\n#endif\n      )\n    {\n      /* Don't catch these signals in batch mode if not initialized.\n\t On some machines, this sets static data that would make\n\t signal fail to work right when the dumped Emacs is run.  */\n      signal (SIGHUP, fatal_error_signal);\n      signal (SIGQUIT, fatal_error_signal);\n      signal (SIGILL, fatal_error_signal);\n      signal (SIGTRAP, fatal_error_signal);\n      signal (SIGIOT, fatal_error_signal);\n#ifdef SIGEMT\n      signal (SIGEMT, fatal_error_signal);\n#endif\n      signal (SIGFPE, fatal_error_signal);\n      signal (SIGBUS, fatal_error_signal);\n      signal (SIGSEGV, fatal_error_signal);\n      signal (SIGSYS, fatal_error_signal);\n      signal (SIGTERM, fatal_error_signal);\n#ifdef SIGXCPU\n      signal (SIGXCPU, fatal_error_signal);\n#endif\n#ifdef SIGXFSZ\n      signal (SIGXFSZ, fatal_error_signal);\n#endif SIGXFSZ\n\n#ifdef AIX\n      /* This used to run fatal_error_signal,\n\t but it isn't fatal.  There's nothing Emacs can usefully do.\n\t Might as well let the system kill us if it insists.  */\n      signal (SIGDANGER, SIG_IGN);\n      signal (20, fatal_error_signal);\n      signal (21, fatal_error_signal);\n      signal (22, fatal_error_signal);\n      signal (23, fatal_error_signal);\n      signal (24, fatal_error_signal);\n#ifdef SIGIO\n      signal (SIGAIO, fatal_error_signal);\n      signal (SIGPTY, fatal_error_signal);\n#endif\n#ifdef SIGURG\n      /* Note that SIGIOINT is the same as SIGIO on some machines,\n\t and the same as SIGURG on others.  It seems ore reliable to use the\n\t name with a uniform meaning.  */\n      signal (SIGURG, fatal_error_signal);\n#endif\n      signal (SIGGRANT, fatal_error_signal);\n      signal (SIGRETRACT, fatal_error_signal);\n      signal (SIGSOUND, fatal_error_signal);\n      signal (SIGMSG, fatal_error_signal);\n#endif /* AIX */\n    }\n\n  noninteractive1 = noninteractive;\n\n/* Perform basic initializations (not merely interning symbols) */\n\n  if (!initialized)\n    {\n      init_alloc_once ();\n      init_obarray ();\n      init_eval_once ();\n      init_syntax_once ();\t/* Create standard syntax table.  */\n\t\t      /* Must be done before init_buffer */\n      init_buffer_once ();\t/* Create buffer table and some buffers */\n      init_minibuf_once ();\t/* Create list of minibuffers */\n\t\t\t      /* Must precede init_window_once */\n      init_window_once ();\t/* Init the window system */\n    }\n\n  init_alloc ();\n#ifdef MAINTAIN_ENVIRONMENT\n  init_environ ();\n#endif\n  init_eval ();\n  init_data ();\n  init_read ();\n\n  init_cmdargs (argc, argv, skip_args);\t/* Create list Vcommand_line_args */\n  init_buffer ();\t/* Init default directory of main buffer */\n  if (!noninteractive)\n    {\n#ifdef VMS\n      init_vms_input ();/* init_display calls get_screen_size, that needs this */\n#endif /* VMS */\n      init_display ();\t/* Determine terminal type.  init_sys_modes uses results */\n    }\n  init_keyboard ();\t/* This too must precede init_sys_modes */\n  init_callproc ();\t/* And this too. */\n  init_sys_modes ();\t/* Init system terminal modes (RAW or CBREAK, etc.) */\n  init_xdisp ();\n  init_macros ();\n  init_editfns ();\n#ifdef VMS\n  init_vmsfns ();\n#endif /* VMS */\n#ifdef subprocesses\n  init_process ();\n#endif /* subprocesses */\n\n/* Intern the names of all standard functions and variables; define standard keys */\n\n  if (!initialized)\n    {\n      /* The basic levels of Lisp must come first */\n      /* And data must come first of all\n\t for the sake of symbols like error-message */\n      syms_of_data ();\n      syms_of_alloc ();\n#ifdef MAINTAIN_ENVIRONMENT\n      syms_of_environ ();\n#endif MAINTAIN_ENVIRONMENT\n      syms_of_read ();\n      syms_of_print ();\n      syms_of_eval ();\n      syms_of_fns ();\n\n      syms_of_abbrev ();\n      syms_of_buffer ();\n      syms_of_bytecode ();\n      syms_of_callint ();\n      syms_of_casefiddle ();\n      syms_of_callproc ();\n      syms_of_cmds ();\n#ifndef NO_DIR_LIBRARY\n      syms_of_dired ();\n#endif /* not NO_DIR_LIBRARY */\n      syms_of_display ();\n      syms_of_doc ();\n      syms_of_editfns ();\n      syms_of_emacs ();\n      syms_of_fileio ();\n#ifdef CLASH_DETECTION\n      syms_of_filelock ();\n#endif /* CLASH_DETECTION */\n      syms_of_indent ();\n      syms_of_keyboard ();\n      syms_of_keymap ();\n      syms_of_macros ();\n      syms_of_marker ();\n      syms_of_minibuf ();\n      syms_of_mocklisp ();\n#ifdef subprocesses\n      syms_of_process ();\n#endif /* subprocesses */\n      syms_of_search ();\n      syms_of_syntax ();\n      syms_of_undo ();\n      syms_of_window ();\n      syms_of_xdisp ();\n#ifdef HAVE_X_WINDOWS\n      syms_of_xfns ();\n#ifdef HAVE_X_MENU\n      syms_of_xmenu ();\n#endif /* HAVE_X_MENU */\n#endif /* HAVE_X_WINDOWS */\n\n#ifdef SYMS_SYSTEM\n      SYMS_SYSTEM;\n#endif\n\n#ifdef SYMS_MACHINE\n      SYMS_MACHINE;\n#endif\n\n      keys_of_casefiddle ();\n      keys_of_cmds ();\n      keys_of_buffer ();\n      keys_of_keyboard ();\n      keys_of_keymap ();\n      keys_of_macros ();\n      keys_of_minibuf ();\n      keys_of_window ();\n    }\n\n  if (!initialized)\n    {\n      /* Handle -l loadup-and-dump, args passed by Makefile. */\n      if (argc > 2 + skip_args && !strcmp (argv[1 + skip_args], \"-l\"))\n\tVtop_level = Fcons (intern (\"load\"),\n\t\t\t    Fcons (build_string (argv[2 + skip_args]), Qnil));\n#ifdef CANNOT_DUMP\n      /* Unless next switch is -nl, load \"loadup.el\" first thing.  */\n      if (!(argc > 1 + skip_args && !strcmp (argv[1 + skip_args], \"-nl\")))\n\tVtop_level = Fcons (intern (\"load\"),\n\t\t\t    Fcons (build_string (\"loadup.el\"), Qnil));\n#endif /* CANNOT_DUMP */\n    }\n\n  initialized = 1;\n\n  /* Enter editor command loop.  This never returns.  */\n  Frecursive_edit ();\n  /* NOTREACHED */\n}\n\f\nDEFUN (\"kill-emacs\", Fkill_emacs, Skill_emacs, 0, 1, \"P\",\n  \"Exit the Emacs job and kill it.  ARG means no query.\\n\\\nIf emacs is running noninteractively and ARG is an integer,\\n\\\nreturn ARG as the exit program code.\")\n  (arg)\n     Lisp_Object arg;\n{\n  Lisp_Object answer;\n  int i;\n  struct gcpro gcpro1;\n\n  GCPRO1 (arg);\n\n  if (!EQ (Vkill_emacs_hook, Qnil))\n    call0 (Vkill_emacs_hook);\n\n  if (feof (stdin))\n    arg = Qt;\n\n#ifdef subprocesses\n  kill_buffer_processes (Qnil);\n#endif /* subprocesses */\n\n#ifdef VMS\n  kill_vms_processes ();\n#endif /* VMS */\n\n  Fdo_auto_save (Qt);\n\n#ifdef CLASH_DETECTION\n  unlock_all_files ();\n#endif /* CLASH_DETECTION */\n\n  fflush (stdout);\n  reset_sys_modes ();\n  UNGCPRO;\n\n/* Is it really necessary to do this deassign\n   when we are going to exit anyway?  */\n/* #ifdef VMS\n  stop_vms_input ();\n #endif  */\n  stuff_buffered_input (arg);\n#ifdef SIGIO\n  /* There is a tendency for a SIGIO signal to arrive within exit,\n     and cause a SIGHUP because the input descriptor is already closed.  */\n  unrequest_sigio ();\n  signal (SIGIO, SIG_IGN);\n#endif\n  exit ((XTYPE (arg) == Lisp_Int) ? XINT (arg)\n#ifdef VMS\n\t: 1\n#else\n\t: 0\n#endif\n\t);\n  /* NOTREACHED */\n}\n\f\n#ifndef CANNOT_DUMP\n/* Nothing like this can be implemented on an Apollo.\n   What a loss!  */\n\n#ifdef HAVE_SHM\n\nDEFUN (\"dump-emacs-data\", Fdump_emacs_data, Sdump_emacs_data, 1, 1, 0,\n  \"Dump current state of Emacs into data file FILENAME.\\n\\\nThis function exists on systems that use HAVE_SHM.\")\n  (intoname)\n     Lisp_Object intoname;\n{\n  extern int my_edata;\n  Lisp_Object tem;\n  extern void malloc_warning ();\n\n  CHECK_STRING (intoname, 0);\n  intoname = Fexpand_file_name (intoname, Qnil);\n\n  tem = Vpurify_flag;\n  Vpurify_flag = Qnil;\n\n  fflush (stdout);\n  /* Tell malloc where start of impure now is */\n  /* Also arrange for warnings when nearly out of space.  */\n#ifndef SYSTEM_MALLOC\n  malloc_init (&my_edata, malloc_warning);\n#endif\n  map_out_data (XSTRING (intoname)->data);\n\n  Vpurify_flag = tem;\n\n  return Qnil;\n}\n\n#else /* not HAVE_SHM */\n\nDEFUN (\"dump-emacs\", Fdump_emacs, Sdump_emacs, 2, 2, 0,\n  \"Dump current state of Emacs into executable file FILENAME.\\n\\\nTake symbols from SYMFILE (presumably the file you executed to run Emacs).\")\n  (intoname, symname)\n     Lisp_Object intoname, symname;\n{\n  extern int my_edata;\n  Lisp_Object tem;\n  extern void malloc_warning ();\n\n  CHECK_STRING (intoname, 0);\n  intoname = Fexpand_file_name (intoname, Qnil);\n  if (!EQ (symname, Qnil))\n    {\n      CHECK_STRING (symname, 0);\n      if (XSTRING (symname)->size)\n\tsymname = Fexpand_file_name (symname, Qnil);\n    }\n\n  tem = Vpurify_flag;\n  Vpurify_flag = Qnil;\n\n  fflush (stdout);\n#ifdef VMS\n  mapout_data (XSTRING (intoname)->data);\n#else\n  /* Tell malloc where start of impure now is */\n  /* Also arrange for warnings when nearly out of space.  */\n#ifndef SYSTEM_MALLOC\n  malloc_init (&my_edata, malloc_warning);\n#endif\n  unexec (XSTRING (intoname)->data,\n\t  !EQ (symname, Qnil) ? XSTRING (symname)->data : 0, &my_edata, 0, 0);\n#endif /* not VMS */\n\n  Vpurify_flag = tem;\n\n  return Qnil;\n}\n\n#endif /* not HAVE_SHM */\n\n#endif /* not CANNOT_DUMP */\n\f\n#ifdef VMS\n#define SEPCHAR ','\n#else\n#define SEPCHAR ':'\n#endif\n\nLisp_Object\ndecode_env_path (evarname, defalt)\n     char *evarname, *defalt;\n{\n  register char *path, *p;\n  extern char *index ();\n\n  Lisp_Object lpath;\n\n  if (evarname != 0)\n    path = (char *) egetenv (evarname);\n  else\n    path = 0;\n  if (!path)\n    path = defalt;\n  lpath = Qnil;\n  while (1)\n    {\n      p = index (path, SEPCHAR);\n      if (!p) p = path + strlen (path);\n      lpath = Fcons (p - path ? make_string (path, p - path) : Qnil,\n\t\t     lpath);\n      if (*p)\n\tpath = p + 1;\n      else\n\tbreak;\n    }\n  return Fnreverse (lpath);\n}\n\nsyms_of_emacs ()\n{\n#ifndef CANNOT_DUMP\n#ifdef HAVE_SHM\n  defsubr (&Sdump_emacs_data);\n#else\n  defsubr (&Sdump_emacs);\n#endif\n#endif /* not CANNOT_DUMP */\n\n  defsubr (&Skill_emacs);\n\n  DEFVAR_LISP (\"command-line-args\", &Vcommand_line_args,\n    \"Args passed by shell to Emacs, as a list of strings.\");\n\n  DEFVAR_LISP (\"system-type\", &Vsystem_type,\n    \"Symbol indicating type of operating system you are using.\");\n  Vsystem_type = intern (SYSTEM_TYPE);\n\n  DEFVAR_BOOL (\"noninteractive\", &noninteractive1,\n    \"Non-nil means Emacs is running without interactive terminal.\");\n\n  Vkill_emacs_hook = Qnil;\n\n  DEFVAR_LISP (\"kill-emacs-hook\", &Vkill_emacs_hook,\n    \"Function called, if non-nil, whenever kill-emacs is called.\");\n}\n",
    "342bcb7ae276c1ef948a36939ca0376b": "/* Fundamental definitions for GNU Emacs Lisp interpreter.\n   Copyright (C) 1985, 1986, 1987 Free Software Foundation, Inc.\n\nThis file is part of GNU Emacs.\n\nGNU Emacs is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 1, or (at your option)\nany later version.\n\nGNU Emacs is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GNU Emacs; see the file COPYING.  If not, write to\nthe Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n\n\n/* Define the fundamental Lisp data structures */\n\n/* This is the set of Lisp data types */\n\nenum Lisp_Type\n  {\n    /* Integer.  object.v.integer is the integer value. */\n    Lisp_Int,\n\n    /* Symbol.  object.v.symbol points to a struct Lisp_Symbol. */\n    Lisp_Symbol,\n\n    /* Marker (editor pointer).  object.v.marker points to a struct Lisp_Marker. */\n    Lisp_Marker,\n\n    /* String.  object.v.string points to a struct Lisp_String.\n       The length of the string, and its contents, are stored therein. */\n    Lisp_String,\n\n    /* Vector of Lisp objects.  object.v.vector points to a struct Lisp_Vector.\n       The length of the vector, and its contents, are stored therein. */\n    Lisp_Vector,\n\n    /* Cons.  object.v.cons points to a struct Lisp_Cons. */\n    Lisp_Cons,\n\n    /* >>> No longer used */\n    Lisp_Object_Unused_1,\n#if 0\n    was...\n    /* Treated like vector in GC, except do not set its mark bit.\n       Used for internal data blocks that will be explicitly freed\n       but which, while active, are reached by GC mark exactly once\n       and should be marked through like a vector.  */\n    Lisp_Temp_Vector,\n#endif /* 0 */\n\n    /* Editor buffer.  obj.v.buffer points to a struct buffer.\n       No buffer is ever truly freed; they can be \"killed\", but this\n       just marks them as dead. */\n    Lisp_Buffer,\n\n    /* Built-in function.  obj.v.subr points to a struct Lisp_Subr\n       which describes how to call the function, and its documentation,\n       as well as pointing to the code. */\n    Lisp_Subr,\n\n    /* Internal value return by subroutines of read.\n       The user never sees this data type.\n       Its value is just a number. */\n    Lisp_Internal,\n\n    /* Forwarding pointer to an int variable.\n       This is allowed only in the value cell of a symbol,\n       and it means that the symbol's value really lives in the\n       specified int variable.\n       obj.v.intptr points to the int variable. */\n    Lisp_Intfwd,\n\n    /* Boolean forwarding pointer to an int variable.\n       This is like Lisp_Intfwd except that the ostensible \"value\" of the symbol\n       is t if the int variable is nonzero, nil if it is zero.\n       obj.v.intptr points to the int variable. */\n    Lisp_Boolfwd,\n\n    /* Object describing a connection to a subprocess.\n       It points to storage of type  struct Lisp_Process  */\n    Lisp_Process,\n\n    /* Forwarding pointer to a Lisp_Object variable.\n       This is allowed only in the value cell of a symbol,\n       and it means that the symbol's value really lives in the\n       specified variable.\n       obj.v.objfwd points to the Lisp_Object variable. */\n    Lisp_Objfwd,\n\n      /* was Lisp_Internal */\n    Lisp_Object_Unused_2,\n\n    /* Used when a FILE * value needs to be passed\n       in an argument of type Lisp_Object.\n       You must do (FILE *) obj.v.integer to get the value.\n       The user will never see this data type. */\n    Lisp_Internal_Stream,\n\n    /* Used in a symbol value cell when the symbol's value is per-buffer.\n        The actual contents are a cons cell which starts a list like this:\n        (REALVALUE BUFFER CURRENT-ALIST-ELEMENT . DEFAULT-VALUE)).\n\n\tBUFFER is the last buffer for which this symbol's value was\n\tmade up to date.\n\n        CURRENT-ALIST-ELEMENT is a pointer to an element of BUFFER's\n\tb_local_var_alist, that being the element whose car is this variable.\n        Or it can be a pointer to the (CURRENT-ALIST-ELEMENT . DEFAULT-VALUE), if BUFFER\n\tdoes not have an element in its alist for this variable\n\t(that is, if BUFFER sees the default value of this variable).\n\n\tIf we want to examine or set the value and BUFFER is current,\n\twe just examine or set REALVALUE.\n\tIf BUFFER is not current, we store the current REALVALUE value into\n\tCURRENT-ALIST-ELEMENT, then find the appropriate alist element for\n\tthe buffer now current and set up CURRENT-ALIST-ELEMENT.\n\tThen we set REALVALUE out of that element, and store into BUFFER.\n\n\tIf we are setting the variable and the current buffer does not have\n\tan alist entry for this variable, an alist entry is created.\n\n\tNote that REALVALUE can be a forwarding pointer.\n\tEach time it is examined or set, forwarding must be done.  */\n    Lisp_Buffer_Local_Value,\n\n    /* Like Lisp_Buffer_Local_Value with one difference:\n\tmerely setting the variable while some buffer is current\n\tdoes not cause that buffer to have its own local value of this variable.\n\tOnly make-local-variable does that.  */\n    Lisp_Some_Buffer_Local_Value,\n\n\n    /* Like Lisp_Objfwd except that value lives in a slot\n       in the current buffer.  Value is byte index of slot within buffer */\n    Lisp_Buffer_Objfwd,\n\n    /* In symbol value cell, means var is unbound.\n       In symbol function cell, means function name is undefined. */\n    Lisp_Void,\n\n    /* Window used for Emacs display.\n       Data inside looks like a Lisp_Vector.  */\n    Lisp_Window,\n\n    /* Used by save,set,restore-window-configuration */\n    Lisp_Window_Configuration\n  };\n\n#ifndef NO_UNION_TYPE\n\n#ifndef BIG_ENDIAN\n\n/* Definition of Lisp_Object for little-endian machines.  */\n\ntypedef\nunion Lisp_Object\n  {\n    /* Used for comparing two Lisp_Objects;\n       also, positive integers can be accessed fast this way. */\n    int i;\n\n    struct\n      {\n\tint val: 24;\n\tchar type;\n      } s;\n    struct\n      {\n\tunsigned int val: 24;\n\tchar type;\n      } u;\n    struct\n      {\n\tunsigned int val: 24;\n\tenum Lisp_Type type: 7;\n\t/* The markbit is not really part of the value of a Lisp_Object,\n\t   and is always zero except during garbage collection.  */\n\tunsigned int markbit: 1;\n      } gu;\n  }\nLisp_Object;\n\n#else /* If BIG_ENDIAN */\n\ntypedef\nunion Lisp_Object\n  {\n    /* Used for comparing two Lisp_Objects;\n       also, positive integers can be accessed fast this way. */\n    int i;\n\n    struct\n      {\n\tchar type;\n\tint val: 24;\n      } s;\n    struct\n      {\n\tchar type;\n\tunsigned int val: 24;\n      } u;\n    struct\n      {\n\t/* The markbit is not really part of the value of a Lisp_Object,\n\t   and is always zero except during garbage collection.  */\n\tunsigned int markbit: 1;\n\tenum Lisp_Type type: 7;\n\tunsigned int val: 24;\n      } gu;\n  }\nLisp_Object;\n\n#endif /* BIG_ENDIAN */\n\n#endif /* NO_UNION_TYPE */\n\n\n/* If union type is not wanted, define Lisp_Object as just a number\n   and define the macros below to extract fields by shifting */\n\n#ifdef NO_UNION_TYPE\n\n#define Lisp_Object int\n\n/* These values are overridden by the m- file on some machines.  */\n#ifndef VALBITS\n#define VALBITS 24\n#endif\n\n#ifndef GCTYPEBITS\n#define GCTYPEBITS 7\n#endif\n\n#ifndef VALMASK\n#define VALMASK ((1<<VALBITS) - 1)\n#endif\n#define GCTYPEMASK ((1<<GCTYPEBITS) - 1)\n#define MARKBIT (1 << (VALBITS + GCTYPEBITS))\n\n#endif /* NO_UNION_TYPE */\n\f\n/* These macros extract various sorts of values from a Lisp_Object.\n For example, if tem is a Lisp_Object whose type is Lisp_Cons,\n XCONS (tem) is the struct Lisp_Cons * pointing to the memory for that cons. */\n\n#ifdef NO_UNION_TYPE\n\n/* One need to override this if there must be high bits set in data space\n   (doing the result of the below & ((1 << (GCTYPE + 1)) - 1) would work\n    on all machines, but would penalise machines which don't need it)\n */\n#ifndef XTYPE\n#define XTYPE(a) ((enum Lisp_Type) ((a) >> VALBITS))\n#endif\n\n#ifndef XSETTYPE\n#define XSETTYPE(a, b) ((a)  =  XUINT (a) | ((int)(b) << VALBITS))\n#endif\n\n/* Use XFASTINT for fast retrieval and storage of integers known\n  to be positive.  This takes advantage of the fact that Lisp_Int is 0.  */\n#define XFASTINT(a) (a)\n\n/* Extract the value of a Lisp_Object as a signed integer.  */\n\n#ifndef XINT   /* Some machines need to do this differently.  */\n#define XINT(a) (((a) << (INTBITS-VALBITS)) >> (INTBITS-VALBITS))\n#endif\n\n/* Extract the value as an unsigned integer.  This is a basis\n   for exctacting it as a pointer to a structure in storage.  */\n\n#ifndef XUINT\n#define XUINT(a) ((a) & VALMASK)\n#endif\n\n#ifdef HAVE_SHM\n/* In this representation, data is found in two widely separated segments.  */\n#define XPNTR(a) \\\n  (XUINT (a) | (XUINT (a) > PURESIZE ? DATA_SEG_BITS : PURE_SEG_BITS))\n#else /* not HAVE_SHM */\n#ifdef DATA_SEG_BITS\n/* This case is used for the rt-pc.\n   In the diffs I was given, it checked for ptr = 0\n   and did not adjust it in that case.\n   But I don't think that zero should ever be found\n   in a Lisp object whose data type says it points to something.  */\n#define XPNTR(a) (XUINT (a) | DATA_SEG_BITS)\n#else /* not DATA_SEG_BITS */\n#define XPNTR(a) XUINT (a)\n#endif\n#endif /* not HAVE_SHM */\n\n#ifndef XSETINT\n#define XSETINT(a, b)  ((a) = ((a) & ~VALMASK) |  ((b) & VALMASK))\n#endif\n\n#ifndef XSETUINT\n#define XSETUINT(a, b) XSETINT (a, b)\n#endif\n\n#ifndef XSETPNTR\n#define XSETPNTR(a, b) XSETINT (a, b)\n#endif\n\n#ifndef XSET\n#define XSET(var, type, ptr) \\\n   ((var) = ((int)(type) << VALBITS) + ((int) (ptr) & VALMASK))\n#endif\n\n/* During garbage collection, XGCTYPE must be used for extracting types\n so that the mark bit is ignored.  XMARKBIT access the markbit.\n Markbits are used only in particular slots of particular structure types.\n Other markbits are always zero.\n Outside of garbage collection, all mark bits are always zero.  */\n\n#ifndef XGCTYPE\n#define XGCTYPE(a) ((enum Lisp_Type) (((a) >> VALBITS) & GCTYPEMASK))\n#endif\n\n/* In version 19, try \n#if VALBITS + GCTYPEBITS == INTBITS - 1\n#define XMARKBIT(a) ((a) < 0)\n#define XSETMARKBIT(a,b) ((a) = ((a) & ~MARKBIT) | ((b) ? MARKBIT : 0))\n*/\n\n#ifndef XMARKBIT\n#define XMARKBIT(a) ((a) & MARKBIT)\n#endif\n\n#ifndef XSETMARKBIT\n#define XSETMARKBIT(a,b) ((a) = ((a) & ~MARKBIT) | (b))\n#endif\n\n#ifndef XMARK\n#define XMARK(a) ((a) |= MARKBIT)\n#endif\n\n#ifndef XUNMARK\n#define XUNMARK(a) ((a) &= ~MARKBIT)\n#endif\n\n#endif /* NO_UNION_TYPE */\n\n#ifndef NO_UNION_TYPE\n\n#define XTYPE(a) ((enum Lisp_Type) (a).u.type)\n#define XSETTYPE(a, b) ((a).u.type = (char) (b))\n\n/* Use XFASTINT for fast retrieval and storage of integers known\n  to be positive.  This takes advantage of the fact that Lisp_Int is 0.  */\n#define XFASTINT(a) ((a).i)\n\n#ifdef EXPLICIT_SIGN_EXTEND\n/* Make sure we sign-extend; compilers have been known to fail to do so.  */\n#define XINT(a) (((a).i << 8) >> 8)\n#else\n#define XINT(a) ((a).s.val)\n#endif /* EXPLICIT_SIGN_EXTEND */\n\n#define XUINT(a) ((a).u.val)\n#define XPNTR(a) ((a).u.val)\n#define XSETINT(a, b) ((a).s.val = (int) (b))\n#define XSETUINT(a, b) ((a).s.val = (int) (b))\n#define XSETPNTR(a, b) ((a).s.val = (int) (b))\n\n#define XSET(var, vartype, ptr) \\\n   (((var).s.type = ((char) (vartype))), ((var).s.val = ((int) (ptr))))\n\n/* During garbage collection, XGCTYPE must be used for extracting types\n so that the mark bit is ignored.  XMARKBIT access the markbit.\n Markbits are used only in particular slots of particular structure types.\n Other markbits are always zero.\n Outside of garbage collection, all mark bits are always zero.  */\n\n#define XGCTYPE(a) ((a).gu.type)\n#define XMARKBIT(a) ((a).gu.markbit)\n#define XSETMARKBIT(a,b) (XMARKBIT(a) = (b))\n#define XMARK(a) (XMARKBIT(a) = 1)\n#define XUNMARK(a) (XMARKBIT(a) = 0)\n\n#endif /* NO_UNION_TYPE */\n\n\n#define XCONS(a) ((struct Lisp_Cons *) XPNTR(a))\n#define XBUFFER(a) ((struct buffer *) XPNTR(a))\n#define XVECTOR(a) ((struct Lisp_Vector *) XPNTR(a))\n#define XSUBR(a) ((struct Lisp_Subr *) XPNTR(a))\n#define XSTRING(a) ((struct Lisp_String *) XPNTR(a))\n#define XSYMBOL(a) ((struct Lisp_Symbol *) XPNTR(a))\n#define XFUNCTION(a) ((Lisp_Object (*)()) XPNTR(a))\n#define XMARKER(a) ((struct Lisp_Marker *) XPNTR(a))\n#define XOBJFWD(a) ((Lisp_Object *) XPNTR(a))\n#define XINTPTR(a) ((int *) XPNTR(a))\n#define XWINDOW(a) ((struct window *) XPNTR(a))\n#define XPROCESS(a) ((struct Lisp_Process *) XPNTR(a))\n\n#define XSETCONS(a, b) XSETPNTR(a, (int) (b))\n#define XSETBUFFER(a, b) XSETPNTR(a, (int) (b))\n#define XSETVECTOR(a, b) XSETPNTR(a, (int) (b))\n#define XSETSUBR(a, b) XSETPNTR(a, (int) (b))\n#define XSETSTRING(a, b) XSETPNTR(a, (int) (b))\n#define XSETSYMBOL(a, b) XSETPNTR(a, (int) (b))\n#define XSETFUNCTION(a, b) XSETPNTR(a, (int) (b))\n#define XSETMARKER(a, b) XSETPNTR(a, (int) (b))\n#define XSETOBJFWD(a, b) XSETPNTR(a, (int) (b))\n#define XSETINTPTR(a, b) XSETPNTR(a, (int) (b))\n#define XSETWINDOW(a, b) XSETPNTR(a, (int) (b))\n#define XSETPROCESS(a, b) XSETPNTR(a, (int) (b))\n\f\n/* In a cons, the markbit of the car is the gc mark bit */\n\nstruct Lisp_Cons\n  {\n    Lisp_Object car, cdr;\n  };\n\n/* Like a cons, but records info on where the text lives that it was read from */\n/* This is not really in use now */\n\nstruct Lisp_Buffer_Cons\n  {\n    Lisp_Object car, cdr;\n    struct buffer *buffer;\n    int bufpos;\n  };\n\n/* In a string or vector, the sign bit of the `size' is the gc mark bit */\n\nstruct Lisp_String\n  {\n    int size;\n    unsigned char data[1];\n  };\n\nstruct Lisp_Vector\n  {\n    int size;\n    struct Lisp_Vector *next;\n    Lisp_Object contents[1];\n  };\n\n/* In a symbol, the markbit of the plist is used as the gc mark bit */\n\nstruct Lisp_Symbol\n  {\n    struct Lisp_String *name;\n    Lisp_Object value;\n    Lisp_Object function;\n    Lisp_Object plist;\n    struct Lisp_Symbol *next;\t/* -> next symbol in this obarray bucket */\n  };\n\nstruct Lisp_Subr\n  {\n    Lisp_Object (*function) ();\n    short min_args, max_args;\n    char *symbol_name;\n    char *prompt;\n    char *doc;\n  };\n\n/* In a marker, the markbit of the chain field is used as the gc mark bit */\n\nstruct Lisp_Marker\n  {\n    struct buffer *buffer;\n    Lisp_Object chain;\n    int bufpos;\n  };\n\f\n/* Data type checking */\n\n#ifdef NULL\n#undef NULL\n#endif\n#define NULL(x)  (XFASTINT (x) == XFASTINT (Qnil))\n/* #define LISTP(x) (XTYPE ((x)) == Lisp_Cons)*/\n#define CONSP(x) (XTYPE ((x)) == Lisp_Cons)\n#define EQ(x, y) (XFASTINT (x) == XFASTINT (y))\n\n#define CHECK_LIST(x, i) \\\n  { if ((XTYPE ((x)) != Lisp_Cons) && !NULL (x)) x = wrong_type_argument (Qlistp, (x)); }\n\n#define CHECK_STRING(x, i) \\\n  { if (XTYPE ((x)) != Lisp_String) x = wrong_type_argument (Qstringp, (x)); }\n\n#define CHECK_CONS(x, i) \\\n  { if (XTYPE ((x)) != Lisp_Cons) x = wrong_type_argument (Qconsp, (x)); }\n\n#define CHECK_SYMBOL(x, i) \\\n  { if (XTYPE ((x)) != Lisp_Symbol) x = wrong_type_argument (Qsymbolp, (x)); }\n\n#define CHECK_VECTOR(x, i) \\\n  { if (XTYPE ((x)) != Lisp_Vector) x = wrong_type_argument (Qvectorp, (x)); }\n\n#define CHECK_BUFFER(x, i) \\\n  { if (XTYPE ((x)) != Lisp_Buffer) x = wrong_type_argument (Qbufferp, (x)); }\n\n#define CHECK_WINDOW(x, i) \\\n  { if (XTYPE ((x)) != Lisp_Window) x = wrong_type_argument (Qwindowp, (x)); }\n\n#define CHECK_PROCESS(x, i) \\\n  { if (XTYPE ((x)) != Lisp_Process) x = wrong_type_argument (Qprocessp, (x)); }\n\n#define CHECK_NUMBER(x, i) \\\n  { if (XTYPE ((x)) != Lisp_Int) x = wrong_type_argument (Qintegerp, (x)); }\n\n#define CHECK_MARKER(x, i) \\\n  { if (XTYPE ((x)) != Lisp_Marker) x = wrong_type_argument (Qmarkerp, (x)); }\n\n#define CHECK_NUMBER_COERCE_MARKER(x, i) \\\n  { if (XTYPE ((x)) == Lisp_Marker) XFASTINT (x) = marker_position (x); \\\n    else if (XTYPE ((x)) != Lisp_Int) x = wrong_type_argument (Qinteger_or_marker_p, (x)); }\n\n#ifdef VIRT_ADDR_VARIES\n\n/* For machines like APOLLO where text and data can go anywhere\n   in virtual memory.  */\n#define CHECK_IMPURE(obj) \\\n  { extern int pure[]; \\\n    if ((PNTR_COMPARISON_TYPE) XPNTR (obj) < (PNTR_COMPARISON_TYPE) ((char *) pure + PURESIZE) \\\n\t&& (PNTR_COMPARISON_TYPE) XPNTR (obj) >= (PNTR_COMPARISON_TYPE) pure) \\\n      pure_write_error (); }\n\n#else /* not VIRT_ADDR_VARIES */\n#ifdef PNTR_COMPARISON_TYPE\n\n/* when PNTR_COMPARISON_TYPE is not the default (unsigned int) */\n#define CHECK_IMPURE(obj) \\\n  { extern int my_edata; \\\n    if ((PNTR_COMPARISON_TYPE) XPNTR (obj) < (PNTR_COMPARISON_TYPE) &my_edata) \\\n      pure_write_error (); }\n\n#else /* not VIRT_ADDRESS_VARIES, not PNTR_COMPARISON_TYPE */\n\n#define CHECK_IMPURE(obj) \\\n  { extern int my_edata; \\\n    if (XPNTR (obj) < (unsigned int) &my_edata) \\\n      pure_write_error (); }\n\n#endif /* PNTR_COMPARISON_TYPE */\n#endif /* VIRT_ADDRESS_VARIES */\n\n/* Cast pointers to this type to compare them.  Some machines want int.  */\n#ifndef PNTR_COMPARISON_TYPE\n#define PNTR_COMPARISON_TYPE unsigned int\n#endif\n\f\n/* Define a built-in function for calling from Lisp.\n `lname' should be the name to give the function in Lisp,\n    as a null-terminated C string.\n `fnname' should be the name of the function in C.\n    By convention, it starts with F.\n `sname' should be the name for the C constant structure\n    that records information on this function for internal use.\n    By convention, it should be the same as `fnname' but with S instead of F.\n    It's too bad that C macros can't compute this from `fnname'.\n `minargs' should be a number, the minimum number of arguments allowed.\n `maxargs' should be a number, the maximum number of arguments allowed,\n    or else MANY or UNEVALLED.\n    MANY means pass a vector of evaluated arguments,\n\t in the form of an integer number-of-arguments\n\t followed by the address of a vector of Lisp_Objects\n\t which contains the argument values.\n    UNEVALLED means pass the list of unevaluated arguments\n `prompt' says how to read arguments for an interactive call.\n    This can be zero or a C string.\n    Zero means that interactive calls are not allowed.\n    A string is interpreted in a hairy way:\n     it should contain one line for each argument to be read, terminated by \\n.\n     The first character of the line controls the type of parsing:\n       s  --  read a string.\n       S  --  read a symbol.\n       k  --  read a key sequence and return it as a string.\n       a  --  read a function name (symbol) with completion.\n       C  --  read a command name (symbol) with completion.\n       v  --  read a variable name (symbol) with completion.\n       b  --  read a buffer name (a string) with completion.\n       B  --  buffer name, may be existing buffer or may not be.\n       f  --  read a file name, file must exist.\n       F  --  read a file name, file need not exist.\n       n  --  read a number.\n       c  --  read a character and return it as a number.\n       p  --  use the numeric value of the prefix argument.\n       P  --  use raw value of prefix - can be nil, -, (NUMBER) or NUMBER.\n       x  --  read a Lisp object from the minibuffer.\n       X  --  read a Lisp form from the minibuffer and use its value.\n    A null string means call interactively with no arguments.\n `doc' is documentation for the user.\n*/\n\n#define DEFUN(lname, fnname, sname, minargs, maxargs, prompt, doc) \\\n  Lisp_Object fnname (); \\\n  struct Lisp_Subr sname = {fnname, minargs, maxargs, lname, prompt, 0}; \\\n  Lisp_Object fnname\n\n/* defsubr (Sname);\n is how we define the symbol for function `name' at start-up time. */\nextern void defsubr ();\n\n#define MANY -2\n#define UNEVALLED -1\n\n/* Macros we use to define forwarded Lisp variables.\n   These are used in the syms_of_FILENAME functions.  */\n\n#define DEFVARLISP(lname, vname, doc) defvar_lisp (lname, vname)\n#define DEFVARBOOL(lname, vname, doc) defvar_bool (lname, vname)\n#define DEFVARINT(lname, vname, doc) defvar_int (lname, vname)\n#define DEFVARPERBUFFER(lname, vname, doc)  \\\n defvar_per_buffer (lname, vname, 0)\n\n#define DEFVAR_LISP(lname, vname, doc) defvar_lisp (lname, vname)\n#define DEFVAR_LISP_NOPRO(lname, vname, doc) defvar_lisp_nopro (lname, vname)\n#define DEFVAR_BOOL(lname, vname, doc) defvar_bool (lname, vname)\n#define DEFVAR_INT(lname, vname, doc) defvar_int (lname, vname)\n#define DEFVAR_PER_BUFFER(lname, vname, doc)  \\\n defvar_per_buffer (lname, vname, 0)\n\f\n/* Structure for recording Lisp call stack for backtrace purposes */\n\nstruct specbinding\n  {\n    Lisp_Object symbol, old_value;\n    Lisp_Object (*func) ();\n    Lisp_Object unused;\t\t/* Dividing by 16 is faster than by 12 */\n  };\n\nextern struct specbinding *specpdl;\nextern struct specbinding *specpdl_ptr;\nextern int specpdl_size;\n\nstruct handler\n  {\n    Lisp_Object handler;\n    Lisp_Object var;\n    int poll_suppress_count;\t/* No error should exit a piece of code\n\t\t\t\t   in which polling is suppressed.  */\n    struct catchtag *tag;\n    struct handler *next;\n  };\n\nextern struct handler *handlerlist;\n\n/* Check quit-flag and quit if it is non-nil. */\n\n#define QUIT \\\n  if (!NULL (Vquit_flag) && NULL (Vinhibit_quit)) \\\n    { Vquit_flag = Qnil; Fsignal (Qquit, Qnil); }\n\n/* Nonzero if ought to quit now.  */\n\n#define QUITP (!NULL (Vquit_flag) && NULL (Vinhibit_quit))\n\f\n/* 1 if CH is upper case.  */\n\n#define UPPERCASEP(CH) (downcase_table[CH] != (CH))\n\n/* 1 if CH is lower case.  */\n\n#define LOWERCASEP(CH)   \\\n (downcase_table[CH] == (CH) && downcase_table[0400 + (CH)] != (CH))\n\n/* 1 if CH is neither upper nor lower case.  */\n\n#define NOCASEP(CH) (downcase_table[0400 + (CH)] == (CH))\n\n/* Upcase a character, or make no change if that cannot be done.  */\n\n#define UPCASE(CH) (downcase_table[CH] == (CH) ? UPCASE1 (CH) : (CH))\n\n/* Upcase a character known to be not upper case.  */\n\n#define UPCASE1(CH) downcase_table[0400 + (CH)]\n\n/* Downcase a character, or make no change if that cannot be done. */\n\n#define DOWNCASE(CH) downcase_table[CH]\n\f\n/* number of bytes of structure consed since last GC */\n\nextern int consing_since_gc;\n\n/* threshold for doing another gc */\n\nextern int gc_cons_threshold;\n\n/* value of consing_since_gc when undos were last truncated.  */\n\nextern int consing_at_last_truncate;\n\n/* Structure for recording stack slots that need marking */\n\n/* This is a chain of structures, each of which points at a Lisp_Object variable\n whose value should be marked in garbage collection.\n Normally every link of the chain is an automatic variable of a function,\n and its `val' points to some argument or local variable of the function.\n On exit to the function, the chain is set back to the value it had on entry.\n This way, no link remains in the chain when the stack frame containing the link disappears.\n\n Every function that can call Feval must protect in this fashion all\n Lisp_Object variables whose contents will be used again. */\n\nextern struct gcpro *gcprolist;\n\nstruct gcpro\n  {\n    struct gcpro *next;\n    Lisp_Object *var;\t\t/* Address of first protected variable */\n    int nvars;\t\t\t/* Number of consecutive protected variables */\n  };\n\n#define GCPRO1(varname) \\\n {gcpro1.next = gcprolist; gcpro1.var = &varname; gcpro1.nvars = 1; \\\n  gcprolist = &gcpro1; }\n\n#define GCPRO2(varname1, varname2) \\\n {gcpro1.next = gcprolist; gcpro1.var = &varname1; gcpro1.nvars = 1; \\\n  gcpro2.next = &gcpro1; gcpro2.var = &varname2; gcpro2.nvars = 1; \\\n  gcprolist = &gcpro2; }\n\n#define GCPRO3(varname1, varname2, varname3) \\\n {gcpro1.next = gcprolist; gcpro1.var = &varname1; gcpro1.nvars = 1; \\\n  gcpro2.next = &gcpro1; gcpro2.var = &varname2; gcpro2.nvars = 1; \\\n  gcpro3.next = &gcpro2; gcpro3.var = &varname3; gcpro3.nvars = 1; \\\n  gcprolist = &gcpro3; }\n\n#define GCPRO4(varname1, varname2, varname3, varname4) \\\n {gcpro1.next = gcprolist; gcpro1.var = &varname1; gcpro1.nvars = 1; \\\n  gcpro2.next = &gcpro1; gcpro2.var = &varname2; gcpro2.nvars = 1; \\\n  gcpro3.next = &gcpro2; gcpro3.var = &varname3; gcpro3.nvars = 1; \\\n  gcpro4.next = &gcpro3; gcpro4.var = &varname4; gcpro4.nvars = 1; \\\n  gcprolist = &gcpro4; }\n\n/* Call staticpro (&var) to protect static variable `var'. */\n\nvoid staticpro();\n  \n#define UNGCPRO (gcprolist = gcpro1.next)\n\f\n/* Defined in data.c */\nextern Lisp_Object Qnil, Qt, Qquote, Qlambda, Qsubr, Qunbound;\nextern Lisp_Object Qerror_conditions, Qerror_message, Qtop_level;\nextern Lisp_Object Qerror, Qquit, Qwrong_type_argument, Qargs_out_of_range;\nextern Lisp_Object Qvoid_variable, Qvoid_function;\nextern Lisp_Object Qsetting_constant, Qinvalid_read_syntax;\nextern Lisp_Object Qinvalid_function, Qwrong_number_of_arguments, Qno_catch;\nextern Lisp_Object Qend_of_file, Qarith_error;\nextern Lisp_Object Qbeginning_of_buffer, Qend_of_buffer, Qbuffer_read_only;\n\nextern Lisp_Object Qintegerp, Qnatnump, Qsymbolp, Qlistp, Qconsp;\nextern Lisp_Object Qstringp, Qarrayp, Qsequencep, Qbufferp;\nextern Lisp_Object Qchar_or_string_p, Qmarkerp, Qvectorp;\nextern Lisp_Object Qinteger_or_marker_p, Qboundp, Qfboundp;\nextern Lisp_Object Qcdr;\n\nextern Lisp_Object Feq (), Fnull (), Flistp (), Fconsp (), Fatom (), Fnlistp ();\nextern Lisp_Object Fintegerp (), Fnatnump (), Fsymbolp ();\nextern Lisp_Object Fvectorp (), Fstringp (), Farrayp (), Fsequencep ();\nextern Lisp_Object Fbufferp (), Fmarkerp (), Fsubrp (), Fchar_or_string_p ();\nextern Lisp_Object Finteger_or_marker_p ();\n\nextern Lisp_Object Fcar (), Fcar_safe(), Fcdr (), Fcdr_safe();\nextern Lisp_Object Fsetcar (), Fsetcdr ();\nextern Lisp_Object Fboundp (), Ffboundp (), Fmakunbound (), Ffmakunbound ();\nextern Lisp_Object Fsymbol_function (), Fsymbol_plist (), Fsymbol_name ();\nextern Lisp_Object Ffset (), Fsetplist ();\nextern Lisp_Object Fsymbol_value (), Fset ();\nextern Lisp_Object Fdefault_value (), Fset_default ();\n\nextern Lisp_Object Faref (), Faset (), Farray_length ();\n\nextern Lisp_Object Fstring_to_int (), Fint_to_string ();\nextern Lisp_Object Feqlsign (), Fgtr (), Flss (), Fgeq (), Fleq (), Fneq (), Fzerop ();\nextern Lisp_Object Fplus (), Fminus (), Ftimes (), Fquo (), Frem (), Fmax (), Fmin ();\nextern Lisp_Object Flogand (), Flogior (), Flogxor (), Flognot (), Flsh (), Fash ();\nextern Lisp_Object Fadd1 (), Fsub1 ();\n\nextern Lisp_Object make_number ();\nextern void args_out_of_range ();\nextern void args_out_of_range_3 ();\nextern Lisp_Object wrong_type_argument ();\n\n/* Defined in fns.c */\nextern Lisp_Object Qstring_lessp;\nextern Lisp_Object Vfeatures;\nextern Lisp_Object Fidentity (), Frandom ();\nextern Lisp_Object Flength ();\nextern Lisp_Object Fappend (), Fconcat (), Fvconcat (), Fcopy_sequence ();\nextern Lisp_Object Fsubstring ();\nextern Lisp_Object Fnthcdr (), Fmemq (), Fassq (), Fassoc ();\nextern Lisp_Object Frassq (), Fdelq (), Fsort ();\nextern Lisp_Object Freverse (), Fnreverse (), Fget (), Fput (), Fequal ();\nextern Lisp_Object Ffillarray (), Fnconc (), Fmapcar (), Fmapconcat ();\nextern Lisp_Object Fy_or_n_p (), Fyes_or_no_p ();\nextern Lisp_Object Ffeaturep (), Frequire () , Fprovide ();\nextern Lisp_Object concat2 (), nconc2 ();\nextern Lisp_Object assq_no_quit ();\n\n/* Defined in alloc.c */\nextern Lisp_Object Vpurify_flag;\nextern Lisp_Object Fcons (), Flist(), Fmake_list ();\nextern Lisp_Object Fmake_vector (), Fvector (), Fmake_symbol (), Fmake_marker ();\nextern Lisp_Object Fmake_string (), build_string (), make_string();\nextern Lisp_Object Fpurecopy (), make_pure_string ();\nextern Lisp_Object pure_cons (), make_pure_vector ();\nextern Lisp_Object Fgarbage_collect ();\n\n/* Defined in print.c */\nextern Lisp_Object Vprin1_to_string_buffer;\nextern Lisp_Object Fprin1 (), Fprin1_to_string (), Fprinc ();\nextern Lisp_Object Fterpri (), Fprint ();\nextern Lisp_Object Vstandard_output, Qstandard_output;\nextern temp_output_buffer_setup (), temp_output_buffer_show ();\n\n/* Defined in lread.c */\nextern Lisp_Object Qvariable_documentation, Qstandard_input;\nextern Lisp_Object Vobarray, Vstandard_input;\nextern Lisp_Object Fread (), Fread_from_string ();\nextern Lisp_Object Fintern (), Fintern_soft (), Fload ();\nextern Lisp_Object Fget_file_char (), Fread_char ();\nextern Lisp_Object Feval_current_buffer (), Feval_region ();\nextern Lisp_Object intern (), oblookup ();\n\n/* Defined in eval.c */\nextern Lisp_Object Qautoload, Qexit, Qinteractive, Qcommandp, Qdefun, Qmacro;\nextern Lisp_Object Vinhibit_quit, Vquit_flag, Qinhibit_quit;\nextern Lisp_Object Vmocklisp_arguments, Qmocklisp, Qmocklisp_arguments;\nextern Lisp_Object Vautoload_queue;\nextern Lisp_Object Fand (), For (), Fif (), Fprogn (), Fprog1 (), Fprog2 ();\nextern Lisp_Object Fsetq (), Fquote ();\nextern Lisp_Object Fuser_variable_p (), Finteractive_p ();\nextern Lisp_Object Fdefun (), Flet (), FletX (), Fwhile ();\nextern Lisp_Object Fcatch (), Fthrow (), Funwind_protect ();\nextern Lisp_Object Fcondition_case (), Fsignal ();\nextern Lisp_Object Ffunction_type (), Fautoload (), Fcommandp ();\nextern Lisp_Object Feval (), Fapply (), Ffuncall ();\nextern Lisp_Object Fglobal_set (), Fglobal_value (), Fbacktrace ();\nextern Lisp_Object apply1 (), call0 (), call1 (), call2 (), call3 ();\nextern Lisp_Object apply_lambda ();\nextern Lisp_Object internal_catch ();\nextern Lisp_Object internal_condition_case ();\nextern void unbind_to ();\nextern void error ();\nextern Lisp_Object un_autoload ();\n\n/* Defined in editfns.c */\nextern Lisp_Object Vprefix_arg, Qminus, Vcurrent_prefix_arg;\nextern Lisp_Object Fgoto_char ();\nextern Lisp_Object Fpoint_min_marker (), Fpoint_max_marker ();\nextern Lisp_Object Fpoint_min (), Fpoint_max ();\nextern Lisp_Object Fpoint (), Fpoint_marker (), Fmark_marker ();\nextern Lisp_Object Ffollchar (), Fprevchar (), Fchar_after (), Finsert ();\nextern Lisp_Object Feolp (), Feobp (), Fbolp (), Fbobp ();\nextern Lisp_Object Fformat (), format1 ();\nextern Lisp_Object Fbuffer_substring (), Fbuffer_string ();\nextern Lisp_Object Fstring_equal (), Fstring_lessp (), Fbuffer_substring_lessp ();\nextern Lisp_Object save_excursion_save (), save_restriction_save ();\nextern Lisp_Object save_excursion_restore (), save_restriction_restore ();\nextern Lisp_Object Fchar_to_string ();\n\n/* defined in buffer.c */\nextern Lisp_Object Vbuffer_alist;\nextern Lisp_Object Fget_buffer (), Fget_buffer_create (), Fset_buffer ();\nextern Lisp_Object Fbarf_if_buffer_read_only ();\nextern Lisp_Object Fcurrent_buffer (), Fswitch_to_buffer (), Fpop_to_buffer ();\nextern Lisp_Object Fother_buffer ();\nextern struct buffer *all_buffers;\n\n/* defined in marker.c */\n\nextern Lisp_Object Fmarker_position (), Fmarker_buffer ();\nextern Lisp_Object Fcopy_marker ();\n\n/* Defined in fileio.c */\n\nextern Lisp_Object Qfile_error;\nextern Lisp_Object Ffile_name_as_directory ();\nextern Lisp_Object Fexpand_file_name (), Ffile_name_nondirectory ();\nextern Lisp_Object Fsubstitute_in_file_name ();\nextern Lisp_Object Ffile_symlink_p ();\n\n/* Defined in abbrev.c */\n\nextern Lisp_Object Vfundamental_mode_abbrev_table;\n\n/* defined in search.c */\nextern unsigned char downcase_table[];\nextern Lisp_Object Fstring_match ();\nextern Lisp_Object Fscan_buffer ();\n\n/* defined in minibuf.c */\n\nextern Lisp_Object last_minibuf_string, Vminibuffer_list;\nextern Lisp_Object read_minibuf (), Fcompleting_read ();\nextern Lisp_Object Fread_from_minibuffer ();\nextern Lisp_Object Fread_variable ();\nextern Lisp_Object Fread_minibuffer (), Feval_minibuffer ();\nextern Lisp_Object Fread_string (), Fread_file_name ();\nextern Lisp_Object Fread_no_blanks_input ();\n\n/* Defined in callint.c */\n\nextern Lisp_Object Vcommand_history;\nextern Lisp_Object Qcall_interactively;\nextern Lisp_Object Fcall_interactively ();\nextern Lisp_Object Fprefix_numeric_value ();\n\n/* defined in casefiddle.c */\n\nextern Lisp_Object Fdowncase (), Fupcase (), Fcapitalize ();\n\n/* defined in keyboard.c */\n\nextern Lisp_Object Vhelp_form, Vtop_level;\nextern Lisp_Object Fdiscard_input (), Frecursive_edit ();\nextern Lisp_Object Fcommand_execute (), Finput_pending_p ();\nextern int poll_suppress_count;\n\n/* defined in keymap.c */\n\nextern Lisp_Object Qkeymap;\nextern Lisp_Object Fkey_description (), Fsingle_key_description ();\nextern Lisp_Object Fwhere_is_internal ();\nextern Lisp_Object access_keymap (), store_in_keymap ();\nextern Lisp_Object get_keyelt (), get_keymap();\n\n/* defined in indent.c */\nextern Lisp_Object Fvertical_motion (), Findent_to (), Fcurrent_column ();\n\n/* defined in window.c */\nextern Lisp_Object Qwindowp;\nextern Lisp_Object Fget_buffer_window ();\nextern Lisp_Object Fsave_window_excursion ();\nextern Lisp_Object Fset_window_configuration (), Fcurrent_window_configuration ();\n\n/* defined in emacs.c */\nextern Lisp_Object decode_env_path ();\n/* Nonzero means don't do interactive redisplay and don't change tty modes */\nextern int noninteractive;\n/* Nonzero means don't do use window-system-specific display code */\nextern int inhibit_window_system;\n\n/* defined in process.c */\nextern Lisp_Object Fget_process (), Fget_buffer_process (), Fprocessp ();\nextern Lisp_Object Fprocess_status (), Fkill_process ();\n\n/* defined in callproc.c */\nextern Lisp_Object Vexec_path, Vexec_directory;\n\n#ifdef MAINTAIN_ENVIRONMENT\n/* defined in environ.c */\nextern int size_of_current_environ ();\nextern void get_current_environ ();\n/* extern void current_environ (); */\nextern Lisp_Object Fgetenv ();\n#endif /* MAINTAIN_ENVIRONMENT */\n\n/* defined in doc.c */\nextern Lisp_Object Vdoc_file_name;\nextern Lisp_Object Fsubstitute_command_keys ();\nextern Lisp_Object Fdocumentation (), Fdocumentation_property ();\n\n/* defined in bytecode.c */\nextern Lisp_Object Qbytecode;\n\n/* defined in macros.c */\nextern Lisp_Object Fexecute_kbd_macro ();\n\n/* Nonzero means Emacs has already been initialized.\n   Used during startup to detect startup of dumped Emacs.  */\nextern int initialized;\n\nextern int immediate_quit;\t    /* Nonzero means ^G can quit instantly */\n\nextern void debugger ();\n\nextern char *malloc (), *realloc (), *getenv (), *ctime (), *getwd ();\nextern long *xmalloc (), *xrealloc ();\n\n#ifdef MAINTAIN_ENVIRONMENT\nextern unsigned char *egetenv ();\n#else\n#define egetenv getenv\n#endif\n"
  },
  "lineAnnotations": []
}