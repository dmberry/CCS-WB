{
  "id": "esolangs-2026-sample",
  "name": "2026 - Esoteric Programming Languages Collection",
  "mode": "critique",
  "description": "Five foundational esolangs (INTERCAL, FALSE, brainfuck, Befunge, Piet) demonstrating computational critique and hacker folk art",
  "era": "1990s",
  "codeFiles": [
    {
      "id": "file-1",
      "name": "README.md",
      "language": "markdown"
    },
    {
      "id": "file-2",
      "name": "intercal-hello.i",
      "language": "text"
    },
    {
      "id": "file-3",
      "name": "false-hello.f",
      "language": "text"
    },
    {
      "id": "file-4",
      "name": "brainfuck-hello.bf",
      "language": "text"
    },
    {
      "id": "file-5",
      "name": "befunge-hello.bf93",
      "language": "text"
    },
    {
      "id": "file-6",
      "name": "piet-explained.txt",
      "language": "text"
    }
  ],
  "codeContents": {
    "file-1": "# Esoteric Programming Languages Collection (2026)\n\n## Acknowledgment\n\nThis collection was inspired by Daniel Temkin's work documenting and creating esoteric programming languages, particularly his blog [esoteric.codes](https://esoteric.codes) and his writings on esolangs as hacker folk art. Temkin's insight that esolangs reveal \"what a pure code anti-style might look like\" opens crucial questions about computational rationality, productivity logic, and the aesthetic possibilities of code.\n\n## Historical Context\n\nEsoteric programming languages (esolangs) emerged as a form of computational critique and hacker folk art beginning in the 1970s. Unlike commercial languages (Python, Java) or academic research languages (ML, Prolog) that aim to minimize cognitive overhead and maximize productivity, esolangs deliberately break from computational norms. They ask: **What is code for? What forms can it take? What questions can it ask?**\n\nThe term \"esoteric\" signals these languages exist outside utilitarian programming—they are conceptual experiments, aesthetic objects, philosophical provocations, and playful subversions of what code \"should\" be. As Temkin observes, the most interesting possibilities of an esolang are often discovered not by its creator but through others' experiments, creating a collaborative spirit between language designer and programmer reminiscent of Oulipian constraint-based writing.\n\nEsolangs developed parallel to conceptual art practices without direct influence. Sol LeWitt's distinction between **concept** (general direction) and **idea** (specific realization) maps remarkably onto esolang design, where a language prompt can give rise to multiple interpretations. Some esolangs exist purely as concepts that \"run in our heads\" without needing implementation.\n\n## The Languages\n\nThis collection includes five foundational esolangs spanning 1972-2001, each representing a different approach to computational critique:\n\n### INTERCAL (1972)\n**Creators:** Don Woods and James M. Lyon\n**Approach:** Parody and politeness\n\nThe original esoteric language, created as a deliberate parody of languages like FORTRAN, COBOL, and ALGOL. INTERCAL's defining feature is its requirement for \"computational politeness\"—programmers must use PLEASE statements with appropriate frequency (too few and the compiler refuses to run; too many and it complains about excessive obsequiousness). The language inverts normal programming expectations: it has operators that are intentionally obscure (mingle, select), variable types that are absurd (16-bit and 32-bit integers only), and control flow that is deliberately confusing.\n\nRevived in 1990 as C-INTERCAL by Eric S. Raymond, INTERCAL became the founding document of esolang culture—a proof that languages need not serve efficiency or clarity.\n\n### FALSE (1993)\n**Creator:** Wouter van Oortmerssen\n**Approach:** Minimalism and compiler size\n\nFALSE was designed as an experiment in how small a compiler could be made. The original Amiga compiler was just 1024 bytes. FALSE uses single-character commands and a stack-based architecture, making programs extremely dense and difficult to parse visually. Every operation is a single ASCII character: `$` duplicates the top stack item, `%` drops it, `#` reads an integer, `.` prints an integer.\n\nFALSE demonstrates that eliminating readability in favor of compactness produces a valid but radically different mode of expression. The language asks: what is lost when we prioritize machine efficiency over human comprehension?\n\n### brainfuck (1993)\n**Creator:** Urban Müller\n**Approach:** Extreme minimalism and Turing tarpit\n\nPerhaps the most famous esolang, brainfuck reduces computation to eight single-character commands operating on a tape of memory cells and a pointer: `>` `<` `+` `-` `.` `,` `[` `]`. Despite (or because of) its brutal simplicity, brainfuck is Turing-complete—it can theoretically compute anything computable.\n\nThe name signals its hostile relationship to the programmer. Writing even simple programs requires intense mental effort, yet the language has inspired hundreds of derivatives and implementations. brainfuck is a \"Turing tarpit\"—a system that is technically universal but practically unusable. It reveals the gap between theoretical computability and actual usability.\n\n### Befunge (1993)\n**Creator:** Chris Pressey\n**Approach:** Two-dimensional code space\n\nBefunge treats code as a two-dimensional grid where execution can move up, down, left, or right based on directional commands (`^` `v` `<` `>`). The instruction pointer navigates this space, with code that can modify itself. Programs become spatial puzzles rather than linear sequences.\n\nBefunge challenges the assumption that code must be read left-to-right, top-to-bottom. It introduces spatiality, navigation, and self-modification as fundamental to program structure. The language asks: what if code occupied physical space we could traverse?\n\n### Piet (2001)\n**Creator:** David Morgan-Mar\n**Approach:** Visual aesthetics and color-based syntax\n\nNamed after Piet Mondrian, Piet programs are written as colored pixel grids resembling abstract modernist paintings. The language uses 20 distinct colors arranged in a color wheel. Program flow moves through blocks of color, with operations determined by hue and lightness changes between blocks.\n\nPiet makes explicit the aesthetic dimension of code. Programs are immediately recognizable as artworks, yet they execute real computation. Some Piet programmers hide code within larger images; others develop distinctive styles within its constraints. Piet asks: what if code were indistinguishable from visual art?\n\n## Critical Code Studies Value\n\nEsolangs are uniquely valuable for Critical Code Studies because they foreground normally invisible assumptions about what code is and does:\n\n### Computational Rationality and Productivity Logic\nEsolangs refuse the utilitarian mandate that code should be \"clean,\" \"efficient,\" \"maintainable,\" or \"production-ready.\" They reveal productivity as an ideological position rather than a neutral technical requirement. What happens when we design languages that deliberately obstruct rather than facilitate work?\n\n### Aesthetics and Anti-Style\nBy breaking from conventional syntax and semantics, esolangs make visible the aesthetic choices embedded in \"normal\" languages. Python's readability doctrine, C's pointer arithmetic, Java's verbosity—these are stylistic commitments, not inevitabilities. Esolangs explore what Temkin calls \"pure code anti-style.\"\n\n### Metaphor and Virtual Machines\nEvery programming language embodies a metaphor: stacks, heaps, objects, functions, cells, tapes. Esolangs make these metaphors strange again. Befunge's 2D grid and Piet's color blocks are no more or less metaphorical than C's memory model or JavaScript's prototype chain—they just refuse familiar abstractions.\n\n### Constraint and Creativity\nLike Oulipian writing (Georges Perec's *La Disparition* without the letter 'e'), esolangs use severe constraints to generate unexpected creativity. The constraint is not a limitation but a generative force. What new forms of expression emerge when normal programming is impossible?\n\n### Folk Art and Hacker Culture\nEsolangs exist outside both commercial and academic programming. They are hacker folk art—community-driven, playful, technically sophisticated, and philosophically rich. They document a programming culture that values wit, cleverness, and conceptual provocation over market value or research impact.\n\n### Conceptual Art and Dematerialization\nMany esolangs exist primarily as concepts. They \"run in our heads\" without needing implementation. This parallels conceptual art's dematerialization of the art object. The language-as-idea becomes more important than any particular program written in it.\n\n### Labor and Anti-Work\nEsolangs perform a kind of computational refusal. They waste machine cycles, frustrate programmers, and produce nothing of exchange value. In an economy where code is increasingly tied to platform capitalism and algorithmic governance, esolangs represent a space of uselessness, play, and anti-productivity.\n\n## Source\n\nThis is a curated collection of example programs representing five foundational esolangs. Each example is chosen to demonstrate the language's conceptual approach and aesthetic character.\n\n- **INTERCAL**: Original specification from 1972, revived 1990s\n- **FALSE**: Created 1993, minimal compiler experiment\n- **brainfuck**: Created 1993, extreme minimalism\n- **Befunge**: Created 1993, 2D spatial code\n- **Piet**: Created 2001, color-based visual programming\n\n**Primary Archive**: [esolangs.org](https://esolangs.org) - The community wiki documenting thousands of esoteric languages\n\n**Interpreters and Documentation**: Many implementations available under open source licenses (MIT, GPL, public domain)\n\n## Key Files Included\n\n1. **intercal-hello.i** - INTERCAL \"Hello World\" demonstrating PLEASE statements and computational politeness\n2. **false-hello.f** - FALSE stack-based hello world showing dense single-character syntax\n3. **brainfuck-hello.bf** - brainfuck hello world revealing the labor of extreme minimalism\n4. **befunge-hello.bf93** - Befunge 2D grid program with spatial navigation\n5. **piet-explained.txt** - Explanation of Piet's color-based visual programming (programs are images, not text)\n\n## Suggested Annotations\n\n### Computational Rationality\n1. How does INTERCAL's \"PLEASE\" requirement parody corporate politeness culture?\n2. What assumptions about programmer efficiency does FALSE violate?\n3. Is brainfuck's difficulty a bug or a feature? What does \"usability\" mean?\n4. How does Befunge's spatiality challenge linear thinking about program flow?\n5. What does Piet reveal about the invisibility of syntax in text-based languages?\n\n### Aesthetics and Style\n6. What is the \"style\" of brainfuck? Can we describe an aesthetic of minimalism in code?\n7. How does Befunge code \"look\" different from normal code on the page?\n8. Is Piet code more like visual art, written code, or something else entirely?\n9. What makes INTERCAL \"funny\"? How does humor function as critique?\n10. Does FALSE's density create a visual texture? What does this texture communicate?\n\n### Labor and Anti-Work\n11. How much mental labor does brainfuck demand compared to Python for the same task?\n12. Is writing in esolangs a form of computational handicraft vs. industrial programming?\n13. What is the \"productivity\" of an INTERCAL program that deliberately wastes time?\n14. Do esolangs represent refusal of programming as work?\n15. How does the difficulty of esolangs relate to \"code golf\" optimization culture?\n\n### Metaphor and Abstraction\n16. What is FALSE's \"stack\" metaphor? How does it differ from C's memory model?\n17. Befunge treats code as navigable space—what are the implications of this metaphor?\n18. brainfuck's \"tape\" recalls Turing machines—is this historical or conceptual reference?\n19. How does Piet's color wheel create a different kind of semantic system?\n20. What abstractions do we lose when we abandon variables, functions, and objects?\n\n### Community and Folk Art\n21. How does the esolangs.org wiki function as an archive of computational folk art?\n22. What role does playfulness serve in hacker culture vs. professional programming?\n23. Why do esolangers maintain \"to-do lists\" of unimplemented language ideas?\n24. How does esolang culture parallel the Oulipo literary movement?\n25. What makes an esolang \"successful\" if not practical utility?\n\n### Conceptual Art Parallels\n26. How does LeWitt's concept/idea distinction map onto esolang prompts and realizations?\n27. Can an esolang exist purely as a concept without implementation?\n28. Is reading an esolang description a form of \"executing\" it mentally?\n29. How does Piet's relationship to Mondrian parallel code poetry's relationship to literature?\n30. What does it mean for code to be \"dematerialized\" into pure concept?\n\n### Constraint and Oulipo\n31. How do esolang constraints generate creativity rather than limitation?\n32. Compare brainfuck's eight-character vocabulary to Perec's lipogram constraints\n33. Does constraint-based programming reveal anything about constraint-based writing?\n34. What new forms emerge when \"normal\" expression is impossible?\n35. Is the constraint itself the art object, or is it the programs written under constraint?\n\n### Philosophical Questions\n36. If Minesweeper accidentally simulates a computer, what does this say about computation?\n37. Can we separate a language's syntax from its semantics? Do esolangs help answer this?\n38. What is the ontological status of an unimplemented esolang?\n39. Is code inherently utilitarian, or can it exist for its own sake?\n40. Do esolangs reveal that all programming languages are equally arbitrary?\n\n## References\n\n### Primary Sources\n- Temkin, Daniel. *Forty-Four Esolangs: The Art of Esoteric Code*. MIT Press, 2025.\n- Temkin, Daniel. \"Esolangs as Experiential Art.\" *esoteric.codes* blog, 2015-2025.\n- Woods, Don, and James M. Lyon. \"INTERCAL Programming Language Reference Manual.\" 1972.\n- Raymond, Eric S. \"The INTERCAL Programming Language Revised Reference Manual.\" C-INTERCAL distribution, 1996.\n\n### Critical Code Studies\n- Marino, Mark C. *Critical Code Studies*. MIT Press, 2020.\n- Montfort, Nick, et al. *10 PRINT CHR$(205.5+RND(1)); : GOTO 10*. MIT Press, 2013.\n- Mackenzie, Adrian. *Cutting Code: Software and Sociality*. Peter Lang, 2006.\n\n### Software Studies and Digital Culture\n- Berry, David M. *Critical Theory and the Digital*. Bloomsbury, 2014.\n- Berry, David M. *The Philosophy of Software: Code and Mediation in the Digital Age*. Palgrave Macmillan, 2011.\n- Chun, Wendy Hui Kyong. *Programmed Visions: Software and Memory*. MIT Press, 2011.\n- Fuller, Matthew. *Software Studies: A Lexicon*. MIT Press, 2008.\n\n### Conceptual Art and Oulipo\n- LeWitt, Sol. \"Paragraphs on Conceptual Art.\" *Artforum*, June 1967.\n- Motte, Warren, ed. *Oulipo: A Primer of Potential Literature*. Dalkey Archive Press, 1998.\n- Mathews, Harry, and Alastair Brotchie, eds. *Oulipo Compendium*. Atlas Press, 2005.\n\n### Computing History and Hacker Culture\n- Levy, Steven. *Hackers: Heroes of the Computer Revolution*. O'Reilly, 2010.\n- Raymond, Eric S. *The New Hacker's Dictionary*. MIT Press, 1996.\n- Stallman, Richard M. \"The GNU Manifesto.\" 1985.\n\n### Philosophy of Technology\n- Hayles, N. Katherine. *My Mother Was a Computer: Digital Subjects and Literary Texts*. University of Chicago Press, 2005.\n- Kittler, Friedrich. \"There Is No Software.\" In *Literature, Media, Information Systems*, edited by John Johnston. Routledge, 1997.\n- Stiegler, Bernard. *Technics and Time, 1: The Fault of Epimetheus*. Stanford University Press, 1998.\n",
    "file-2": "INTERCAL \"Hello World\" Program\n===============================================================================\nLanguage: INTERCAL (Compiler Language With No Pronounceable Acronym)\nCreated: 1972 by Don Woods and James M. Lyon\nRevived: 1990 as C-INTERCAL by Eric S. Raymond\nPurpose: Parody language demonstrating computational politeness\n\nThis program outputs \"HELLO\" using INTERCAL's array output system.\nNote the PLEASE statements - INTERCAL requires appropriate politeness!\nToo few PLEASE statements (under 1/3) and the compiler rejects the code.\nToo many PLEASE statements (over 1/3) and the compiler complains of obsequiousness.\n\nThe cryptic numbers are INTERCAL's way of encoding ASCII characters.\nEach character is represented by numeric codes stored in array elements.\n\nPLEASE DO ,1 <- #13\nDO ,1 SUB #1 <- #238\nDO ,1 SUB #2 <- #108\nDO ,1 SUB #3 <- #112\nDO ,1 SUB #4 <- #0\nDO ,1 SUB #5 <- #64\nDO ,1 SUB #6 <- #194\nDO ,1 SUB #7 <- #48\nPLEASE DO ,1 SUB #8 <- #22\nDO ,1 SUB #9 <- #248\nDO ,1 SUB #10 <- #168\nDO ,1 SUB #11 <- #24\nDO ,1 SUB #12 <- #16\nDO ,1 SUB #13 <- #162\nPLEASE READ OUT ,1\nPLEASE GIVE UP\n",
    "file-3": "{\n===============================================================================\nFALSE \"Hello, World!\" Program\n===============================================================================\nLanguage: FALSE\nCreated: 1993 by Wouter van Oortmerssen\nPurpose: Minimalist stack-based language with tiny compiler (1024 bytes)\n\nFALSE uses single-character commands and stack operations:\n  number - Push integer to stack\n  , - Pop top of stack and output as ASCII character\n  . - Pop top of stack and output as integer\n  ' - Push next character's ASCII value to stack\n\nThis program outputs \"Hello, World!\" by pushing ASCII values and emitting them.\nEach character is pushed to stack (either as number or via ' character literal)\nand then immediately output with the , command.\n\nThe extreme density of single-character commands makes programs nearly\nunreadable, demonstrating the tension between machine efficiency and\nhuman comprehension. This is what a 1024-byte compiler produces.\n===============================================================================\n}\n\n72,'e,'l,'l,'o,',,' ,'W,'o,'r,'l,'d,'!,10,\n",
    "file-4": "===============================================================================\nbrainfuck \"Hello World!\" Program\n===============================================================================\nLanguage: brainfuck\nCreated: 1993 by Urban Müller\nPurpose: Extreme minimalism - Turing-complete with only 8 commands\n\nbrainfuck operates on a tape of memory cells with a pointer:\n> = Move pointer right\n< = Move pointer left\n+ = Increment current cell\n- = Decrement current cell\n. = Output current cell as ASCII character\n, = Input character to current cell\n[ = Jump forward past matching ] if current cell is zero\n] = Jump back to matching [ if current cell is non-zero\n\nThis program outputs \"Hello World!\" by incrementing cells to ASCII values.\nThe nested loops construct multiple values efficiently, then output them.\n\nWriting even simple programs requires intense mental effort, revealing\nthe gap between theoretical Turing-completeness and practical usability.\nbrainfuck is a \"Turing tarpit\" - technically universal, practically hostile.\n===============================================================================\n\n++++++++[>++++[>++>+++>+++>+<<<<-]>+>+>->>+[<]<-]>>.>---.+++++++..+++.>>.<-.<.+++.------.--------.>>+.>++.\n",
    "file-5": "===============================================================================\nBefunge \"Hello World!\" Program\n===============================================================================\nLanguage: Befunge-93\nCreated: 1993 by Chris Pressey\nPurpose: Two-dimensional code space with self-modification\n\nBefunge treats code as a 2D grid. The instruction pointer navigates this\nspace based on direction commands:\n> = Move right\n< = Move left\n^ = Move up\nv = Move down\n\nOther key commands:\n\" = Toggle string mode (push characters to stack)\n, = Pop and output as character\n* = Multiply top two stack values\n@ = End program\n\nThis program navigates a spatial grid to output \"Hello World!\".\nThe path moves right, down, left, creating flows through 2D space.\nCode becomes a navigable landscape rather than a linear sequence.\n\nBefunge challenges the assumption that code must be read left-to-right,\ntop-to-bottom, introducing spatiality as fundamental to program structure.\n===============================================================================\n\n>              v\nv  ,,,,,\"Hello\"<\n>48*,          v\nv,,,,,,\"World!\"<\n>25*,@\n",
    "file-6": "PIET PROGRAMMING LANGUAGE: VISUAL CODE AS ART\n\nPiet programs cannot be represented as text files - they ARE image files (PNG, GIF).\nPrograms consist of colored pixels arranged in grids, resembling abstract art.\n\nHOW PIET WORKS:\n\n1. COLOR WHEEL SEMANTICS\n   - 20 distinct colors arranged in a color wheel\n   - 6 hues: red, yellow, green, cyan, blue, magenta\n   - 3 lightness levels: light, normal, dark\n   - Plus black (wall) and white (free pass)\n\n2. PROGRAM EXECUTION\n   - Starts at top-left corner, moving right\n   - Direction pointer determines travel direction\n   - Codel chooser determines which edge to exit from\n   - Movement between color blocks determines operations\n\n3. OPERATIONS BY COLOR CHANGE\n   - Hue change: determines operation type\n   - Lightness change: modifies the operation\n\n   Examples:\n   - 1 hue step, no lightness = push\n   - 2 hue steps, no lightness = pop\n   - 3 hue steps, 1 lighter = add\n   - 1 hue step, 1 darker = duplicate\n\n4. VISUAL AESTHETICS\n   - Programs look like Mondrian paintings\n   - Code and art become indistinguishable\n   - Some hide programs in larger images\n   - Others develop signature styles\n\nEXAMPLE \"HELLO WORLD\" VISUAL DESCRIPTION:\n\nA typical Piet \"Hello World\" is a grid approximately 40x25 codels.\nIt contains:\n- Large colored blocks (10-20 codels) for pushing ASCII values\n- Thin single-codel strips for operations\n- Strategic black walls for direction changes\n- White corridors for pointer navigation\n\nThe visual appearance: blocky colored rectangles in reds, yellows, blues,\narranged to look vaguely like abstract geometric art. To the untrained eye,\nit could be confused with a small Mondrian composition or a pixelated\nretro game sprite.\n\nWHY PIET MATTERS FOR CRITICAL CODE STUDIES:\n\n1. Makes syntax visual rather than textual\n2. Foregrounds aesthetic choices in language design\n3. Collapses distinction between code and art object\n4. Demonstrates that \"readable code\" assumes text\n5. Creates community around style and interpretation\n\nVIEWING PIET PROGRAMS:\n\nTo see actual Piet programs:\n- Visit: https://www.dangermouse.net/esoteric/piet/samples.html\n- David Morgan-Mar's original gallery of example programs\n- Each program is downloadable as PNG or GIF\n- Includes \"Hello World\", pi calculator, and more complex programs\n\nPIET INTERPRETERS:\n\n- npiet: Official interpreter (C)\n- pietinterpreter: Java-based interpreter\n- Many online interpreters available\n- Can trace execution path visually\n\nCREATING PIET PROGRAMS:\n\nRequires either:\n- Image editor (manual pixel placement)\n- Specialized Piet IDE (PietDev, PietCreator)\n- Textual notation converted to image\n\nThe creative process is fundamentally different from text-based coding -\nit's spatial, visual, and aesthetic from the start.\n"
  }
}